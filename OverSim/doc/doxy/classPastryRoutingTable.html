<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OverSim: PastryRoutingTable Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">OverSim
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classPastryRoutingTable.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<div class="title">PastryRoutingTable Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="PastryRoutingTable" --><!-- doxytag: inherits="PastryStateObject" -->
<p>Routing table module.  
 <a href="classPastryRoutingTable.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="PastryRoutingTable_8h_source.html">PastryRoutingTable.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for PastryRoutingTable:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classPastryRoutingTable.png" usemap="#PastryRoutingTable_map" alt=""/>
  <map id="PastryRoutingTable_map" name="PastryRoutingTable_map">
<area href="classPastryStateObject.html" title="PastryStateObject Module." alt="PastryStateObject" shape="rect" coords="0,0,121,24"/>
</map>
 </div></div>

<p><a href="classPastryRoutingTable-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryRoutingTable.html#a3a4907994a66da808a72d17a77c93ee2">initializeTable</a> (uint32_t <a class="el" href="classPastryStateObject.html#a755bc90b0fb6bd61c42207d17855b743">bitsPerDigit</a>, double <a class="el" href="classPastryRoutingTable.html#aa22730d4147c929c205d86f4bda64c61">repairTimeout</a>, const <a class="el" href="classNodeHandle.html">NodeHandle</a> &amp;<a class="el" href="classPastryStateObject.html#a946cabf3c3e981122e05bb37bf1c95dc">owner</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the routing table.  <a href="#a3a4907994a66da808a72d17a77c93ee2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNodeHandle.html">NodeHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryRoutingTable.html#a0a3497ae41535458b14e31be32d5f6fc">lookupNextHop</a> (const <a class="el" href="classOverlayKey.html">OverlayKey</a> &amp;destination)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the next hop according to the <a class="el" href="classPastry.html" title="Pastry overlay module.">Pastry</a> routing scheme.  <a href="#a0a3497ae41535458b14e31be32d5f6fc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classNodeHandle.html">NodeHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryRoutingTable.html#a9f43c06e0a2d98f01c9b3809da0efae6">findCloserNode</a> (const <a class="el" href="classOverlayKey.html">OverlayKey</a> &amp;destination, bool optimize=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">try to find a node numerically closer to a given key with the same shared prefix as the current node in the routing table.  <a href="#a9f43c06e0a2d98f01c9b3809da0efae6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryRoutingTable.html#a0604bf72a6a6143d4cb8eb6a55e0b0f3">findCloserNodes</a> (const <a class="el" href="classOverlayKey.html">OverlayKey</a> &amp;destination, <a class="el" href="NodeVector_8h.html#a442f90b66b22aa9fca51f83c5ce1b02b">NodeVector</a> *nodes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classTransportAddress.html">TransportAddress</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryRoutingTable.html#ae440c8aa89543afc2147b8784be93c41">failedNode</a> (const <a class="el" href="classTransportAddress.html">TransportAddress</a> &amp;failed)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">tells the routing table that a node has failed  <a href="#ae440c8aa89543afc2147b8784be93c41"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classTransportAddress.html">TransportAddress</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryRoutingTable.html#a632d81ee59ded7bc2249b64555b3bb78">repair</a> (const <a class="el" href="classPastryStateMessage.html">PastryStateMessage</a> *msg, const <a class="el" href="structPastryStateMsgProximity.html">PastryStateMsgProximity</a> *prox)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">attempt to repair the routing using a received REPAIR message  <a href="#a632d81ee59ded7bc2249b64555b3bb78"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryRoutingTable.html#a1d4e337dda181b732aa96cd5d5007a42">dumpToStateMessage</a> (<a class="el" href="classPastryStateMessage.html">PastryStateMessage</a> *msg) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">dump content of the table to a <a class="el" href="classPastryStateMessage.html">PastryStateMessage</a>  <a href="#a1d4e337dda181b732aa96cd5d5007a42"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryRoutingTable.html#a3bf3d796d20167be722fdcff57f19944">dumpRowToMessage</a> (<a class="el" href="classPastryStateMessage.html">PastryStateMessage</a> *msg, int row) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">dump content of a single row of the routing table to a state message  <a href="#a3bf3d796d20167be722fdcff57f19944"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryRoutingTable.html#a449b7e0abcd2be8a93816669201bfc4c">getLastRow</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the number of rows in the routing table  <a href="#a449b7e0abcd2be8a93816669201bfc4c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classTransportAddress.html">TransportAddress</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryRoutingTable.html#a092e213c15bf70d632dcae0f313bbe01">getRow</a> (uint8_t row) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classTransportAddress.html">TransportAddress</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryRoutingTable.html#a37d02a2bda67fe9618b382f321a532d3">getRandomNode</a> (int row)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a random node from the routing table  <a href="#a37d02a2bda67fe9618b382f321a532d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryRoutingTable.html#a92eb6e9176f873cb0a7106ce6e97a53e">mergeNode</a> (const <a class="el" href="classNodeHandle.html">NodeHandle</a> &amp;node, simtime_t prox)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">merge a node in the IRoutingTable  <a href="#a92eb6e9176f873cb0a7106ce6e97a53e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryRoutingTable.html#aa5222c6a0ecd848658dd51b8d93b7fc3">initStateFromHandleVector</a> (const std::vector&lt; <a class="el" href="structPastryStateMsgHandle.html">PastryStateMsgHandle</a> &gt; &amp;handles)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">initialize table from vector of PastryStateMsgHandles with STATE messages received during JOIN phase.  <a href="#aa5222c6a0ecd848658dd51b8d93b7fc3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryRoutingTable.html#aed1ca355690a9e0354a420bf7c96e3a4">dumpToVector</a> (std::vector&lt; <a class="el" href="classTransportAddress.html">TransportAddress</a> &gt; &amp;affected) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">appends all routing table entries to a given vector of TransportAddresses, needed to find all Nodes to be notified after joining.  <a href="#aed1ca355690a9e0354a420bf7c96e3a4"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryRoutingTable.html#a0b87befd6ebf85f6c6cdf3303d386b88">nodesPerRow</a></td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryRoutingTable.html#a1c3b854b710dba7cc56abc427980fbec">earlyInit</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">initialize watches etc.  <a href="#a1c3b854b710dba7cc56abc427980fbec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryRoutingTable.html#a4a364fc06948408b322cd12d7988bccc">addRow</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">adds a new line to the routing table  <a href="#a4a364fc06948408b322cd12d7988bccc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryRoutingTable.html#a4b84eeabf2d6da3509c9159b0c1c4beb">digitAt</a> (uint32_t n, const <a class="el" href="classOverlayKey.html">OverlayKey</a> &amp;key) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns n'th pastry digit from a key  <a href="#a4b84eeabf2d6da3509c9159b0c1c4beb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structPastryExtendedNode.html">PastryExtendedNode</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryRoutingTable.html#a8ecdfb9dca39fcf3bb0e5418fec9d78c">nodeAt</a> (uint32_t row, uint32_t col) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns routing table entry at specified position  <a href="#a8ecdfb9dca39fcf3bb0e5418fec9d78c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryRoutingTable.html#a129c1c2b0591a8c6a6c1c7eae380131e">findNextNodeToAsk</a> (<a class="el" href="structPRTTrackRepair.html">PRTTrackRepair</a> &amp;track) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">helper function, updates a <a class="el" href="structPRTTrackRepair.html" title="Struct for tracking attempts to repair a routing table entry.">PRTTrackRepair</a> structure to point to the next node that can be asked for repair  <a href="#a129c1c2b0591a8c6a6c1c7eae380131e"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryRoutingTable.html#aa22730d4147c929c205d86f4bda64c61">repairTimeout</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="PastryRoutingTable_8h.html#aef87e32a9d3f457c82682f7d416ff0dd">PRTRow</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryRoutingTable.html#a9ad52acd8b712f0b841806b9e193fb4a">rows</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structPRTTrackRepair.html">PRTTrackRepair</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryRoutingTable.html#adcd9c4e275d1036afd0fe371b53d4d00">awaitingRepair</a></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Routing table module. </p>
<p>This module contains the routing table of the Chord implementation.</p>
<dl class="author"><dt><b>Author:</b></dt><dd>Felix Palmen </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classPastry.html" title="Pastry overlay module.">Pastry</a> </dd></dl>

<p>Definition at line <a class="el" href="PastryRoutingTable_8h_source.html#l00064">64</a> of file <a class="el" href="PastryRoutingTable_8h_source.html">PastryRoutingTable.h</a>.</p>
</div><hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a4a364fc06948408b322cd12d7988bccc"></a><!-- doxytag: member="PastryRoutingTable::addRow" ref="a4a364fc06948408b322cd12d7988bccc" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PastryRoutingTable::addRow </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>adds a new line to the routing table </p>

<p>Definition at line <a class="el" href="PastryRoutingTable_8cc_source.html#l00354">354</a> of file <a class="el" href="PastryRoutingTable_8cc_source.html">PastryRoutingTable.cc</a>.</p>

<p>Referenced by <a class="el" href="PastryRoutingTable_8cc_source.html#l00043">initializeTable()</a>, and <a class="el" href="PastryRoutingTable_8cc_source.html#l00297">mergeNode()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="PastryRoutingTable_8h.html#aef87e32a9d3f457c82682f7d416ff0dd" title="Vector-type of a line in Pastry IRoutingTable.">PRTRow</a> row(<a class="code" href="classPastryRoutingTable.html#a0b87befd6ebf85f6c6cdf3303d386b88">nodesPerRow</a>, <a class="code" href="classPastryStateObject.html#a957e9ac8870e9f03df83f85ff4d8cf7b">unspecNode</a>());

    <span class="comment">// place own node at correct position:</span>
    (row.begin() + <a class="code" href="classPastryRoutingTable.html#a4b84eeabf2d6da3509c9159b0c1c4beb" title="returns n&#39;th pastry digit from a key">digitAt</a>(<a class="code" href="classPastryRoutingTable.html#a9ad52acd8b712f0b841806b9e193fb4a">rows</a>.size(), <a class="code" href="classPastryStateObject.html#a946cabf3c3e981122e05bb37bf1c95dc" title="stores the NodeHandle of the owner of this PastryStateObject.">owner</a>.<a class="code" href="classNodeHandle.html#aef531103cdf07c8353267f4d30a80112" title="returns key of this NodeHandle">getKey</a>()))-&gt;node = <a class="code" href="classPastryStateObject.html#a946cabf3c3e981122e05bb37bf1c95dc" title="stores the NodeHandle of the owner of this PastryStateObject.">owner</a>;
    <a class="code" href="classPastryRoutingTable.html#a9ad52acd8b712f0b841806b9e193fb4a">rows</a>.push_back(row);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a4b84eeabf2d6da3509c9159b0c1c4beb"></a><!-- doxytag: member="PastryRoutingTable::digitAt" ref="a4b84eeabf2d6da3509c9159b0c1c4beb" args="(uint32_t n, const OverlayKey &amp;key) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PastryRoutingTable::digitAt </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOverlayKey.html">OverlayKey</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns n'th pastry digit from a key </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>which digit to return </td></tr>
    <tr><td class="paramname">key</td><td>extract digit from this key </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pastry digit </dd></dl>

<p>Definition at line <a class="el" href="PastryRoutingTable_8cc_source.html#l00029">29</a> of file <a class="el" href="PastryRoutingTable_8cc_source.html">PastryRoutingTable.cc</a>.</p>

<p>Referenced by <a class="el" href="PastryRoutingTable_8cc_source.html#l00354">addRow()</a>, <a class="el" href="PastryRoutingTable_8cc_source.html#l00096">findCloserNode()</a>, <a class="el" href="PastryRoutingTable_8cc_source.html#l00073">lookupNextHop()</a>, and <a class="el" href="PastryRoutingTable_8cc_source.html#l00297">mergeNode()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">return</span> key.<a class="code" href="classOverlayKey.html#a25b2a67642f29fe2035a0abf74de3dd1" title="Returns a sub integer at position p with n-bits.">getBitRange</a>(<a class="code" href="classOverlayKey.html#af855a4dfc0e5dc0d2afc6b87fa1d7426" title="Returns the length in number of bits.">OverlayKey::getLength</a>() - ++n * <a class="code" href="classPastryStateObject.html#a755bc90b0fb6bd61c42207d17855b743">bitsPerDigit</a>,
                           bitsPerDigit);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a3bf3d796d20167be722fdcff57f19944"></a><!-- doxytag: member="PastryRoutingTable::dumpRowToMessage" ref="a3bf3d796d20167be722fdcff57f19944" args="(PastryStateMessage *msg, int row) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PastryRoutingTable::dumpRowToMessage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPastryStateMessage.html">PastryStateMessage</a> *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>dump content of a single row of the routing table to a state message </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>the state message to be filled with entries </td></tr>
    <tr><td class="paramname">row</td><td>the number of the row </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="PastryRoutingTable_8cc_source.html#l00217">217</a> of file <a class="el" href="PastryRoutingTable_8cc_source.html">PastryRoutingTable.cc</a>.</p>

<p>Referenced by <a class="el" href="BasePastry_8cc_source.html#l00664">BasePastry::createStateMessage()</a>.</p>
<div class="fragment"><pre class="fragment">{
    uint32_t i = 0;
    uint32_t size = 0;
    std::vector&lt;PRTRow&gt;::const_iterator itRows;
    PRTRow::const_iterator itCols;

    msg-&gt;<a class="code" href="classPastryStateMessage.html#a1432ce9c20f9ef89f14fa3fb1384d3f3">setRoutingTableArraySize</a>(<a class="code" href="classPastryRoutingTable.html#a0b87befd6ebf85f6c6cdf3303d386b88">nodesPerRow</a>);
    <span class="keywordflow">if</span> ((row == -1) || (row &gt; (<span class="keywordtype">int</span>)<a class="code" href="classPastryRoutingTable.html#a9ad52acd8b712f0b841806b9e193fb4a">rows</a>.size())) {
        itRows = <a class="code" href="classPastryRoutingTable.html#a9ad52acd8b712f0b841806b9e193fb4a">rows</a>.end() - 1;
    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (row &gt; (<span class="keywordtype">int</span>)<a class="code" href="classPastryRoutingTable.html#a9ad52acd8b712f0b841806b9e193fb4a">rows</a>.size()) {
        EV &lt;&lt; <span class="stringliteral">&quot;asked for nonexistent row&quot;</span>;
        <span class="comment">// TODO: verify this - added by ib</span>
        msg-&gt;<a class="code" href="classPastryStateMessage.html#a1432ce9c20f9ef89f14fa3fb1384d3f3">setRoutingTableArraySize</a>(0);
        <span class="keywordflow">return</span>;
    } <span class="keywordflow">else</span> {
        itRows = <a class="code" href="classPastryRoutingTable.html#a9ad52acd8b712f0b841806b9e193fb4a">rows</a>.begin() + row - 1;
    }
    <span class="keywordflow">for</span> (itCols = itRows-&gt;begin(); itCols != itRows-&gt;end(); itCols++) {
        <span class="keywordflow">if</span> (!itCols-&gt;node.isUnspecified()) {
            ++size;
            msg-&gt;<a class="code" href="classPastryStateMessage.html#a92f3cfd3a8a76a8271634cef30ae51b7">setRoutingTable</a>(i++, itCols-&gt;node);
        }
    }
    <span class="comment">// TODO: verify this - added by ib</span>
    msg-&gt;<a class="code" href="classPastryStateMessage.html#a1432ce9c20f9ef89f14fa3fb1384d3f3">setRoutingTableArraySize</a>(size);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a1d4e337dda181b732aa96cd5d5007a42"></a><!-- doxytag: member="PastryRoutingTable::dumpToStateMessage" ref="a1d4e337dda181b732aa96cd5d5007a42" args="(PastryStateMessage *msg) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PastryRoutingTable::dumpToStateMessage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPastryStateMessage.html">PastryStateMessage</a> *&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>dump content of the table to a <a class="el" href="classPastryStateMessage.html">PastryStateMessage</a> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>the <a class="el" href="classPastryStateMessage.html">PastryStateMessage</a> to be filled with entries </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classPastryStateObject.html#a6df4273e063990435c7766cae4f1b83a">PastryStateObject</a>.</p>

<p>Definition at line <a class="el" href="PastryRoutingTable_8cc_source.html#l00196">196</a> of file <a class="el" href="PastryRoutingTable_8cc_source.html">PastryRoutingTable.cc</a>.</p>

<p>Referenced by <a class="el" href="BasePastry_8cc_source.html#l00664">BasePastry::createStateMessage()</a>.</p>
<div class="fragment"><pre class="fragment">{
    uint32_t i = 0;
    uint32_t size = 0;
    std::vector&lt;PRTRow&gt;::const_iterator itRows;
    PRTRow::const_iterator itCols;

    msg-&gt;<a class="code" href="classPastryStateMessage.html#a1432ce9c20f9ef89f14fa3fb1384d3f3">setRoutingTableArraySize</a>(<a class="code" href="classPastryRoutingTable.html#a9ad52acd8b712f0b841806b9e193fb4a">rows</a>.size() * <a class="code" href="classPastryRoutingTable.html#a0b87befd6ebf85f6c6cdf3303d386b88">nodesPerRow</a>);

    <span class="keywordflow">for</span> (itRows = <a class="code" href="classPastryRoutingTable.html#a9ad52acd8b712f0b841806b9e193fb4a">rows</a>.begin(); itRows != <a class="code" href="classPastryRoutingTable.html#a9ad52acd8b712f0b841806b9e193fb4a">rows</a>.end(); itRows++) {
        <span class="keywordflow">for</span> (itCols = itRows-&gt;begin(); itCols != itRows-&gt;end(); itCols++) {
            <span class="keywordflow">if</span> (!itCols-&gt;node.isUnspecified()) {
                ++size;
                msg-&gt;<a class="code" href="classPastryStateMessage.html#a92f3cfd3a8a76a8271634cef30ae51b7">setRoutingTable</a>(i++, itCols-&gt;node);
            }
        }
    }
    msg-&gt;<a class="code" href="classPastryStateMessage.html#a1432ce9c20f9ef89f14fa3fb1384d3f3">setRoutingTableArraySize</a>(size);
}
</pre></div>
</div>
</div>
<a class="anchor" id="aed1ca355690a9e0354a420bf7c96e3a4"></a><!-- doxytag: member="PastryRoutingTable::dumpToVector" ref="aed1ca355690a9e0354a420bf7c96e3a4" args="(std::vector&lt; TransportAddress &gt; &amp;affected) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PastryRoutingTable::dumpToVector </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTransportAddress.html">TransportAddress</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>affected</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>appends all routing table entries to a given vector of TransportAddresses, needed to find all Nodes to be notified after joining. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">affected</td><td>the vector to fill with routing table entries </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classPastryStateObject.html#ac677c6c0df6213694165eb3ee912c85e">PastryStateObject</a>.</p>

<p>Definition at line <a class="el" href="PastryRoutingTable_8cc_source.html#l00342">342</a> of file <a class="el" href="PastryRoutingTable_8cc_source.html">PastryRoutingTable.cc</a>.</p>

<p>Referenced by <a class="el" href="Pastry_8cc_source.html#l00161">Pastry::changeState()</a>, and <a class="el" href="Pastry_8cc_source.html#l00804">Pastry::doSecondStage()</a>.</p>
<div class="fragment"><pre class="fragment">{
    std::vector&lt;PRTRow&gt;::const_iterator itRows;
    PRTRow::const_iterator itCols;

    <span class="keywordflow">for</span> (itRows = <a class="code" href="classPastryRoutingTable.html#a9ad52acd8b712f0b841806b9e193fb4a">rows</a>.begin(); itRows != <a class="code" href="classPastryRoutingTable.html#a9ad52acd8b712f0b841806b9e193fb4a">rows</a>.end(); ++itRows)
        <span class="keywordflow">for</span> (itCols = itRows-&gt;begin(); itCols != itRows-&gt;end(); ++itCols)
            <span class="keywordflow">if</span> (!itCols-&gt;node.isUnspecified())
                affected.push_back(itCols-&gt;node);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a1c3b854b710dba7cc56abc427980fbec"></a><!-- doxytag: member="PastryRoutingTable::earlyInit" ref="a1c3b854b710dba7cc56abc427980fbec" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PastryRoutingTable::earlyInit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [private, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>initialize watches etc. </p>

<p>Implements <a class="el" href="classPastryStateObject.html#a711a095dc7d08c3ee45c4f8bdaf27fce">PastryStateObject</a>.</p>

<p>Definition at line <a class="el" href="PastryRoutingTable_8cc_source.html#l00037">37</a> of file <a class="el" href="PastryRoutingTable_8cc_source.html">PastryRoutingTable.cc</a>.</p>
<div class="fragment"><pre class="fragment">{
    WATCH_VECTOR(<a class="code" href="classPastryRoutingTable.html#a9ad52acd8b712f0b841806b9e193fb4a">rows</a>);
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae440c8aa89543afc2147b8784be93c41"></a><!-- doxytag: member="PastryRoutingTable::failedNode" ref="ae440c8aa89543afc2147b8784be93c41" args="(const TransportAddress &amp;failed)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTransportAddress.html">TransportAddress</a> &amp; PastryRoutingTable::failedNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTransportAddress.html">TransportAddress</a> &amp;&#160;</td>
          <td class="paramname"><em>failed</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>tells the routing table that a node has failed </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">failed</td><td>the failed node </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a node to ask for REPAIR or <a class="el" href="classTransportAddress.html#ac1709545db722cbbce1367034142d31f" title="TransportAddress without specified ip and port.">TransportAddress::UNSPECIFIED_NODE</a> </dd></dl>

<p>Implements <a class="el" href="classPastryStateObject.html#aac3ee89c4129465def00861424f232e3">PastryStateObject</a>.</p>

<p>Definition at line <a class="el" href="PastryRoutingTable_8cc_source.html#l00378">378</a> of file <a class="el" href="PastryRoutingTable_8cc_source.html">PastryRoutingTable.cc</a>.</p>

<p>Referenced by <a class="el" href="Bamboo_8cc_source.html#l00299">Bamboo::handleFailedNode()</a>, and <a class="el" href="Pastry_8cc_source.html#l00886">Pastry::handleFailedNode()</a>.</p>
<div class="fragment"><pre class="fragment">{
    std::vector&lt;PRTRow&gt;::iterator itRows;
    PRTRow::iterator itCols;
    <a class="code" href="structPRTTrackRepair.html" title="Struct for tracking attempts to repair a routing table entry.">PRTTrackRepair</a> tmpTrack;

    <span class="keywordtype">bool</span> found = <span class="keyword">false</span>;

    <span class="comment">// find node in table:</span>
    <span class="keywordflow">for</span> (itRows = <a class="code" href="classPastryRoutingTable.html#a9ad52acd8b712f0b841806b9e193fb4a">rows</a>.begin(); itRows != <a class="code" href="classPastryRoutingTable.html#a9ad52acd8b712f0b841806b9e193fb4a">rows</a>.end(); itRows++) {
        <span class="keywordflow">for</span> (itCols = itRows-&gt;begin(); itCols != itRows-&gt;end(); itCols++) {
            <span class="keywordflow">if</span> ((! itCols-&gt;node.isUnspecified()) &amp;&amp;
                    (itCols-&gt;node.getIp() == failed.<a class="code" href="classTransportAddress.html#a00e613d98d3412e2b92897c25aa0eb4c" title="returns ip address">getIp</a>())) {
                itCols-&gt;<a class="code" href="structPRTTrackRepair.html#afe07e90cb15c3738b8b55474f3d9ffe7">node</a> = <a class="code" href="classNodeHandle.html#a79bf2c5e29c969cbd0b2581cb188d8a6" title="the unspecified NodeHandle">NodeHandle::UNSPECIFIED_NODE</a>;
                itCols-&gt;rtt = <a class="code" href="PastryTypes_8h.html#ac72c42e64b55779864ac448c6a71a0e2" title="value for undefined proximity:">PASTRY_PROX_UNDEF</a>;
                found = <span class="keyword">true</span>;
                <span class="keywordflow">break</span>;
            }
        }
        <span class="keywordflow">if</span> (found) <span class="keywordflow">break</span>;
    }

    <span class="comment">// not found, nothing to do:</span>
    <span class="keywordflow">if</span> (!found) <span class="keywordflow">return</span> <a class="code" href="classTransportAddress.html#ac1709545db722cbbce1367034142d31f" title="TransportAddress without specified ip and port.">TransportAddress::UNSPECIFIED_NODE</a>;

    <span class="comment">// else fill temporary record:</span>
    tmpTrack.<a class="code" href="structPRTTrackRepair.html#aad132b6672452a53d916e7d938aca33e">failedRow</a> = itRows - <a class="code" href="classPastryRoutingTable.html#a9ad52acd8b712f0b841806b9e193fb4a">rows</a>.begin();
    tmpTrack.<a class="code" href="structPRTTrackRepair.html#af1311e8d338fb3aa0a43dfc065261205">failedCol</a> = itCols - itRows-&gt;begin();
    tmpTrack.<a class="code" href="structPRTTrackRepair.html#afe07e90cb15c3738b8b55474f3d9ffe7">node</a> = <a class="code" href="classTransportAddress.html#ac1709545db722cbbce1367034142d31f" title="TransportAddress without specified ip and port.">TransportAddress::UNSPECIFIED_NODE</a>;
    <a class="code" href="classPastryRoutingTable.html#a129c1c2b0591a8c6a6c1c7eae380131e" title="helper function, updates a PRTTrackRepair structure to point to the next node that can be asked for r...">findNextNodeToAsk</a>(tmpTrack);
    tmpTrack.<a class="code" href="structPRTTrackRepair.html#a69f96a0571527c092f7890a185f39520">timestamp</a> = simTime();

    <span class="keywordflow">if</span> (tmpTrack.<a class="code" href="structPRTTrackRepair.html#afe07e90cb15c3738b8b55474f3d9ffe7">node</a>.<a class="code" href="classTransportAddress.html#a026e777c423ff2a0280edd2fa5472e74" title="indicates if TransportAddress is specified">isUnspecified</a>())
        <span class="keywordflow">return</span> <a class="code" href="classTransportAddress.html#ac1709545db722cbbce1367034142d31f" title="TransportAddress without specified ip and port.">TransportAddress::UNSPECIFIED_NODE</a>;
    <a class="code" href="classPastryRoutingTable.html#adcd9c4e275d1036afd0fe371b53d4d00">awaitingRepair</a>.push_back(tmpTrack);
    <span class="keywordflow">return</span> <a class="code" href="classPastryRoutingTable.html#adcd9c4e275d1036afd0fe371b53d4d00">awaitingRepair</a>.back().node;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a9f43c06e0a2d98f01c9b3809da0efae6"></a><!-- doxytag: member="PastryRoutingTable::findCloserNode" ref="a9f43c06e0a2d98f01c9b3809da0efae6" args="(const OverlayKey &amp;destination, bool optimize=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNodeHandle.html">NodeHandle</a> &amp; PastryRoutingTable::findCloserNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOverlayKey.html">OverlayKey</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>optimize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>try to find a node numerically closer to a given key with the same shared prefix as the current node in the routing table. </p>
<p>this method is to be called, when a regular next hop couldn't be found or wasn't reachable.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>the destination key </td></tr>
    <tr><td class="paramname">optimize</td><td>if set, check all nodes and return the best/closest one </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a closer <a class="el" href="classNodeHandle.html" title="This class implements a node handle.">NodeHandle</a> or <a class="el" href="classNodeHandle.html#a79bf2c5e29c969cbd0b2581cb188d8a6" title="the unspecified NodeHandle">NodeHandle::UNSPECIFIED_NODE</a> if none was found </dd></dl>

<p>Implements <a class="el" href="classPastryStateObject.html#a5bc159769dfdcd95ceaaf6055798b743">PastryStateObject</a>.</p>

<p>Definition at line <a class="el" href="PastryRoutingTable_8cc_source.html#l00096">96</a> of file <a class="el" href="PastryRoutingTable_8cc_source.html">PastryRoutingTable.cc</a>.</p>

<p>Referenced by <a class="el" href="BasePastry_8cc_source.html#l00906">BasePastry::findNode()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> (destination == <a class="code" href="classPastryStateObject.html#a946cabf3c3e981122e05bb37bf1c95dc" title="stores the NodeHandle of the owner of this PastryStateObject.">owner</a>.<a class="code" href="classNodeHandle.html#aef531103cdf07c8353267f4d30a80112" title="returns key of this NodeHandle">getKey</a>())
        opp_error(<span class="stringliteral">&quot;trying to find closer node to own key!&quot;</span>);

    <span class="keyword">const</span> <a class="code" href="structPastryExtendedNode.html" title="struct for storing a NodeHandle together with its proximity value and an optional timestamp...">PastryExtendedNode</a>* entry;

    <span class="keywordflow">if</span> (optimize) {
        <span class="comment">// pointer to later return value, initialize to unspecified, so</span>
        <span class="comment">// the specialCloserCondition() check will be done against our own</span>
        <span class="comment">// node as long as no node closer to the destination than our own was</span>
        <span class="comment">// found.</span>
        <span class="keyword">const</span> <a class="code" href="classNodeHandle.html" title="This class implements a node handle.">NodeHandle</a>* ret = &amp;<a class="code" href="classNodeHandle.html#a79bf2c5e29c969cbd0b2581cb188d8a6" title="the unspecified NodeHandle">NodeHandle::UNSPECIFIED_NODE</a>;

        <span class="comment">// a numerically closer node can only be found in the row containing</span>
        <span class="comment">// nodes with the same prefix length and in the row above.</span>
        <span class="keywordtype">int</span> shl = <a class="code" href="classPastryStateObject.html#a946cabf3c3e981122e05bb37bf1c95dc" title="stores the NodeHandle of the owner of this PastryStateObject.">owner</a>.<a class="code" href="classNodeHandle.html#aef531103cdf07c8353267f4d30a80112" title="returns key of this NodeHandle">getKey</a>().<a class="code" href="classOverlayKey.html#a0a44da45d3d52ce2ad76dad4e06a2888" title="Calculates the number of equal bits (digits) from the left with another Key (shared prefix length)...">sharedPrefixLength</a>(destination) / <a class="code" href="classPastryStateObject.html#a755bc90b0fb6bd61c42207d17855b743">bitsPerDigit</a>;
        <span class="keywordtype">int</span> digit = <a class="code" href="classPastryRoutingTable.html#a4b84eeabf2d6da3509c9159b0c1c4beb" title="returns n&#39;th pastry digit from a key">digitAt</a>(shl, destination);
        <span class="keywordtype">int</span> x = <a class="code" href="classPastryRoutingTable.html#a4b84eeabf2d6da3509c9159b0c1c4beb" title="returns n&#39;th pastry digit from a key">digitAt</a>(shl, <a class="code" href="classPastryStateObject.html#a946cabf3c3e981122e05bb37bf1c95dc" title="stores the NodeHandle of the owner of this PastryStateObject.">owner</a>.<a class="code" href="classNodeHandle.html#aef531103cdf07c8353267f4d30a80112" title="returns key of this NodeHandle">getKey</a>()); <span class="comment">// position index of own node</span>

        <span class="comment">// first try the row with same prefix length:</span>
        <span class="keywordtype">int</span> n = <a class="code" href="classPastryRoutingTable.html#a0b87befd6ebf85f6c6cdf3303d386b88">nodesPerRow</a>;
        <span class="keywordtype">int</span> a = digit - 1; <span class="comment">// position index of search to the left</span>
        <span class="keywordtype">int</span> b = digit + 1; <span class="comment">// position index of search to the right</span>

        <span class="keywordflow">while</span> ((a &gt;= 0) || (b &lt; n)) {
            <span class="comment">// no need to continue search in one direction when own entry is</span>
            <span class="comment">// reached:</span>
            <span class="keywordflow">if</span> (a == x) a = -1;
            <span class="keywordflow">if</span> (b == x) b = n;

            <span class="keywordflow">if</span> (a &gt;= 0) {
                entry = &amp;(<a class="code" href="classPastryRoutingTable.html#a8ecdfb9dca39fcf3bb0e5418fec9d78c" title="returns routing table entry at specified position">nodeAt</a>(shl, a));
                <span class="keywordflow">if</span> ((!entry-&gt;<a class="code" href="structPastryExtendedNode.html#a4b5835436cdf9648b60e69e2c1fb2777">node</a>.<a class="code" href="classNodeHandle.html#ab5136375a4548ced7c2014a73c8743c9" title="indicates if this NodeHandle is specified">isUnspecified</a>()) &amp;&amp;
                        <a class="code" href="classPastryStateObject.html#a13a6c5fdcbe191dc45619aeaa29f1993" title="test a given NodeHandle if it is closer to a given destination, but only if the shared prefix length ...">specialCloserCondition</a>(entry-&gt;<a class="code" href="structPastryExtendedNode.html#a4b5835436cdf9648b60e69e2c1fb2777">node</a>, destination, *ret))
                    ret = &amp;(entry-&gt;<a class="code" href="structPastryExtendedNode.html#a4b5835436cdf9648b60e69e2c1fb2777">node</a>);
                a--;
            }
            <span class="keywordflow">if</span> (b &lt; n) {
                entry = &amp;(<a class="code" href="classPastryRoutingTable.html#a8ecdfb9dca39fcf3bb0e5418fec9d78c" title="returns routing table entry at specified position">nodeAt</a>(shl, b));
                <span class="keywordflow">if</span> ((!entry-&gt;<a class="code" href="structPastryExtendedNode.html#a4b5835436cdf9648b60e69e2c1fb2777">node</a>.<a class="code" href="classNodeHandle.html#ab5136375a4548ced7c2014a73c8743c9" title="indicates if this NodeHandle is specified">isUnspecified</a>()) &amp;&amp;
                        <a class="code" href="classPastryStateObject.html#a13a6c5fdcbe191dc45619aeaa29f1993" title="test a given NodeHandle if it is closer to a given destination, but only if the shared prefix length ...">specialCloserCondition</a>(entry-&gt;<a class="code" href="structPastryExtendedNode.html#a4b5835436cdf9648b60e69e2c1fb2777">node</a>, destination, *ret))
                    ret = &amp;(entry-&gt;<a class="code" href="structPastryExtendedNode.html#a4b5835436cdf9648b60e69e2c1fb2777">node</a>);
                b++;
            }
        }

        <span class="comment">// it this was not the first row, two more nodes to check:</span>
        <span class="keywordflow">if</span> (shl != 0) {
            <span class="comment">// go up one row:</span>
            x = <a class="code" href="classPastryRoutingTable.html#a4b84eeabf2d6da3509c9159b0c1c4beb" title="returns n&#39;th pastry digit from a key">digitAt</a>(--shl, <a class="code" href="classPastryStateObject.html#a946cabf3c3e981122e05bb37bf1c95dc" title="stores the NodeHandle of the owner of this PastryStateObject.">owner</a>.<a class="code" href="classNodeHandle.html#aef531103cdf07c8353267f4d30a80112" title="returns key of this NodeHandle">getKey</a>());

            <span class="keywordflow">if</span> (destination &lt; <a class="code" href="classPastryStateObject.html#a946cabf3c3e981122e05bb37bf1c95dc" title="stores the NodeHandle of the owner of this PastryStateObject.">owner</a>.<a class="code" href="classNodeHandle.html#aef531103cdf07c8353267f4d30a80112" title="returns key of this NodeHandle">getKey</a>()) {
                entry = &amp;(<a class="code" href="classPastryRoutingTable.html#a8ecdfb9dca39fcf3bb0e5418fec9d78c" title="returns routing table entry at specified position">nodeAt</a>(shl, digit - 1));
                <span class="keywordflow">if</span> ((!entry-&gt;<a class="code" href="structPastryExtendedNode.html#a4b5835436cdf9648b60e69e2c1fb2777">node</a>.<a class="code" href="classNodeHandle.html#ab5136375a4548ced7c2014a73c8743c9" title="indicates if this NodeHandle is specified">isUnspecified</a>()) &amp;&amp;
                        <a class="code" href="classPastryStateObject.html#a13a6c5fdcbe191dc45619aeaa29f1993" title="test a given NodeHandle if it is closer to a given destination, but only if the shared prefix length ...">specialCloserCondition</a>(entry-&gt;<a class="code" href="structPastryExtendedNode.html#a4b5835436cdf9648b60e69e2c1fb2777">node</a>, destination, *ret))
                    ret = &amp;(entry-&gt;<a class="code" href="structPastryExtendedNode.html#a4b5835436cdf9648b60e69e2c1fb2777">node</a>);
            } <span class="keywordflow">else</span> {
                entry = &amp;(<a class="code" href="classPastryRoutingTable.html#a8ecdfb9dca39fcf3bb0e5418fec9d78c" title="returns routing table entry at specified position">nodeAt</a>(shl, digit + 1));
                <span class="keywordflow">if</span> ((!entry-&gt;<a class="code" href="structPastryExtendedNode.html#a4b5835436cdf9648b60e69e2c1fb2777">node</a>.<a class="code" href="classNodeHandle.html#ab5136375a4548ced7c2014a73c8743c9" title="indicates if this NodeHandle is specified">isUnspecified</a>()) &amp;&amp;
                        <a class="code" href="classPastryStateObject.html#a13a6c5fdcbe191dc45619aeaa29f1993" title="test a given NodeHandle if it is closer to a given destination, but only if the shared prefix length ...">specialCloserCondition</a>(entry-&gt;<a class="code" href="structPastryExtendedNode.html#a4b5835436cdf9648b60e69e2c1fb2777">node</a>, destination, *ret))
                    ret = &amp;(entry-&gt;<a class="code" href="structPastryExtendedNode.html#a4b5835436cdf9648b60e69e2c1fb2777">node</a>);
            }
        }

        <span class="keywordflow">return</span> *ret; <span class="comment">// still unspecified if no closer node was found</span>
    } <span class="keywordflow">else</span> {
        <span class="comment">// no optimization, return the first closer node found</span>
        <span class="keywordflow">for</span> (uint32_t y = 0; y &lt; <a class="code" href="classPastryRoutingTable.html#a9ad52acd8b712f0b841806b9e193fb4a">rows</a>.size(); ++y) {
            <span class="keywordflow">for</span> (uint32_t x = 0; x &lt; <a class="code" href="classPastryRoutingTable.html#a0b87befd6ebf85f6c6cdf3303d386b88">nodesPerRow</a>; ++x) {
                entry = &amp;(<a class="code" href="classPastryRoutingTable.html#a8ecdfb9dca39fcf3bb0e5418fec9d78c" title="returns routing table entry at specified position">nodeAt</a>(y, x));
                <span class="keywordflow">if</span> ((!entry-&gt;<a class="code" href="structPastryExtendedNode.html#a4b5835436cdf9648b60e69e2c1fb2777">node</a>.<a class="code" href="classNodeHandle.html#ab5136375a4548ced7c2014a73c8743c9" title="indicates if this NodeHandle is specified">isUnspecified</a>()) &amp;&amp;
                        <a class="code" href="classPastryStateObject.html#a13a6c5fdcbe191dc45619aeaa29f1993" title="test a given NodeHandle if it is closer to a given destination, but only if the shared prefix length ...">specialCloserCondition</a>(entry-&gt;<a class="code" href="structPastryExtendedNode.html#a4b5835436cdf9648b60e69e2c1fb2777">node</a>, destination))
                    <span class="keywordflow">return</span> entry-&gt;<a class="code" href="structPastryExtendedNode.html#a4b5835436cdf9648b60e69e2c1fb2777">node</a>;
            }
        }

        <span class="keywordflow">return</span> <a class="code" href="classNodeHandle.html#a79bf2c5e29c969cbd0b2581cb188d8a6" title="the unspecified NodeHandle">NodeHandle::UNSPECIFIED_NODE</a>;
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a0604bf72a6a6143d4cb8eb6a55e0b0f3"></a><!-- doxytag: member="PastryRoutingTable::findCloserNodes" ref="a0604bf72a6a6143d4cb8eb6a55e0b0f3" args="(const OverlayKey &amp;destination, NodeVector *nodes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PastryRoutingTable::findCloserNodes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOverlayKey.html">OverlayKey</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="NodeVector_8h.html#a442f90b66b22aa9fca51f83c5ce1b02b">NodeVector</a> *&#160;</td>
          <td class="paramname"><em>nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classPastryStateObject.html#a5255b15a989fb6f61403760383618375">PastryStateObject</a>.</p>

<p>Definition at line <a class="el" href="PastryRoutingTable_8cc_source.html#l00179">179</a> of file <a class="el" href="PastryRoutingTable_8cc_source.html">PastryRoutingTable.cc</a>.</p>

<p>Referenced by <a class="el" href="BasePastry_8cc_source.html#l00906">BasePastry::findNode()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//TODO</span>
    <span class="keyword">const</span> <a class="code" href="structPastryExtendedNode.html" title="struct for storing a NodeHandle together with its proximity value and an optional timestamp...">PastryExtendedNode</a>* entry;

    <span class="keywordflow">for</span> (uint32_t y = 0; y &lt; <a class="code" href="classPastryRoutingTable.html#a9ad52acd8b712f0b841806b9e193fb4a">rows</a>.size(); ++y) {
        <span class="keywordflow">for</span> (uint32_t x = 0; x &lt; <a class="code" href="classPastryRoutingTable.html#a0b87befd6ebf85f6c6cdf3303d386b88">nodesPerRow</a>; ++x) {
            entry = &amp;(<a class="code" href="classPastryRoutingTable.html#a8ecdfb9dca39fcf3bb0e5418fec9d78c" title="returns routing table entry at specified position">nodeAt</a>(y, x));
            <span class="keywordflow">if</span> (!entry-&gt;<a class="code" href="structPastryExtendedNode.html#a4b5835436cdf9648b60e69e2c1fb2777">node</a>.<a class="code" href="classNodeHandle.html#ab5136375a4548ced7c2014a73c8743c9" title="indicates if this NodeHandle is specified">isUnspecified</a>()
            <span class="comment">/* &amp;&amp; specialCloserCondition(entry-&gt;node, destination)*/</span>)
                nodes-&gt;<a class="code" href="classBaseKeySortedVector.html#afbcdfbd9680a475cceb48ccc841140cd" title="adds an element of type T in increasing order to the NodeVector and returns the position of the added...">add</a>(entry-&gt;<a class="code" href="structPastryExtendedNode.html#a4b5835436cdf9648b60e69e2c1fb2777">node</a>);
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a129c1c2b0591a8c6a6c1c7eae380131e"></a><!-- doxytag: member="PastryRoutingTable::findNextNodeToAsk" ref="a129c1c2b0591a8c6a6c1c7eae380131e" args="(PRTTrackRepair &amp;track) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PastryRoutingTable::findNextNodeToAsk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPRTTrackRepair.html">PRTTrackRepair</a> &amp;&#160;</td>
          <td class="paramname"><em>track</em></td><td>)</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>helper function, updates a <a class="el" href="structPRTTrackRepair.html" title="Struct for tracking attempts to repair a routing table entry.">PRTTrackRepair</a> structure to point to the next node that can be asked for repair </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">track</td><td>the <a class="el" href="structPRTTrackRepair.html" title="Struct for tracking attempts to repair a routing table entry.">PRTTrackRepair</a> structure </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="PastryRoutingTable_8cc_source.html#l00466">466</a> of file <a class="el" href="PastryRoutingTable_8cc_source.html">PastryRoutingTable.cc</a>.</p>

<p>Referenced by <a class="el" href="PastryRoutingTable_8cc_source.html#l00378">failedNode()</a>, and <a class="el" href="PastryRoutingTable_8cc_source.html#l00417">repair()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keyword">const</span> <a class="code" href="classTransportAddress.html" title="This class implements a common transport address.">TransportAddress</a>* ask;

    <span class="keywordflow">if</span> (track.<a class="code" href="structPRTTrackRepair.html#afe07e90cb15c3738b8b55474f3d9ffe7">node</a>.<a class="code" href="classTransportAddress.html#a026e777c423ff2a0280edd2fa5472e74" title="indicates if TransportAddress is specified">isUnspecified</a>()) {
        track.<a class="code" href="structPRTTrackRepair.html#ae506213872b99c5a76bd110ee92c8c6e">askedRow</a> = track.<a class="code" href="structPRTTrackRepair.html#aad132b6672452a53d916e7d938aca33e">failedRow</a>;
        <span class="keywordflow">if</span> (track.<a class="code" href="structPRTTrackRepair.html#af1311e8d338fb3aa0a43dfc065261205">failedCol</a> == 0)
            track.<a class="code" href="structPRTTrackRepair.html#a0651ed7119b31614efcc8d59d383c6ed">askedCol</a> = 1;
        <span class="keywordflow">else</span>
            track.<a class="code" href="structPRTTrackRepair.html#a0651ed7119b31614efcc8d59d383c6ed">askedCol</a> = 0;
        ask = <span class="keyword">static_cast&lt;</span><span class="keyword">const </span><a class="code" href="classTransportAddress.html" title="This class implements a common transport address.">TransportAddress</a>*<span class="keyword">&gt;</span>(
                &amp;(<a class="code" href="classPastryRoutingTable.html#a8ecdfb9dca39fcf3bb0e5418fec9d78c" title="returns routing table entry at specified position">nodeAt</a>(track.<a class="code" href="structPRTTrackRepair.html#ae506213872b99c5a76bd110ee92c8c6e">askedRow</a>, track.<a class="code" href="structPRTTrackRepair.html#a0651ed7119b31614efcc8d59d383c6ed">askedCol</a>).<a class="code" href="structPastryExtendedNode.html#a4b5835436cdf9648b60e69e2c1fb2777">node</a>));
        track.<a class="code" href="structPRTTrackRepair.html#afe07e90cb15c3738b8b55474f3d9ffe7">node</a> = *ask;
        <span class="keywordflow">if</span> ( (! track.<a class="code" href="structPRTTrackRepair.html#afe07e90cb15c3738b8b55474f3d9ffe7">node</a>.<a class="code" href="classTransportAddress.html#a026e777c423ff2a0280edd2fa5472e74" title="indicates if TransportAddress is specified">isUnspecified</a>()) &amp;&amp;
                (track.<a class="code" href="structPRTTrackRepair.html#afe07e90cb15c3738b8b55474f3d9ffe7">node</a> != <a class="code" href="classPastryStateObject.html#a946cabf3c3e981122e05bb37bf1c95dc" title="stores the NodeHandle of the owner of this PastryStateObject.">owner</a>) )
            <span class="keywordflow">return</span>;
    }

    <span class="keywordflow">do</span> {
        <span class="comment">// point to next possible position in routing table:</span>
        track.<a class="code" href="structPRTTrackRepair.html#a0651ed7119b31614efcc8d59d383c6ed">askedCol</a>++;
        <span class="keywordflow">if</span> ((track.<a class="code" href="structPRTTrackRepair.html#ae506213872b99c5a76bd110ee92c8c6e">askedRow</a> == track.<a class="code" href="structPRTTrackRepair.html#aad132b6672452a53d916e7d938aca33e">failedRow</a>) &amp;&amp;
                (track.<a class="code" href="structPRTTrackRepair.html#a0651ed7119b31614efcc8d59d383c6ed">askedCol</a> == track.<a class="code" href="structPRTTrackRepair.html#af1311e8d338fb3aa0a43dfc065261205">failedCol</a>)) track.<a class="code" href="structPRTTrackRepair.html#a0651ed7119b31614efcc8d59d383c6ed">askedCol</a>++;
        <span class="keywordflow">if</span> (track.<a class="code" href="structPRTTrackRepair.html#a0651ed7119b31614efcc8d59d383c6ed">askedCol</a> == <a class="code" href="classPastryRoutingTable.html#a0b87befd6ebf85f6c6cdf3303d386b88">nodesPerRow</a>) {
            <span class="keywordflow">if</span> ((track.<a class="code" href="structPRTTrackRepair.html#ae506213872b99c5a76bd110ee92c8c6e">askedRow</a> &gt; track.<a class="code" href="structPRTTrackRepair.html#a0651ed7119b31614efcc8d59d383c6ed">askedCol</a>) ||
                    (track.<a class="code" href="structPRTTrackRepair.html#ae506213872b99c5a76bd110ee92c8c6e">askedRow</a> == (<a class="code" href="classPastryRoutingTable.html#a9ad52acd8b712f0b841806b9e193fb4a">rows</a>.size() - 1))) {
                <span class="comment">// no more nodes that could be asked, give up:</span>
                track.<a class="code" href="structPRTTrackRepair.html#afe07e90cb15c3738b8b55474f3d9ffe7">node</a> = <a class="code" href="classTransportAddress.html#ac1709545db722cbbce1367034142d31f" title="TransportAddress without specified ip and port.">TransportAddress::UNSPECIFIED_NODE</a>;
                <span class="keywordflow">return</span>;
            }
            track.<a class="code" href="structPRTTrackRepair.html#ae506213872b99c5a76bd110ee92c8c6e">askedRow</a>++;
            track.<a class="code" href="structPRTTrackRepair.html#a0651ed7119b31614efcc8d59d383c6ed">askedCol</a> = 0;
        }

        ask = <span class="keyword">static_cast&lt;</span><span class="keyword">const </span><a class="code" href="classTransportAddress.html" title="This class implements a common transport address.">TransportAddress</a>*<span class="keyword">&gt;</span>(
                &amp;(<a class="code" href="classPastryRoutingTable.html#a8ecdfb9dca39fcf3bb0e5418fec9d78c" title="returns routing table entry at specified position">nodeAt</a>(track.<a class="code" href="structPRTTrackRepair.html#ae506213872b99c5a76bd110ee92c8c6e">askedRow</a>, track.<a class="code" href="structPRTTrackRepair.html#a0651ed7119b31614efcc8d59d383c6ed">askedCol</a>).<a class="code" href="structPastryExtendedNode.html#a4b5835436cdf9648b60e69e2c1fb2777">node</a>));

        <span class="keywordflow">if</span> (track.<a class="code" href="structPRTTrackRepair.html#afe07e90cb15c3738b8b55474f3d9ffe7">node</a>.<a class="code" href="classTransportAddress.html#a026e777c423ff2a0280edd2fa5472e74" title="indicates if TransportAddress is specified">isUnspecified</a>() ||
            (!ask-&gt;<a class="code" href="classTransportAddress.html#a026e777c423ff2a0280edd2fa5472e74" title="indicates if TransportAddress is specified">isUnspecified</a>() &amp;&amp; track.<a class="code" href="structPRTTrackRepair.html#afe07e90cb15c3738b8b55474f3d9ffe7">node</a> != *ask))
            track.<a class="code" href="structPRTTrackRepair.html#afe07e90cb15c3738b8b55474f3d9ffe7">node</a> = *ask; <span class="comment">//only happens if track.node == owner</span>
        <span class="keywordflow">else</span> track.<a class="code" href="structPRTTrackRepair.html#afe07e90cb15c3738b8b55474f3d9ffe7">node</a> = <a class="code" href="classTransportAddress.html#ac1709545db722cbbce1367034142d31f" title="TransportAddress without specified ip and port.">TransportAddress::UNSPECIFIED_NODE</a>;
    }
    <span class="keywordflow">while</span> (track.<a class="code" href="structPRTTrackRepair.html#afe07e90cb15c3738b8b55474f3d9ffe7">node</a>.<a class="code" href="classTransportAddress.html#a026e777c423ff2a0280edd2fa5472e74" title="indicates if TransportAddress is specified">isUnspecified</a>() || (track.<a class="code" href="structPRTTrackRepair.html#afe07e90cb15c3738b8b55474f3d9ffe7">node</a> == <a class="code" href="classPastryStateObject.html#a946cabf3c3e981122e05bb37bf1c95dc" title="stores the NodeHandle of the owner of this PastryStateObject.">owner</a>) );
}
</pre></div>
</div>
</div>
<a class="anchor" id="a449b7e0abcd2be8a93816669201bfc4c"></a><!-- doxytag: member="PastryRoutingTable::getLastRow" ref="a449b7e0abcd2be8a93816669201bfc4c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PastryRoutingTable::getLastRow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>gets the number of rows in the routing table </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of rows in the routing table </dd></dl>

<p>Definition at line <a class="el" href="PastryRoutingTable_8cc_source.html#l00264">264</a> of file <a class="el" href="PastryRoutingTable_8cc_source.html">PastryRoutingTable.cc</a>.</p>

<p>Referenced by <a class="el" href="Pastry_8cc_source.html#l00859">Pastry::doRoutingTableMaintenance()</a>, <a class="el" href="Bamboo_8cc_source.html#l00224">Bamboo::getNextRowToMaintain()</a>, <a class="el" href="BasePastry_8cc_source.html#l01056">BasePastry::getRTLastRow()</a>, and <a class="el" href="BasePastry_8cc_source.html#l00591">BasePastry::handleRequestRoutingRowCall()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">return</span> <a class="code" href="classPastryRoutingTable.html#a9ad52acd8b712f0b841806b9e193fb4a">rows</a>.size();
}
</pre></div>
</div>
</div>
<a class="anchor" id="a37d02a2bda67fe9618b382f321a532d3"></a><!-- doxytag: member="PastryRoutingTable::getRandomNode" ref="a37d02a2bda67fe9618b382f321a532d3" args="(int row)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTransportAddress.html">TransportAddress</a> &amp; PastryRoutingTable::getRandomNode </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns a random node from the routing table </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>the row to choose a random node from </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a random node or <a class="el" href="classTransportAddress.html#ac1709545db722cbbce1367034142d31f" title="TransportAddress without specified ip and port.">TransportAddress::UNSPECIFIED_NODE</a> </dd></dl>

<p>Definition at line <a class="el" href="PastryRoutingTable_8cc_source.html#l00270">270</a> of file <a class="el" href="PastryRoutingTable_8cc_source.html">PastryRoutingTable.cc</a>.</p>

<p>Referenced by <a class="el" href="Bamboo_8cc_source.html#l00250">Bamboo::doLocalTuning()</a>, and <a class="el" href="Pastry_8cc_source.html#l00859">Pastry::doRoutingTableMaintenance()</a>.</p>
<div class="fragment"><pre class="fragment">{
    std::vector&lt;PRTRow&gt;::const_iterator itRows;
    PRTRow::const_iterator itCols;
    uint32_t rnd;

    itRows = <a class="code" href="classPastryRoutingTable.html#a9ad52acd8b712f0b841806b9e193fb4a">rows</a>.begin() + row;
    <span class="keywordflow">if</span> (itRows &gt;= <a class="code" href="classPastryRoutingTable.html#a9ad52acd8b712f0b841806b9e193fb4a">rows</a>.end()) {
        EV &lt;&lt; <span class="stringliteral">&quot;[PastryRoutingTable::getRandomNode()]\n&quot;</span>
           &lt;&lt; <span class="stringliteral">&quot;    tried to get random Node from nonexistent row&quot;</span>
           &lt;&lt; endl;
    }
    rnd = intuniform(0, <a class="code" href="classPastryRoutingTable.html#a0b87befd6ebf85f6c6cdf3303d386b88">nodesPerRow</a> - 1, 0);
    itCols = itRows-&gt;begin() + rnd;
    <span class="keywordflow">while</span> (itCols != itRows-&gt;end()) {
        <span class="keywordflow">if</span> (!itCols-&gt;node.isUnspecified()) <span class="keywordflow">return</span> itCols-&gt;node;
        <span class="keywordflow">else</span> itCols++;
    }
    itCols = itRows-&gt;begin() + rnd;
    <span class="keywordflow">while</span> (itCols &gt;= itRows-&gt;begin()) {
        <span class="keywordflow">if</span> (!itCols-&gt;node.isUnspecified()) <span class="keywordflow">return</span> itCols-&gt;node;
        <span class="keywordflow">else</span> itCols--;
    }
    <span class="keywordflow">return</span> <a class="code" href="classTransportAddress.html#ac1709545db722cbbce1367034142d31f" title="TransportAddress without specified ip and port.">TransportAddress::UNSPECIFIED_NODE</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a092e213c15bf70d632dcae0f313bbe01"></a><!-- doxytag: member="PastryRoutingTable::getRow" ref="a092e213c15bf70d632dcae0f313bbe01" args="(uint8_t row) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classTransportAddress.html">TransportAddress</a> &gt; * PastryRoutingTable::getRow </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="PastryRoutingTable_8cc_source.html#l00247">247</a> of file <a class="el" href="PastryRoutingTable_8cc_source.html">PastryRoutingTable.cc</a>.</p>

<p>Referenced by <a class="el" href="BasePastry_8cc_source.html#l01062">BasePastry::getRTRow()</a>.</p>
<div class="fragment"><pre class="fragment">{
    std::vector&lt;TransportAddress&gt;* temp = <span class="keyword">new</span> std::vector&lt;TransportAddress&gt;;
    <span class="keywordflow">if</span> ((row &lt; 1) || (row &gt; (<span class="keywordtype">int</span>)<a class="code" href="classPastryRoutingTable.html#a9ad52acd8b712f0b841806b9e193fb4a">rows</a>.size())) <span class="keywordflow">return</span> temp;

    std::vector&lt;PRTRow&gt;::const_iterator itRows = <a class="code" href="classPastryRoutingTable.html#a9ad52acd8b712f0b841806b9e193fb4a">rows</a>.begin() + row - 1;

    <span class="keywordflow">for</span> (PRTRow::const_iterator itCols = itRows-&gt;begin();
         itCols != itRows-&gt;end(); ++itCols) {
        <span class="keywordflow">if</span> (itCols != itRows-&gt;end() &amp;&amp; !itCols-&gt;node.isUnspecified()) {
            temp-&gt;push_back(itCols-&gt;node);
        }
    }
    <span class="keywordflow">return</span> temp;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a3a4907994a66da808a72d17a77c93ee2"></a><!-- doxytag: member="PastryRoutingTable::initializeTable" ref="a3a4907994a66da808a72d17a77c93ee2" args="(uint32_t bitsPerDigit, double repairTimeout, const NodeHandle &amp;owner)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PastryRoutingTable::initializeTable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bitsPerDigit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>repairTimeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classNodeHandle.html">NodeHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>owner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initializes the routing table. </p>
<p>This should be called on startup</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bitsPerDigit</td><td><a class="el" href="classPastry.html" title="Pastry overlay module.">Pastry</a> configuration parameter </td></tr>
    <tr><td class="paramname">repairTimeout</td><td><a class="el" href="classPastry.html" title="Pastry overlay module.">Pastry</a> configuration parameter </td></tr>
    <tr><td class="paramname">owner</td><td>the node this table belongs to </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="PastryRoutingTable_8cc_source.html#l00043">43</a> of file <a class="el" href="PastryRoutingTable_8cc_source.html">PastryRoutingTable.cc</a>.</p>

<p>Referenced by <a class="el" href="BasePastry_8cc_source.html#l00187">BasePastry::baseChangeState()</a>.</p>
<div class="fragment"><pre class="fragment">{
    this-&gt;owner = <a class="code" href="classPastryStateObject.html#a946cabf3c3e981122e05bb37bf1c95dc" title="stores the NodeHandle of the owner of this PastryStateObject.">owner</a>;
    this-&gt;<a class="code" href="classPastryRoutingTable.html#aa22730d4147c929c205d86f4bda64c61">repairTimeout</a> = <a class="code" href="classPastryRoutingTable.html#aa22730d4147c929c205d86f4bda64c61">repairTimeout</a>;
    this-&gt;<a class="code" href="classPastryStateObject.html#a755bc90b0fb6bd61c42207d17855b743">bitsPerDigit</a> = <a class="code" href="classPastryStateObject.html#a755bc90b0fb6bd61c42207d17855b743">bitsPerDigit</a>;
    <a class="code" href="classPastryRoutingTable.html#a0b87befd6ebf85f6c6cdf3303d386b88">nodesPerRow</a> = 1 &lt;&lt; <a class="code" href="classPastryStateObject.html#a755bc90b0fb6bd61c42207d17855b743">bitsPerDigit</a>; <span class="comment">// 2 ^ bitsPerDigit</span>

    <span class="comment">// forget old routing table contents in case of restart:</span>
    <span class="keywordflow">if</span> (!<a class="code" href="classPastryRoutingTable.html#a9ad52acd8b712f0b841806b9e193fb4a">rows</a>.empty()) <a class="code" href="classPastryRoutingTable.html#a9ad52acd8b712f0b841806b9e193fb4a">rows</a>.clear();

    <span class="comment">// clear pending repair requests:</span>
    <span class="keywordflow">if</span> (!<a class="code" href="classPastryRoutingTable.html#adcd9c4e275d1036afd0fe371b53d4d00">awaitingRepair</a>.empty()) <a class="code" href="classPastryRoutingTable.html#adcd9c4e275d1036afd0fe371b53d4d00">awaitingRepair</a>.clear();

    <span class="comment">// Create first row in table:</span>
    <a class="code" href="classPastryRoutingTable.html#a4a364fc06948408b322cd12d7988bccc" title="adds a new line to the routing table">addRow</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa5222c6a0ecd848658dd51b8d93b7fc3"></a><!-- doxytag: member="PastryRoutingTable::initStateFromHandleVector" ref="aa5222c6a0ecd848658dd51b8d93b7fc3" args="(const std::vector&lt; PastryStateMsgHandle &gt; &amp;handles)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PastryRoutingTable::initStateFromHandleVector </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structPastryStateMsgHandle.html">PastryStateMsgHandle</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>handles</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>initialize table from vector of PastryStateMsgHandles with STATE messages received during JOIN phase. </p>
<p>The vector has to be sorted by JoinHopCount of the messages</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">handles</td><td>the vector of PastryStateMsgHandles </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true on success </dd></dl>

<p>Definition at line <a class="el" href="PastryRoutingTable_8cc_source.html#l00329">329</a> of file <a class="el" href="PastryRoutingTable_8cc_source.html">PastryRoutingTable.cc</a>.</p>

<p>Referenced by <a class="el" href="Pastry_8cc_source.html#l01101">Pastry::mergeState()</a>.</p>
<div class="fragment"><pre class="fragment">{
    std::vector&lt;PastryStateMsgHandle&gt;::const_iterator it;
    <span class="keywordtype">int</span> hopCheck = 0;

    <span class="keywordflow">for</span> (it = handles.begin(); it != handles.end(); ++it) {
        <span class="keywordflow">if</span> (it-&gt;msg-&gt;getRow() != ++hopCheck) <span class="keywordflow">return</span> <span class="keyword">false</span>;
        <a class="code" href="classPastryStateObject.html#a36f82233ec05837bf3761057f2437c86" title="update own state based on a received PastryStateMessage">mergeState</a>(it-&gt;msg, it-&gt;prox);
    }
    <span class="keywordflow">return</span> <span class="keyword">true</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a0a3497ae41535458b14e31be32d5f6fc"></a><!-- doxytag: member="PastryRoutingTable::lookupNextHop" ref="a0a3497ae41535458b14e31be32d5f6fc" args="(const OverlayKey &amp;destination)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNodeHandle.html">NodeHandle</a> &amp; PastryRoutingTable::lookupNextHop </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOverlayKey.html">OverlayKey</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>gets the next hop according to the <a class="el" href="classPastry.html" title="Pastry overlay module.">Pastry</a> routing scheme. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>the destination key </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the <a class="el" href="classNodeHandle.html" title="This class implements a node handle.">NodeHandle</a> of the next Node or <a class="el" href="classNodeHandle.html#a79bf2c5e29c969cbd0b2581cb188d8a6" title="the unspecified NodeHandle">NodeHandle::UNSPECIFIED_NODE</a> if no next hop could be determined </dd></dl>

<p>Definition at line <a class="el" href="PastryRoutingTable_8cc_source.html#l00073">73</a> of file <a class="el" href="PastryRoutingTable_8cc_source.html">PastryRoutingTable.cc</a>.</p>

<p>Referenced by <a class="el" href="BasePastry_8cc_source.html#l00906">BasePastry::findNode()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> (destination == <a class="code" href="classPastryStateObject.html#a946cabf3c3e981122e05bb37bf1c95dc" title="stores the NodeHandle of the owner of this PastryStateObject.">owner</a>.<a class="code" href="classNodeHandle.html#aef531103cdf07c8353267f4d30a80112" title="returns key of this NodeHandle">getKey</a>()) opp_error(<span class="stringliteral">&quot;trying to lookup own key!&quot;</span>);

    uint32_t shl = <a class="code" href="classPastryStateObject.html#a946cabf3c3e981122e05bb37bf1c95dc" title="stores the NodeHandle of the owner of this PastryStateObject.">owner</a>.<a class="code" href="classNodeHandle.html#aef531103cdf07c8353267f4d30a80112" title="returns key of this NodeHandle">getKey</a>().<a class="code" href="classOverlayKey.html#a0a44da45d3d52ce2ad76dad4e06a2888" title="Calculates the number of equal bits (digits) from the left with another Key (shared prefix length)...">sharedPrefixLength</a>(destination) / <a class="code" href="classPastryStateObject.html#a755bc90b0fb6bd61c42207d17855b743">bitsPerDigit</a>;
    uint32_t digit = <a class="code" href="classPastryRoutingTable.html#a4b84eeabf2d6da3509c9159b0c1c4beb" title="returns n&#39;th pastry digit from a key">digitAt</a>(shl, destination);

    <span class="keywordflow">if</span> (shl &gt;= <a class="code" href="classPastryRoutingTable.html#a9ad52acd8b712f0b841806b9e193fb4a">rows</a>.size()) {
        EV &lt;&lt; <span class="stringliteral">&quot;Pastry: Unable to find next hop for &quot;</span> &lt;&lt; destination
           &lt;&lt; <span class="stringliteral">&quot;, row is empty.&quot;</span> &lt;&lt; endl;
        <span class="keywordflow">return</span> <a class="code" href="classNodeHandle.html#a79bf2c5e29c969cbd0b2581cb188d8a6" title="the unspecified NodeHandle">NodeHandle::UNSPECIFIED_NODE</a>;
    }

    <span class="keyword">const</span> <a class="code" href="structPastryExtendedNode.html" title="struct for storing a NodeHandle together with its proximity value and an optional timestamp...">PastryExtendedNode</a>&amp; next = <a class="code" href="classPastryRoutingTable.html#a8ecdfb9dca39fcf3bb0e5418fec9d78c" title="returns routing table entry at specified position">nodeAt</a>(shl, digit);

    <span class="keywordflow">if</span> (next.<a class="code" href="structPastryExtendedNode.html#a4b5835436cdf9648b60e69e2c1fb2777">node</a>.<a class="code" href="classNodeHandle.html#ab5136375a4548ced7c2014a73c8743c9" title="indicates if this NodeHandle is specified">isUnspecified</a>()) {
        EV &lt;&lt; <span class="stringliteral">&quot;Pastry: Unable to find next hop for &quot;</span> &lt;&lt; destination
           &lt;&lt; <span class="stringliteral">&quot;, routing table entry is empty.&quot;</span> &lt;&lt; endl;
    }
    <span class="keywordflow">return</span> next.<a class="code" href="structPastryExtendedNode.html#a4b5835436cdf9648b60e69e2c1fb2777">node</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a92eb6e9176f873cb0a7106ce6e97a53e"></a><!-- doxytag: member="PastryRoutingTable::mergeNode" ref="a92eb6e9176f873cb0a7106ce6e97a53e" args="(const NodeHandle &amp;node, simtime_t prox)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PastryRoutingTable::mergeNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNodeHandle.html">NodeHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">simtime_t&#160;</td>
          <td class="paramname"><em>prox</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>merge a node in the IRoutingTable </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to merge </td></tr>
    <tr><td class="paramname">prox</td><td>proximity value of the node </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if node was merged </dd></dl>

<p>Implements <a class="el" href="classPastryStateObject.html#aa5029ce2c80ae1a744ea92efc02dc8a7">PastryStateObject</a>.</p>

<p>Definition at line <a class="el" href="PastryRoutingTable_8cc_source.html#l00297">297</a> of file <a class="el" href="PastryRoutingTable_8cc_source.html">PastryRoutingTable.cc</a>.</p>

<p>Referenced by <a class="el" href="Bamboo_8cc_source.html#l00455">Bamboo::lookupFinished()</a>, and <a class="el" href="BasePastry_8cc_source.html#l00273">BasePastry::proxCallback()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> (node.<a class="code" href="classNodeHandle.html#aef531103cdf07c8353267f4d30a80112" title="returns key of this NodeHandle">getKey</a>() == <a class="code" href="classPastryStateObject.html#a946cabf3c3e981122e05bb37bf1c95dc" title="stores the NodeHandle of the owner of this PastryStateObject.">owner</a>.<a class="code" href="classNodeHandle.html#aef531103cdf07c8353267f4d30a80112" title="returns key of this NodeHandle">getKey</a>())
        opp_error(<span class="stringliteral">&quot;trying to merge node with same key!&quot;</span>);

    uint32_t shl;
    uint32_t digit;
    PRTRow::iterator position;

    shl = <a class="code" href="classPastryStateObject.html#a946cabf3c3e981122e05bb37bf1c95dc" title="stores the NodeHandle of the owner of this PastryStateObject.">owner</a>.<a class="code" href="classNodeHandle.html#aef531103cdf07c8353267f4d30a80112" title="returns key of this NodeHandle">getKey</a>().<a class="code" href="classOverlayKey.html#a0a44da45d3d52ce2ad76dad4e06a2888" title="Calculates the number of equal bits (digits) from the left with another Key (shared prefix length)...">sharedPrefixLength</a>(node.<a class="code" href="classNodeHandle.html#aef531103cdf07c8353267f4d30a80112" title="returns key of this NodeHandle">getKey</a>()) / <a class="code" href="classPastryStateObject.html#a755bc90b0fb6bd61c42207d17855b743">bitsPerDigit</a>;
    digit = <a class="code" href="classPastryRoutingTable.html#a4b84eeabf2d6da3509c9159b0c1c4beb" title="returns n&#39;th pastry digit from a key">digitAt</a>(shl, node.<a class="code" href="classNodeHandle.html#aef531103cdf07c8353267f4d30a80112" title="returns key of this NodeHandle">getKey</a>());

    <span class="keywordflow">while</span> (<a class="code" href="classPastryRoutingTable.html#a9ad52acd8b712f0b841806b9e193fb4a">rows</a>.size() &lt;= shl) <a class="code" href="classPastryRoutingTable.html#a4a364fc06948408b322cd12d7988bccc" title="adds a new line to the routing table">addRow</a>();
    position = (<a class="code" href="classPastryRoutingTable.html#a9ad52acd8b712f0b841806b9e193fb4a">rows</a>.begin() + shl)-&gt;begin() + digit;
    <span class="keywordflow">if</span> (position-&gt;node.isUnspecified() || (prox &lt; position-&gt;rtt)) {
        EV &lt;&lt; <span class="stringliteral">&quot;[PastryRoutingTable::mergeNode()]\n&quot;</span>
           &lt;&lt; <span class="stringliteral">&quot;    Node &quot;</span> &lt;&lt; <a class="code" href="classPastryStateObject.html#a946cabf3c3e981122e05bb37bf1c95dc" title="stores the NodeHandle of the owner of this PastryStateObject.">owner</a>.<a class="code" href="classNodeHandle.html#aef531103cdf07c8353267f4d30a80112" title="returns key of this NodeHandle">getKey</a>()
           &lt;&lt; endl;
        EV &lt;&lt; <span class="stringliteral">&quot;        placing node &quot;</span> &lt;&lt; node.<a class="code" href="classNodeHandle.html#aef531103cdf07c8353267f4d30a80112" title="returns key of this NodeHandle">getKey</a>() &lt;&lt; <span class="stringliteral">&quot;in row &quot;</span>
           &lt;&lt; shl &lt;&lt; <span class="stringliteral">&quot;, col&quot;</span> &lt;&lt; digit &lt;&lt; endl;
        <span class="keywordflow">if</span> (! position-&gt;node.isUnspecified()) {
            EV &lt;&lt; <span class="stringliteral">&quot;        (replaced because of better proximity: &quot;</span>
            &lt;&lt; prox &lt;&lt; <span class="stringliteral">&quot; &lt; &quot;</span> &lt;&lt; position-&gt;rtt &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; endl;
        }
        position-&gt;node = node;
        position-&gt;rtt = prox;
        <span class="keywordflow">return</span> <span class="keyword">true</span>;
    }
    <span class="keywordflow">return</span> <span class="keyword">false</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a8ecdfb9dca39fcf3bb0e5418fec9d78c"></a><!-- doxytag: member="PastryRoutingTable::nodeAt" ref="a8ecdfb9dca39fcf3bb0e5418fec9d78c" args="(uint32_t row, uint32_t col) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structPastryExtendedNode.html">PastryExtendedNode</a> &amp; PastryRoutingTable::nodeAt </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns routing table entry at specified position </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>the number of the row </td></tr>
    <tr><td class="paramname">col</td><td>the number of the column </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="PastryRoutingTable_8cc_source.html#l00063">63</a> of file <a class="el" href="PastryRoutingTable_8cc_source.html">PastryRoutingTable.cc</a>.</p>

<p>Referenced by <a class="el" href="PastryRoutingTable_8cc_source.html#l00096">findCloserNode()</a>, <a class="el" href="PastryRoutingTable_8cc_source.html#l00179">findCloserNodes()</a>, <a class="el" href="PastryRoutingTable_8cc_source.html#l00466">findNextNodeToAsk()</a>, <a class="el" href="PastryRoutingTable_8cc_source.html#l00073">lookupNextHop()</a>, and <a class="el" href="PastryRoutingTable_8cc_source.html#l00417">repair()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> (<a class="code" href="classPastryRoutingTable.html#a9ad52acd8b712f0b841806b9e193fb4a">rows</a>.size() &lt;= row) <span class="keywordflow">return</span> <a class="code" href="classPastryStateObject.html#a957e9ac8870e9f03df83f85ff4d8cf7b">unspecNode</a>();
    <span class="keywordflow">if</span> (col &gt;= <a class="code" href="classPastryRoutingTable.html#a0b87befd6ebf85f6c6cdf3303d386b88">nodesPerRow</a>) <span class="keywordflow">return</span> <a class="code" href="classPastryStateObject.html#a957e9ac8870e9f03df83f85ff4d8cf7b">unspecNode</a>();

    <span class="keywordflow">return</span> *((<a class="code" href="classPastryRoutingTable.html#a9ad52acd8b712f0b841806b9e193fb4a">rows</a>.begin()+row)-&gt;begin()+col);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a632d81ee59ded7bc2249b64555b3bb78"></a><!-- doxytag: member="PastryRoutingTable::repair" ref="a632d81ee59ded7bc2249b64555b3bb78" args="(const PastryStateMessage *msg, const PastryStateMsgProximity *prox)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTransportAddress.html">TransportAddress</a> &amp; PastryRoutingTable::repair </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPastryStateMessage.html">PastryStateMessage</a> *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPastryStateMsgProximity.html">PastryStateMsgProximity</a> *&#160;</td>
          <td class="paramname"><em>prox</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>attempt to repair the routing using a received REPAIR message </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>the state message of type REPAIR </td></tr>
    <tr><td class="paramname">prox</td><td>record of proximity values matching the state message </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>another node to ask for REPAIR or <a class="el" href="classTransportAddress.html#ac1709545db722cbbce1367034142d31f" title="TransportAddress without specified ip and port.">TransportAddress::UNSPECIFIED_NODE</a> </dd></dl>

<p>Definition at line <a class="el" href="PastryRoutingTable_8cc_source.html#l00417">417</a> of file <a class="el" href="PastryRoutingTable_8cc_source.html">PastryRoutingTable.cc</a>.</p>

<p>Referenced by <a class="el" href="Pastry_8cc_source.html#l00939">Pastry::checkProxCache()</a>.</p>
<div class="fragment"><pre class="fragment">{
    std::vector&lt;PRTTrackRepair&gt;::iterator it;
    simtime_t now = simTime();

    <span class="comment">// first eliminate outdated entries in awaitingRepair:</span>
    <span class="keywordflow">for</span> (it = <a class="code" href="classPastryRoutingTable.html#adcd9c4e275d1036afd0fe371b53d4d00">awaitingRepair</a>.begin(); it != <a class="code" href="classPastryRoutingTable.html#adcd9c4e275d1036afd0fe371b53d4d00">awaitingRepair</a>.end();) {
        <span class="keywordflow">if</span> (it-&gt;timestamp &lt; (now - <a class="code" href="classPastryRoutingTable.html#aa22730d4147c929c205d86f4bda64c61">repairTimeout</a>))
            it = <a class="code" href="classPastryRoutingTable.html#adcd9c4e275d1036afd0fe371b53d4d00">awaitingRepair</a>.erase(it);
        <span class="keywordflow">else</span> it++;
    }

    <span class="comment">// don&#39;t expect any more repair messages:</span>
    <span class="keywordflow">if</span> (<a class="code" href="classPastryRoutingTable.html#adcd9c4e275d1036afd0fe371b53d4d00">awaitingRepair</a>.empty()) <span class="keywordflow">return</span> <a class="code" href="classTransportAddress.html#ac1709545db722cbbce1367034142d31f" title="TransportAddress without specified ip and port.">TransportAddress::UNSPECIFIED_NODE</a>;

    <span class="comment">// look for source node in our list:</span>
    <span class="keywordflow">for</span> (it = <a class="code" href="classPastryRoutingTable.html#adcd9c4e275d1036afd0fe371b53d4d00">awaitingRepair</a>.begin(); it != <a class="code" href="classPastryRoutingTable.html#adcd9c4e275d1036afd0fe371b53d4d00">awaitingRepair</a>.end(); it++)
        <span class="keywordflow">if</span> (it-&gt;node == msg-&gt;<a class="code" href="classPastryStateMessage.html#ab854faec5faca431685829ba8296ecfd">getSender</a>()) <span class="keywordflow">break</span>;

    <span class="comment">// if not found, return from function:</span>
    <span class="keywordflow">if</span> (it == <a class="code" href="classPastryRoutingTable.html#adcd9c4e275d1036afd0fe371b53d4d00">awaitingRepair</a>.end()) <span class="keywordflow">return</span> <a class="code" href="classTransportAddress.html#ac1709545db722cbbce1367034142d31f" title="TransportAddress without specified ip and port.">TransportAddress::UNSPECIFIED_NODE</a>;

    <span class="comment">// merge state:</span>
    <a class="code" href="classPastryStateObject.html#a36f82233ec05837bf3761057f2437c86" title="update own state based on a received PastryStateMessage">mergeState</a>(msg, prox);

    <span class="comment">// repair not yet done?</span>
    <span class="keywordflow">if</span> (<a class="code" href="classPastryRoutingTable.html#a8ecdfb9dca39fcf3bb0e5418fec9d78c" title="returns routing table entry at specified position">nodeAt</a>(it-&gt;failedRow, it-&gt;failedCol).<a class="code" href="structPastryExtendedNode.html#a4b5835436cdf9648b60e69e2c1fb2777">node</a>.<a class="code" href="classNodeHandle.html#ab5136375a4548ced7c2014a73c8743c9" title="indicates if this NodeHandle is specified">isUnspecified</a>()) {
        <span class="comment">// ask next node</span>
        <a class="code" href="classPastryRoutingTable.html#a129c1c2b0591a8c6a6c1c7eae380131e" title="helper function, updates a PRTTrackRepair structure to point to the next node that can be asked for r...">findNextNodeToAsk</a>(*it);
        <span class="keywordflow">if</span> (it-&gt;node.isUnspecified()) {
            <span class="comment">// no more nodes to ask, give up:</span>
            EV &lt;&lt; <span class="stringliteral">&quot;[PastryRoutingTable::repair()]\n&quot;</span>
               &lt;&lt; <span class="stringliteral">&quot;    RoutingTable giving up repair attempt.&quot;</span>
               &lt;&lt; endl;
            <a class="code" href="classPastryRoutingTable.html#adcd9c4e275d1036afd0fe371b53d4d00">awaitingRepair</a>.erase(it);
            <span class="keywordflow">return</span> <a class="code" href="classTransportAddress.html#ac1709545db722cbbce1367034142d31f" title="TransportAddress without specified ip and port.">TransportAddress::UNSPECIFIED_NODE</a>;
        }
        <span class="keywordflow">else</span> <span class="keywordflow">return</span> it-&gt;node;
    }

    <span class="comment">// repair done: clean up</span>
    EV &lt;&lt; <span class="stringliteral">&quot;[PastryRoutingTable::repair()]\n&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;    RoutingTable repair was successful.&quot;</span>
       &lt;&lt; endl;
    <span class="keywordflow">return</span> <a class="code" href="classTransportAddress.html#ac1709545db722cbbce1367034142d31f" title="TransportAddress without specified ip and port.">TransportAddress::UNSPECIFIED_NODE</a>;
}
</pre></div>
</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="adcd9c4e275d1036afd0fe371b53d4d00"></a><!-- doxytag: member="PastryRoutingTable::awaitingRepair" ref="adcd9c4e275d1036afd0fe371b53d4d00" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structPRTTrackRepair.html">PRTTrackRepair</a>&gt; <a class="el" href="classPastryRoutingTable.html#adcd9c4e275d1036afd0fe371b53d4d00">PastryRoutingTable::awaitingRepair</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="PastryRoutingTable_8h_source.html#l00188">188</a> of file <a class="el" href="PastryRoutingTable_8h_source.html">PastryRoutingTable.h</a>.</p>

<p>Referenced by <a class="el" href="PastryRoutingTable_8cc_source.html#l00378">failedNode()</a>, <a class="el" href="PastryRoutingTable_8cc_source.html#l00043">initializeTable()</a>, and <a class="el" href="PastryRoutingTable_8cc_source.html#l00417">repair()</a>.</p>

</div>
</div>
<a class="anchor" id="a0b87befd6ebf85f6c6cdf3303d386b88"></a><!-- doxytag: member="PastryRoutingTable::nodesPerRow" ref="a0b87befd6ebf85f6c6cdf3303d386b88" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="classPastryRoutingTable.html#a0b87befd6ebf85f6c6cdf3303d386b88">PastryRoutingTable::nodesPerRow</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="PastryRoutingTable_8h_source.html#l00182">182</a> of file <a class="el" href="PastryRoutingTable_8h_source.html">PastryRoutingTable.h</a>.</p>

<p>Referenced by <a class="el" href="PastryRoutingTable_8cc_source.html#l00354">addRow()</a>, <a class="el" href="PastryRoutingTable_8cc_source.html#l00217">dumpRowToMessage()</a>, <a class="el" href="PastryRoutingTable_8cc_source.html#l00196">dumpToStateMessage()</a>, <a class="el" href="PastryRoutingTable_8cc_source.html#l00096">findCloserNode()</a>, <a class="el" href="PastryRoutingTable_8cc_source.html#l00179">findCloserNodes()</a>, <a class="el" href="PastryRoutingTable_8cc_source.html#l00466">findNextNodeToAsk()</a>, <a class="el" href="PastryRoutingTable_8cc_source.html#l00270">getRandomNode()</a>, <a class="el" href="PastryRoutingTable_8cc_source.html#l00043">initializeTable()</a>, and <a class="el" href="PastryRoutingTable_8cc_source.html#l00063">nodeAt()</a>.</p>

</div>
</div>
<a class="anchor" id="aa22730d4147c929c205d86f4bda64c61"></a><!-- doxytag: member="PastryRoutingTable::repairTimeout" ref="aa22730d4147c929c205d86f4bda64c61" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classPastryRoutingTable.html#aa22730d4147c929c205d86f4bda64c61">PastryRoutingTable::repairTimeout</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="PastryRoutingTable_8h_source.html#l00186">186</a> of file <a class="el" href="PastryRoutingTable_8h_source.html">PastryRoutingTable.h</a>.</p>

<p>Referenced by <a class="el" href="PastryRoutingTable_8cc_source.html#l00043">initializeTable()</a>, and <a class="el" href="PastryRoutingTable_8cc_source.html#l00417">repair()</a>.</p>

</div>
</div>
<a class="anchor" id="a9ad52acd8b712f0b841806b9e193fb4a"></a><!-- doxytag: member="PastryRoutingTable::rows" ref="a9ad52acd8b712f0b841806b9e193fb4a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="PastryRoutingTable_8h.html#aef87e32a9d3f457c82682f7d416ff0dd">PRTRow</a>&gt; <a class="el" href="classPastryRoutingTable.html#a9ad52acd8b712f0b841806b9e193fb4a">PastryRoutingTable::rows</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="PastryRoutingTable_8h_source.html#l00187">187</a> of file <a class="el" href="PastryRoutingTable_8h_source.html">PastryRoutingTable.h</a>.</p>

<p>Referenced by <a class="el" href="PastryRoutingTable_8cc_source.html#l00354">addRow()</a>, <a class="el" href="PastryRoutingTable_8cc_source.html#l00217">dumpRowToMessage()</a>, <a class="el" href="PastryRoutingTable_8cc_source.html#l00196">dumpToStateMessage()</a>, <a class="el" href="PastryRoutingTable_8cc_source.html#l00342">dumpToVector()</a>, <a class="el" href="PastryRoutingTable_8cc_source.html#l00037">earlyInit()</a>, <a class="el" href="PastryRoutingTable_8cc_source.html#l00378">failedNode()</a>, <a class="el" href="PastryRoutingTable_8cc_source.html#l00096">findCloserNode()</a>, <a class="el" href="PastryRoutingTable_8cc_source.html#l00179">findCloserNodes()</a>, <a class="el" href="PastryRoutingTable_8cc_source.html#l00466">findNextNodeToAsk()</a>, <a class="el" href="PastryRoutingTable_8cc_source.html#l00264">getLastRow()</a>, <a class="el" href="PastryRoutingTable_8cc_source.html#l00270">getRandomNode()</a>, <a class="el" href="PastryRoutingTable_8cc_source.html#l00247">getRow()</a>, <a class="el" href="PastryRoutingTable_8cc_source.html#l00043">initializeTable()</a>, <a class="el" href="PastryRoutingTable_8cc_source.html#l00073">lookupNextHop()</a>, <a class="el" href="PastryRoutingTable_8cc_source.html#l00297">mergeNode()</a>, and <a class="el" href="PastryRoutingTable_8cc_source.html#l00063">nodeAt()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="PastryRoutingTable_8h_source.html">PastryRoutingTable.h</a></li>
<li><a class="el" href="PastryRoutingTable_8cc_source.html">PastryRoutingTable.cc</a></li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="classPastryRoutingTable.html">PastryRoutingTable</a>      </li>

    <li class="footer">Generated on Thu Mar 6 2014 14:06:57 for OverSim by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.5.1 </li>
   </ul>
 </div>


</body>
</html>
