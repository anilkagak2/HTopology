<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OverSim: XmlRpc::XmlRpcUtil Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">OverSim
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classXmlRpc_1_1XmlRpcUtil.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">XmlRpc::XmlRpcUtil Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="XmlRpc::XmlRpcUtil" -->
<p>Utilities for XML parsing, encoding, and decoding and message handlers.  
 <a href="classXmlRpc_1_1XmlRpcUtil.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="XmlRpcUtil_8h_source.html">XmlRpcUtil.h</a>&gt;</code></p>

<p><a href="classXmlRpc_1_1XmlRpcUtil-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXmlRpc_1_1XmlRpcUtil.html#a31294b7282f97068a68f46995a29bcc9">parseTag</a> (const char *tag, std::string const &amp;xml, int *offset)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns contents between &lt;tag&gt; and &lt;/tag&gt;, updates offset to char after &lt;/tag&gt;  <a href="#a31294b7282f97068a68f46995a29bcc9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXmlRpc_1_1XmlRpcUtil.html#aa0a246fe28c9a5d87abd6adcdf17712a">findTag</a> (const char *tag, std::string const &amp;xml, int *offset)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the tag is found and updates offset to the char after the tag.  <a href="#aa0a246fe28c9a5d87abd6adcdf17712a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXmlRpc_1_1XmlRpcUtil.html#aca44d3dcdd184a089bceb0dc92852617">getNextTag</a> (std::string const &amp;xml, int *offset)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next tag and updates offset to the char after the tag, or empty string if the next non-whitespace character is not '&lt;'.  <a href="#aca44d3dcdd184a089bceb0dc92852617"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXmlRpc_1_1XmlRpcUtil.html#a2ed1df7f98e410a4c8da054e803f3eb1">nextTagIs</a> (const char *tag, std::string const &amp;xml, int *offset)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the tag is found at the specified offset (modulo any whitespace) and updates offset to the char after the tag.  <a href="#a2ed1df7f98e410a4c8da054e803f3eb1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXmlRpc_1_1XmlRpcUtil.html#a99256e5c15fbc64826ed70b64aca7da8">xmlEncode</a> (const std::string &amp;raw)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert raw text to encoded xml.  <a href="#a99256e5c15fbc64826ed70b64aca7da8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXmlRpc_1_1XmlRpcUtil.html#ae1128729bf4f90d3c6929690bdca34d2">xmlDecode</a> (const std::string &amp;encoded)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert encoded xml to raw text.  <a href="#ae1128729bf4f90d3c6929690bdca34d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXmlRpc_1_1XmlRpcUtil.html#ac8423b781acbcbf90e5d4558591e7c61">log</a> (int level, const char *fmt,...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump messages somewhere.  <a href="#ac8423b781acbcbf90e5d4558591e7c61"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXmlRpc_1_1XmlRpcUtil.html#a3b8a23e81eb924fb0889cff32d3fe190">error</a> (const char *fmt,...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump error messages somewhere.  <a href="#a3b8a23e81eb924fb0889cff32d3fe190"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Utilities for XML parsing, encoding, and decoding and message handlers. </p>

<p>Definition at line <a class="el" href="XmlRpcUtil_8h_source.html#l00033">33</a> of file <a class="el" href="XmlRpcUtil_8h_source.html">XmlRpcUtil.h</a>.</p>
</div><hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a3b8a23e81eb924fb0889cff32d3fe190"></a><!-- doxytag: member="XmlRpc::XmlRpcUtil::error" ref="a3b8a23e81eb924fb0889cff32d3fe190" args="(const char *fmt,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XmlRpcUtil::error </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dump error messages somewhere. </p>

<p>Definition at line <a class="el" href="XmlRpcUtil_8cc_source.html#l00090">90</a> of file <a class="el" href="XmlRpcUtil_8cc_source.html">XmlRpcUtil.cc</a>.</p>

<p>Referenced by <a class="el" href="XmlRpcServerConnection_8cc_source.html#l00066">XmlRpc::XmlRpcServerConnection::readHeader()</a>, <a class="el" href="XmlRpcInterface_8cc_source.html#l00961">XmlRpcInterface::readHeader()</a>, <a class="el" href="XmlRpcInterface_8cc_source.html#l01046">XmlRpcInterface::readRequest()</a>, and <a class="el" href="XmlRpcInterface_8cc_source.html#l01079">XmlRpcInterface::writeResponse()</a>.</p>
<div class="fragment"><pre class="fragment">{
  va_list va;
  va_start(va, fmt);
  <span class="keywordtype">char</span> buf[1024];
  vsnprintf(buf,<span class="keyword">sizeof</span>(buf)-1,fmt,va);
  buf[<span class="keyword">sizeof</span>(buf)-1] = 0;
  <a class="code" href="classXmlRpc_1_1XmlRpcErrorHandler.html#a71565e49da56314567f8e39ec03f8065" title="Returns a pointer to the currently installed error handling object.">XmlRpcErrorHandler::getErrorHandler</a>()-&gt;<a class="code" href="classXmlRpc_1_1XmlRpcErrorHandler.html#a6a59a544da79813ec5300966bb2629de" title="Report an error. Custom error handlers should define this method.">error</a>(buf);
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa0a246fe28c9a5d87abd6adcdf17712a"></a><!-- doxytag: member="XmlRpc::XmlRpcUtil::findTag" ref="aa0a246fe28c9a5d87abd6adcdf17712a" args="(const char *tag, std::string const &amp;xml, int *offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XmlRpcUtil::findTag </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>xml</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if the tag is found and updates offset to the char after the tag. </p>

<p>Definition at line <a class="el" href="XmlRpcUtil_8cc_source.html#l00121">121</a> of file <a class="el" href="XmlRpcUtil_8cc_source.html">XmlRpcUtil.cc</a>.</p>

<p>Referenced by <a class="el" href="XmlRpcValue_8cc_source.html#l00219">XmlRpc::XmlRpcValue::fromXml()</a>, <a class="el" href="XmlRpcServer_8cc_source.html#l00354">XmlRpc::XmlRpcServer::parseRequest()</a>, and <a class="el" href="XmlRpcClient_8cc_source.html#l00528">XmlRpc::XmlRpcClient::parseResponse()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (*offset &gt;= <span class="keywordtype">int</span>(xml.length())) <span class="keywordflow">return</span> <span class="keyword">false</span>;
  <span class="keywordtype">size_t</span> istart = xml.find(tag, *offset);
  <span class="keywordflow">if</span> (istart == std::string::npos)
    <span class="keywordflow">return</span> <span class="keyword">false</span>;

  *offset = int(istart + strlen(tag));
  <span class="keywordflow">return</span> <span class="keyword">true</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aca44d3dcdd184a089bceb0dc92852617"></a><!-- doxytag: member="XmlRpc::XmlRpcUtil::getNextTag" ref="aca44d3dcdd184a089bceb0dc92852617" args="(std::string const &amp;xml, int *offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string XmlRpcUtil::getNextTag </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>xml</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the next tag and updates offset to the char after the tag, or empty string if the next non-whitespace character is not '&lt;'. </p>

<p>Definition at line <a class="el" href="XmlRpcUtil_8cc_source.html#l00158">158</a> of file <a class="el" href="XmlRpcUtil_8cc_source.html">XmlRpcUtil.cc</a>.</p>

<p>Referenced by <a class="el" href="XmlRpcValue_8cc_source.html#l00219">XmlRpc::XmlRpcValue::fromXml()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (*offset &gt;= <span class="keywordtype">int</span>(xml.length())) <span class="keywordflow">return</span> std::string();

  <span class="keyword">const</span> <span class="keywordtype">char</span>* cp = xml.c_str() + size_t(*offset);
  <span class="keyword">const</span> <span class="keywordtype">char</span>* startcp = cp;
  <span class="keywordflow">while</span> (*cp &amp;&amp; isspace(*cp))
    ++cp;


  <span class="keywordflow">if</span> (*cp != <span class="charliteral">&#39;&lt;&#39;</span>) <span class="keywordflow">return</span> std::string();

  <span class="comment">// Tag includes the non-blank characters after &lt;</span>
  <span class="keyword">const</span> <span class="keywordtype">char</span>* start = cp++;
  <span class="keywordflow">while</span> (*cp != <span class="charliteral">&#39;&gt;&#39;</span> &amp;&amp; *cp != 0 &amp;&amp; ! isspace(*cp))
    ++cp;

  std::string s(start, cp-start+1);

  <span class="keywordflow">if</span> (*cp != <span class="charliteral">&#39;&gt;&#39;</span>)   <span class="comment">// Skip parameters and values</span>
  {
    <span class="keywordflow">while</span> (*cp != <span class="charliteral">&#39;&gt;&#39;</span> &amp;&amp; *cp != 0)
      ++cp;

    s[s.length()-1] = *cp;
  }

  *offset += int(cp - startcp + 1);
  <span class="keywordflow">return</span> s;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac8423b781acbcbf90e5d4558591e7c61"></a><!-- doxytag: member="XmlRpc::XmlRpcUtil::log" ref="ac8423b781acbcbf90e5d4558591e7c61" args="(int level, const char *fmt,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XmlRpcUtil::log </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dump messages somewhere. </p>

<p>Definition at line <a class="el" href="XmlRpcUtil_8cc_source.html#l00076">76</a> of file <a class="el" href="XmlRpcUtil_8cc_source.html">XmlRpcUtil.cc</a>.</p>

<p>Referenced by <a class="el" href="XmlRpcServer_8cc_source.html#l00175">XmlRpc::XmlRpcServer::acceptConnection()</a>, <a class="el" href="XmlRpcServer_8cc_source.html#l00091">XmlRpc::XmlRpcServer::bindAndListen()</a>, <a class="el" href="XmlRpcSocket_8cc_source.html#l00086">XmlRpc::XmlRpcSocket::close()</a>, <a class="el" href="XmlRpcSource_8cc_source.html#l00025">XmlRpc::XmlRpcSource::close()</a>, <a class="el" href="XmlRpcClient_8cc_source.html#l00135">XmlRpc::XmlRpcClient::close()</a>, <a class="el" href="XmlRpcClient_8cc_source.html#l00267">XmlRpc::XmlRpcClient::doConnect()</a>, <a class="el" href="XmlRpcClient_8cc_source.html#l00171">XmlRpc::XmlRpcClient::execute()</a>, <a class="el" href="XmlRpcServer_8cc_source.html#l00327">XmlRpc::XmlRpcServer::executeRequest()</a>, <a class="el" href="XmlRpcClient_8cc_source.html#l00313">XmlRpc::XmlRpcClient::generateRequest()</a>, <a class="el" href="XmlRpcServer_8cc_source.html#l00445">XmlRpc::XmlRpcServer::generateResponse()</a>, <a class="el" href="XmlRpcSocket_8cc_source.html#l00177">XmlRpc::XmlRpcSocket::nbRead()</a>, <a class="el" href="XmlRpcSocket_8cc_source.html#l00217">XmlRpc::XmlRpcSocket::nbWrite()</a>, <a class="el" href="XmlRpcServerConnection_8cc_source.html#l00066">XmlRpc::XmlRpcServerConnection::readHeader()</a>, <a class="el" href="XmlRpcInterface_8cc_source.html#l00961">XmlRpcInterface::readHeader()</a>, <a class="el" href="XmlRpcClient_8cc_source.html#l00426">XmlRpc::XmlRpcClient::readHeader()</a>, <a class="el" href="XmlRpcServerConnection_8cc_source.html#l00145">XmlRpc::XmlRpcServerConnection::readRequest()</a>, <a class="el" href="XmlRpcInterface_8cc_source.html#l01046">XmlRpcInterface::readRequest()</a>, <a class="el" href="XmlRpcClient_8cc_source.html#l00497">XmlRpc::XmlRpcClient::readResponse()</a>, <a class="el" href="XmlRpcServer_8cc_source.html#l00154">XmlRpc::XmlRpcServer::work()</a>, <a class="el" href="XmlRpcClient_8cc_source.html#l00401">XmlRpc::XmlRpcClient::writeRequest()</a>, <a class="el" href="XmlRpcServerConnection_8cc_source.html#l00177">XmlRpc::XmlRpcServerConnection::writeResponse()</a>, <a class="el" href="XmlRpcInterface_8cc_source.html#l01079">XmlRpcInterface::writeResponse()</a>, <a class="el" href="XmlRpcClient_8cc_source.html#l00037">XmlRpc::XmlRpcClient::XmlRpcClient()</a>, <a class="el" href="XmlRpcServerConnection_8cc_source.html#l00026">XmlRpc::XmlRpcServerConnection::XmlRpcServerConnection()</a>, <a class="el" href="XmlRpcClient_8cc_source.html#l00126">XmlRpc::XmlRpcClient::~XmlRpcClient()</a>, and <a class="el" href="XmlRpcServerConnection_8cc_source.html#l00038">XmlRpc::XmlRpcServerConnection::~XmlRpcServerConnection()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (level &lt;= <a class="code" href="classXmlRpc_1_1XmlRpcLogHandler.html#a94c23c8da2ecca3d296fbaf37b671e56" title="Returns the level of verbosity of informational messages. 0 is no output, 5 is very verbose...">XmlRpcLogHandler::getVerbosity</a>())
  {
    va_list va;
    <span class="keywordtype">char</span> buf[1024];
    va_start( va, fmt);
    vsnprintf(buf,<span class="keyword">sizeof</span>(buf)-1,fmt,va);
    buf[<span class="keyword">sizeof</span>(buf)-1] = 0;
    <a class="code" href="classXmlRpc_1_1XmlRpcLogHandler.html#ab103d4c7573efdb3dc8729a8a72d640b" title="Returns a pointer to the currently installed message reporting object.">XmlRpcLogHandler::getLogHandler</a>()-&gt;<a class="code" href="classXmlRpc_1_1XmlRpcLogHandler.html#a7e2466aacc3173acdbbb7c81ae8eb658" title="Output a message. Custom error handlers should define this method.">log</a>(level, buf);
  }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a2ed1df7f98e410a4c8da054e803f3eb1"></a><!-- doxytag: member="XmlRpc::XmlRpcUtil::nextTagIs" ref="a2ed1df7f98e410a4c8da054e803f3eb1" args="(const char *tag, std::string const &amp;xml, int *offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XmlRpcUtil::nextTagIs </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>xml</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if the tag is found at the specified offset (modulo any whitespace) and updates offset to the char after the tag. </p>

<p>Definition at line <a class="el" href="XmlRpcUtil_8cc_source.html#l00136">136</a> of file <a class="el" href="XmlRpcUtil_8cc_source.html">XmlRpcUtil.cc</a>.</p>

<p>Referenced by <a class="el" href="XmlRpcValue_8cc_source.html#l00465">XmlRpc::XmlRpcValue::arrayFromXml()</a>, <a class="el" href="XmlRpcValue_8cc_source.html#l00219">XmlRpc::XmlRpcValue::fromXml()</a>, <a class="el" href="XmlRpcServer_8cc_source.html#l00354">XmlRpc::XmlRpcServer::parseRequest()</a>, <a class="el" href="XmlRpcClient_8cc_source.html#l00528">XmlRpc::XmlRpcClient::parseResponse()</a>, and <a class="el" href="XmlRpcValue_8cc_source.html#l00502">XmlRpc::XmlRpcValue::structFromXml()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (*offset &gt;= <span class="keywordtype">int</span>(xml.length())) <span class="keywordflow">return</span> <span class="keyword">false</span>;
  <span class="keyword">const</span> <span class="keywordtype">char</span>* cp = xml.c_str() + *offset;
  <span class="keywordtype">int</span> nc = 0;
  <span class="keywordflow">while</span> (*cp &amp;&amp; isspace(*cp)) {
    ++cp;
    ++nc;
  }

  <span class="keywordtype">int</span> len = int(strlen(tag));
  <span class="keywordflow">if</span>  (*cp &amp;&amp; (strncmp(cp, tag, len) == 0)) {
    *offset += nc + len;
    <span class="keywordflow">return</span> <span class="keyword">true</span>;
  }
  <span class="keywordflow">return</span> <span class="keyword">false</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a31294b7282f97068a68f46995a29bcc9"></a><!-- doxytag: member="XmlRpc::XmlRpcUtil::parseTag" ref="a31294b7282f97068a68f46995a29bcc9" args="(const char *tag, std::string const &amp;xml, int *offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string XmlRpcUtil::parseTag </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>xml</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns contents between &lt;tag&gt; and &lt;/tag&gt;, updates offset to char after &lt;/tag&gt; </p>

<p>Definition at line <a class="el" href="XmlRpcUtil_8cc_source.html#l00103">103</a> of file <a class="el" href="XmlRpcUtil_8cc_source.html">XmlRpcUtil.cc</a>.</p>

<p>Referenced by <a class="el" href="XmlRpcServer_8cc_source.html#l00354">XmlRpc::XmlRpcServer::parseRequest()</a>, and <a class="el" href="XmlRpcValue_8cc_source.html#l00502">XmlRpc::XmlRpcValue::structFromXml()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (*offset &gt;= <span class="keywordtype">int</span>(xml.length())) <span class="keywordflow">return</span> std::string();
  <span class="keywordtype">size_t</span> istart = xml.find(tag, *offset);
  <span class="keywordflow">if</span> (istart == std::string::npos) <span class="keywordflow">return</span> std::string();
  istart += strlen(tag);
  std::string etag = <span class="stringliteral">&quot;&lt;/&quot;</span>;
  etag += tag + 1;
  <span class="keywordtype">size_t</span> iend = xml.find(etag, istart);
  <span class="keywordflow">if</span> (iend == std::string::npos) <span class="keywordflow">return</span> std::string();

  *offset = int(iend + etag.length());
  <span class="keywordflow">return</span> xml.substr(istart, iend-istart);
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae1128729bf4f90d3c6929690bdca34d2"></a><!-- doxytag: member="XmlRpc::XmlRpcUtil::xmlDecode" ref="ae1128729bf4f90d3c6929690bdca34d2" args="(const std::string &amp;encoded)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string XmlRpcUtil::xmlDecode </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>encoded</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert encoded xml to raw text. </p>

<p>Definition at line <a class="el" href="XmlRpcUtil_8cc_source.html#l00201">201</a> of file <a class="el" href="XmlRpcUtil_8cc_source.html">XmlRpcUtil.cc</a>.</p>

<p>Referenced by <a class="el" href="XmlRpcValue_8cc_source.html#l00362">XmlRpc::XmlRpcValue::stringFromXml()</a>.</p>
<div class="fragment"><pre class="fragment">{
  std::string::size_type iAmp = encoded.find(<a class="code" href="XmlRpcUtil_8cc.html#ae03be254a8892027361c7f5830bd138c">AMP</a>);
  <span class="keywordflow">if</span> (iAmp == std::string::npos)
    <span class="keywordflow">return</span> encoded;

  std::string decoded(encoded, 0, iAmp);
  std::string::size_type iSize = encoded.size();
  decoded.reserve(iSize);

  <span class="keyword">const</span> <span class="keywordtype">char</span>* ens = encoded.c_str();
  <span class="keywordflow">while</span> (iAmp != iSize) {
    <span class="keywordflow">if</span> (encoded[iAmp] == <a class="code" href="XmlRpcUtil_8cc.html#ae03be254a8892027361c7f5830bd138c">AMP</a> &amp;&amp; iAmp+1 &lt; iSize) {
      <span class="keywordtype">int</span> iEntity;
      <span class="keywordflow">for</span> (iEntity=0; <a class="code" href="XmlRpcUtil_8cc.html#ab02a0e5ab7789531bff6c27d729b7976">xmlEntity</a>[iEntity] != 0; ++iEntity)
        <span class="comment">//if (encoded.compare(iAmp+1, xmlEntLen[iEntity], xmlEntity[iEntity]) == 0)</span>
        <span class="keywordflow">if</span> (strncmp(ens+iAmp+1, <a class="code" href="XmlRpcUtil_8cc.html#ab02a0e5ab7789531bff6c27d729b7976">xmlEntity</a>[iEntity], <a class="code" href="XmlRpcUtil_8cc.html#a86251f3c24454954769d55460005edcb">xmlEntLen</a>[iEntity]) == 0)
        {
          decoded += <a class="code" href="XmlRpcUtil_8cc.html#add8dd07abb5251c20cd768094902036c">rawEntity</a>[iEntity];
          iAmp += <a class="code" href="XmlRpcUtil_8cc.html#a86251f3c24454954769d55460005edcb">xmlEntLen</a>[iEntity]+1;
          <span class="keywordflow">break</span>;
        }
      <span class="keywordflow">if</span> (<a class="code" href="XmlRpcUtil_8cc.html#ab02a0e5ab7789531bff6c27d729b7976">xmlEntity</a>[iEntity] == 0)    <span class="comment">// unrecognized sequence</span>
        decoded += encoded[iAmp++];

    } <span class="keywordflow">else</span> {
      decoded += encoded[iAmp++];
    }
  }
    
  <span class="keywordflow">return</span> decoded;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a99256e5c15fbc64826ed70b64aca7da8"></a><!-- doxytag: member="XmlRpc::XmlRpcUtil::xmlEncode" ref="a99256e5c15fbc64826ed70b64aca7da8" args="(const std::string &amp;raw)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string XmlRpcUtil::xmlEncode </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>raw</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert raw text to encoded xml. </p>

<p>Definition at line <a class="el" href="XmlRpcUtil_8cc_source.html#l00238">238</a> of file <a class="el" href="XmlRpcUtil_8cc_source.html">XmlRpcUtil.cc</a>.</p>

<p>Referenced by <a class="el" href="XmlRpcValue_8cc_source.html#l00374">XmlRpc::XmlRpcValue::stringToXml()</a>, and <a class="el" href="XmlRpcValue_8cc_source.html#l00527">XmlRpc::XmlRpcValue::structToXml()</a>.</p>
<div class="fragment"><pre class="fragment">{
  std::string::size_type iRep = raw.find_first_of(<a class="code" href="XmlRpcUtil_8cc.html#add8dd07abb5251c20cd768094902036c">rawEntity</a>);
  <span class="keywordflow">if</span> (iRep == std::string::npos)
    <span class="keywordflow">return</span> raw;

  std::string encoded(raw, 0, iRep);
  std::string::size_type iSize = raw.size();

  <span class="keywordflow">while</span> (iRep != iSize) {
    <span class="keywordtype">int</span> iEntity;
    <span class="keywordflow">for</span> (iEntity=0; <a class="code" href="XmlRpcUtil_8cc.html#add8dd07abb5251c20cd768094902036c">rawEntity</a>[iEntity] != 0; ++iEntity)
      <span class="keywordflow">if</span> (raw[iRep] == <a class="code" href="XmlRpcUtil_8cc.html#add8dd07abb5251c20cd768094902036c">rawEntity</a>[iEntity])
      {
        encoded += <a class="code" href="XmlRpcUtil_8cc.html#ae03be254a8892027361c7f5830bd138c">AMP</a>;
        encoded += <a class="code" href="XmlRpcUtil_8cc.html#ab02a0e5ab7789531bff6c27d729b7976">xmlEntity</a>[iEntity];
        <span class="keywordflow">break</span>;
      }
    <span class="keywordflow">if</span> (<a class="code" href="XmlRpcUtil_8cc.html#add8dd07abb5251c20cd768094902036c">rawEntity</a>[iEntity] == 0)
      encoded += raw[iRep];
    ++iRep;
  }
  <span class="keywordflow">return</span> encoded;
}
</pre></div>
</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="XmlRpcUtil_8h_source.html">XmlRpcUtil.h</a></li>
<li><a class="el" href="XmlRpcUtil_8cc_source.html">XmlRpcUtil.cc</a></li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceXmlRpc.html">XmlRpc</a>      </li>
      <li class="navelem"><a class="el" href="classXmlRpc_1_1XmlRpcUtil.html">XmlRpcUtil</a>      </li>

    <li class="footer">Generated on Thu Mar 6 2014 14:07:06 for OverSim by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.5.1 </li>
   </ul>
 </div>


</body>
</html>
