<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OverSim: InetUnderlayConfigurator.cc Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">OverSim
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('InetUnderlayConfigurator_8cc.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">InetUnderlayConfigurator.cc</div>  </div>
</div>
<div class="contents">
<a href="InetUnderlayConfigurator_8cc.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">//</span>
<a name="l00002"></a>00002 <span class="comment">// This program is free software; you can redistribute it and/or</span>
<a name="l00003"></a>00003 <span class="comment">// modify it under the terms of the GNU General Public License</span>
<a name="l00004"></a>00004 <span class="comment">// as published by the Free Software Foundation; either version 2</span>
<a name="l00005"></a>00005 <span class="comment">// of the License, or (at your option) any later version.</span>
<a name="l00006"></a>00006 <span class="comment">//</span>
<a name="l00007"></a>00007 <span class="comment">// This program is distributed in the hope that it will be useful,</span>
<a name="l00008"></a>00008 <span class="comment">// but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00009"></a>00009 <span class="comment">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00010"></a>00010 <span class="comment">// GNU General Public License for more details.</span>
<a name="l00011"></a>00011 <span class="comment">//</span>
<a name="l00012"></a>00012 <span class="comment">// You should have received a copy of the GNU General Public License</span>
<a name="l00013"></a>00013 <span class="comment">// along with this program; if not, write to the Free Software</span>
<a name="l00014"></a>00014 <span class="comment">// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.</span>
<a name="l00015"></a>00015 <span class="comment">//</span>
<a name="l00016"></a>00016 
<a name="l00022"></a>00022 <span class="preprocessor">#include &quot;<a class="code" href="InetUnderlayConfigurator_8h.html">InetUnderlayConfigurator.h</a>&quot;</span>
<a name="l00023"></a>00023 
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;<a class="code" href="GlobalNodeList_8h.html">GlobalNodeList.h</a>&gt;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;<a class="code" href="TransportAddress_8h.html">TransportAddress.h</a>&gt;</span>
<a name="l00026"></a>00026 
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;<a class="code" href="StringConvert_8h.html">StringConvert.h</a>&gt;</span>
<a name="l00028"></a>00028 
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;<a class="code" href="AccessNet_8h.html">AccessNet.h</a>&gt;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;IRoutingTable.h&gt;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &lt;RoutingTable6.h&gt;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &lt;IInterfaceTable.h&gt;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &lt;IPAddressResolver.h&gt;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &lt;IPv4InterfaceData.h&gt;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &lt;IPv6InterfaceData.h&gt;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &lt;NotificationBoard.h&gt;</span>
<a name="l00037"></a>00037 
<a name="l00038"></a>00038 
<a name="l00039"></a>00039 <span class="preprocessor">#include &lt;<a class="code" href="InetInfo_8h.html">InetInfo.h</a>&gt;</span>
<a name="l00040"></a>00040 
<a name="l00041"></a>00041 <a class="code" href="ALMTest_8cc.html#a3b5014f410c7989e8bad4b467ecc94cd">Define_Module</a>(<a class="code" href="classInetUnderlayConfigurator.html" title="Configurator module for the InetUnderlay.">InetUnderlayConfigurator</a>);
<a name="l00042"></a>00042 
<a name="l00043"></a><a class="code" href="classInetUnderlayConfigurator.html#ab2766113859f05dc03723dbc2a9736a6">00043</a> <span class="keywordtype">void</span> <a class="code" href="classInetUnderlayConfigurator.html#ab2766113859f05dc03723dbc2a9736a6" title="Sets up backbone, assigns ip addresses, calculates routing tables, sets some parameters and adds the ...">InetUnderlayConfigurator::initializeUnderlay</a>(<span class="keywordtype">int</span> stage)
<a name="l00044"></a>00044 {
<a name="l00045"></a>00045     <span class="comment">//backbone configuration</span>
<a name="l00046"></a>00046     <span class="keywordflow">if</span> (stage == <a class="code" href="InitStages_8h.html#a42fde1aa1e14a1c45d29061d6e87e532ac691a73094515eb9c580b1cac99f416c" title="first stage for underlay configurators">MIN_STAGE_UNDERLAY</a>) {
<a name="l00047"></a>00047         <span class="comment">// Find all router modules.</span>
<a name="l00048"></a>00048         cTopology topo(<span class="stringliteral">&quot;topo&quot;</span>);
<a name="l00049"></a>00049         topo.extractByProperty(<span class="stringliteral">&quot;node&quot;</span>);
<a name="l00050"></a>00050 
<a name="l00051"></a>00051         <span class="keywordflow">if</span> (par(<span class="stringliteral">&quot;useIPv6Addresses&quot;</span>).boolValue()) {
<a name="l00052"></a>00052             <a class="code" href="classInetUnderlayConfigurator.html#ac37e6f6adee00d6dfbce628b3fc735f9">setUpIPv6</a>(topo);
<a name="l00053"></a>00053             <span class="comment">//opp_error(&quot;IPv6 is not supported in this release but is coming soon.&quot;);</span>
<a name="l00054"></a>00054         } <span class="keywordflow">else</span> {
<a name="l00055"></a>00055             <a class="code" href="classInetUnderlayConfigurator.html#a8a7d9b35842e31ffa7a590110d11205a">setUpIPv4</a>(topo);
<a name="l00056"></a>00056         }
<a name="l00057"></a>00057     }
<a name="l00058"></a>00058     <span class="comment">//access net configuration</span>
<a name="l00059"></a>00059     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(stage == <a class="code" href="InitStages_8h.html#a42fde1aa1e14a1c45d29061d6e87e532a51360a7e54ff555dc3d078d686500cb9" title="last stage for underlay configurators">MAX_STAGE_UNDERLAY</a>) {
<a name="l00060"></a>00060         <span class="comment">// fetch some parameters</span>
<a name="l00061"></a>00061         <a class="code" href="classInetUnderlayConfigurator.html#af94467080ac95c8b5197568da39cb1fe" title="number of access router">accessRouterNum</a> = getParentModule()-&gt;par(<span class="stringliteral">&quot;accessRouterNum&quot;</span>);
<a name="l00062"></a>00062         <a class="code" href="classInetUnderlayConfigurator.html#a9ba1baa1cd1979f23eda0585eadd39e5" title="number of overlayAccessRouter">overlayAccessRouterNum</a> = getParentModule()-&gt;par(<span class="stringliteral">&quot;overlayAccessRouterNum&quot;</span>);
<a name="l00063"></a>00063 
<a name="l00064"></a>00064         <span class="comment">// count the overlay clients</span>
<a name="l00065"></a>00065         <a class="code" href="classUnderlayConfigurator.html#aed1fe1d613fb061b714fc281cbb0b820" title="current number of overlay terminals">overlayTerminalCount</a> = 0;
<a name="l00066"></a>00066 
<a name="l00067"></a>00067         <a class="code" href="classInetUnderlayConfigurator.html#a3ce6afb58a3a639cd8fc7977233b02b6" title="number of overall created overlay terminals">numCreated</a> = 0;
<a name="l00068"></a>00068         <a class="code" href="classInetUnderlayConfigurator.html#aa7434e33dfa90cc8b0b14575a12a33fc" title="number of overall killed overlay terminals">numKilled</a> = 0;
<a name="l00069"></a>00069 
<a name="l00070"></a>00070         <span class="comment">// add access node modules to access node vector</span>
<a name="l00071"></a>00071         cModule* node;
<a name="l00072"></a>00072         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classInetUnderlayConfigurator.html#af94467080ac95c8b5197568da39cb1fe" title="number of access router">accessRouterNum</a>; i++) {
<a name="l00073"></a>00073             node = getParentModule()-&gt;getSubmodule(<span class="stringliteral">&quot;accessRouter&quot;</span>, i);
<a name="l00074"></a>00074             <a class="code" href="classInetUnderlayConfigurator.html#a8271d89920574711ddd9c8cd4a65fab9" title="stores accessRouter">accessNode</a>.push_back( node );
<a name="l00075"></a>00075         }
<a name="l00076"></a>00076 
<a name="l00077"></a>00077         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classInetUnderlayConfigurator.html#a9ba1baa1cd1979f23eda0585eadd39e5" title="number of overlayAccessRouter">overlayAccessRouterNum</a>; i++) {
<a name="l00078"></a>00078             node = getParentModule()-&gt;getSubmodule(<span class="stringliteral">&quot;overlayAccessRouter&quot;</span>, i);
<a name="l00079"></a>00079             <a class="code" href="classInetUnderlayConfigurator.html#a8271d89920574711ddd9c8cd4a65fab9" title="stores accessRouter">accessNode</a>.push_back( node );
<a name="l00080"></a>00080         }
<a name="l00081"></a>00081 
<a name="l00082"></a>00082         <span class="comment">// debug stuff</span>
<a name="l00083"></a>00083         WATCH_PTRVECTOR(<a class="code" href="classInetUnderlayConfigurator.html#a8271d89920574711ddd9c8cd4a65fab9" title="stores accessRouter">accessNode</a>);
<a name="l00084"></a>00084     }
<a name="l00085"></a>00085 }
<a name="l00086"></a>00086 
<a name="l00087"></a><a class="code" href="classInetUnderlayConfigurator.html#ae8568a771c843767277558c4350774ec">00087</a> <a class="code" href="classTransportAddress.html" title="This class implements a common transport address.">TransportAddress</a>* <a class="code" href="classInetUnderlayConfigurator.html#ae8568a771c843767277558c4350774ec" title="Creates an overlay node.">InetUnderlayConfigurator::createNode</a>(<a class="code" href="classNodeType.html" title="Enum specifying node properties.">NodeType</a> type, <span class="keywordtype">bool</span> initialize)
<a name="l00088"></a>00088 {
<a name="l00089"></a>00089     Enter_Method_Silent();
<a name="l00090"></a>00090     <span class="comment">// derive overlay node from ned</span>
<a name="l00091"></a>00091     std::string nameStr = <span class="stringliteral">&quot;overlayTerminal&quot;</span>;
<a name="l00092"></a>00092     <span class="keywordflow">if</span>( <a class="code" href="classUnderlayConfigurator.html#a45b9ecd5f8deb026db63afc69c60d5a5" title="pointer to the ChurnGenerators">churnGenerator</a>.size() &gt; 1 ){
<a name="l00093"></a>00093         nameStr += <span class="stringliteral">&quot;-&quot;</span> + convertToString&lt;uint32_t&gt;(type.<a class="code" href="classNodeType.html#ad6f207541b281c15db64c6d87ee43143">typeID</a>);
<a name="l00094"></a>00094     }
<a name="l00095"></a>00095     cModuleType* moduleType = cModuleType::get(type.<a class="code" href="classNodeType.html#a60aa8ee80380320728c200d5ea9edcea">terminalType</a>.c_str());
<a name="l00096"></a>00096     cModule* node = moduleType-&gt;create(nameStr.c_str(), getParentModule(),
<a name="l00097"></a>00097                                        <a class="code" href="classInetUnderlayConfigurator.html#a3ce6afb58a3a639cd8fc7977233b02b6" title="number of overall created overlay terminals">numCreated</a> + 1, <a class="code" href="classInetUnderlayConfigurator.html#a3ce6afb58a3a639cd8fc7977233b02b6" title="number of overall created overlay terminals">numCreated</a>);
<a name="l00098"></a>00098 
<a name="l00099"></a>00099     <span class="keywordflow">if</span> (type.<a class="code" href="classNodeType.html#a4c4e8497d48ac644ed1dd3cb024a74f5">channelTypesTx</a>.size() &gt; 0) {
<a name="l00100"></a>00100         <span class="keywordflow">throw</span> cRuntimeError(<span class="stringliteral">&quot;InetUnderlayConfigurator::createNode(): Setting &quot;</span>
<a name="l00101"></a>00101                     <span class="stringliteral">&quot;channel types via the churn generator is not allowed &quot;</span>
<a name="l00102"></a>00102                     <span class="stringliteral">&quot;with the InetUnderlay. Use **.accessNet.channelTypes instead!&quot;</span>);
<a name="l00103"></a>00103     }
<a name="l00104"></a>00104 
<a name="l00105"></a>00105     node-&gt;setGateSize(<span class="stringliteral">&quot;pppg&quot;</span>, 1);
<a name="l00106"></a>00106 
<a name="l00107"></a>00107     std::string displayString;
<a name="l00108"></a>00108 
<a name="l00109"></a>00109     <span class="keywordflow">if</span> ((type.<a class="code" href="classNodeType.html#ad6f207541b281c15db64c6d87ee43143">typeID</a> &gt; 0) &amp;&amp; (type.<a class="code" href="classNodeType.html#ad6f207541b281c15db64c6d87ee43143">typeID</a> &lt;= <a class="code" href="classUnderlayConfigurator.html#a98cdd2bec4b42ccf467e8062cc5a0f7c">NUM_COLORS</a>)) {
<a name="l00110"></a>00110         ((displayString += <span class="stringliteral">&quot;i=device/wifilaptop_l,&quot;</span>)
<a name="l00111"></a>00111                         += <a class="code" href="classUnderlayConfigurator.html#ab5366368e36a4884d97ae5c3d2a82182">colorNames</a>[type.<a class="code" href="classNodeType.html#ad6f207541b281c15db64c6d87ee43143">typeID</a> - 1])
<a name="l00112"></a>00112                         += <span class="stringliteral">&quot;,40;i2=block/circle_s&quot;</span>;
<a name="l00113"></a>00113     } <span class="keywordflow">else</span> {
<a name="l00114"></a>00114         displayString = <span class="stringliteral">&quot;i=device/wifilaptop_l;i2=block/circle_s&quot;</span>;
<a name="l00115"></a>00115     }
<a name="l00116"></a>00116 
<a name="l00117"></a>00117     node-&gt;finalizeParameters();
<a name="l00118"></a>00118     node-&gt;setDisplayString(displayString.c_str());
<a name="l00119"></a>00119 
<a name="l00120"></a>00120     node-&gt;buildInside();
<a name="l00121"></a>00121     node-&gt;scheduleStart(simTime());
<a name="l00122"></a>00122 
<a name="l00123"></a>00123     <span class="comment">// create meta information</span>
<a name="l00124"></a>00124     <a class="code" href="classInetInfo.html">InetInfo</a>* info = <span class="keyword">new</span> <a class="code" href="classInetInfo.html">InetInfo</a>(type.<a class="code" href="classNodeType.html#ad6f207541b281c15db64c6d87ee43143">typeID</a>, node-&gt;getId(), type.<a class="code" href="classNodeType.html#a9490adb73cbd8c8283eba9afc7c61dc7">context</a>);
<a name="l00125"></a>00125     <a class="code" href="classAccessNet.html" title="Configuration module for access networks.">AccessNet</a>* accessNet= check_and_cast&lt;<a class="code" href="classAccessNet.html" title="Configuration module for access networks.">AccessNet</a>*&gt;
<a name="l00126"></a>00126         (<a class="code" href="classInetUnderlayConfigurator.html#a8271d89920574711ddd9c8cd4a65fab9" title="stores accessRouter">accessNode</a>[intuniform(0, <a class="code" href="classInetUnderlayConfigurator.html#a8271d89920574711ddd9c8cd4a65fab9" title="stores accessRouter">accessNode</a>.size() - 1)]
<a name="l00127"></a>00127                 -&gt;getSubmodule(<span class="stringliteral">&quot;accessNet&quot;</span>));
<a name="l00128"></a>00128 
<a name="l00129"></a>00129     info-&gt;<a class="code" href="classInetInfo.html#a9585d1249c2b1afcfedbf79e7256dcb9" title="setter and getter">setAccessNetModule</a>(accessNet);
<a name="l00130"></a>00130     info-&gt;<a class="code" href="classInetInfo.html#ad815c71baf87d6e6104aedade4f8aa73">setNodeID</a>(node-&gt;getId());
<a name="l00131"></a>00131 
<a name="l00132"></a>00132     <span class="comment">// add node to a randomly chosen access net and bootstrap oracle</span>
<a name="l00133"></a>00133     <a class="code" href="classUnderlayConfigurator.html#a18732aa18ca952e0f7973216692d7777" title="pointer to GlobalNodeList">globalNodeList</a>-&gt;<a class="code" href="classGlobalNodeList.html#a82a6c218304d734e2169e1c8fc5817ee" title="Adds new peers to the peer set.">addPeer</a>(accessNet-&gt;addOverlayNode(node), info);
<a name="l00134"></a>00134 
<a name="l00135"></a>00135     <span class="comment">// if the node was not created during startup we have to</span>
<a name="l00136"></a>00136     <span class="comment">// finish the initialization process manually</span>
<a name="l00137"></a>00137     <span class="keywordflow">if</span> (!initialize) {
<a name="l00138"></a>00138         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = <a class="code" href="InitStages_8h.html#a42fde1aa1e14a1c45d29061d6e87e532a51360a7e54ff555dc3d078d686500cb9" title="last stage for underlay configurators">MAX_STAGE_UNDERLAY</a> + 1; i &lt; <a class="code" href="InitStages_8h.html#a42fde1aa1e14a1c45d29061d6e87e532a89279af766b25396b796fe5cfd77d717" title="total number of stages">NUM_STAGES_ALL</a>; i++) {
<a name="l00139"></a>00139             node-&gt;callInitialize(i);
<a name="l00140"></a>00140         }
<a name="l00141"></a>00141     }
<a name="l00142"></a>00142 
<a name="l00143"></a>00143     <a class="code" href="classUnderlayConfigurator.html#aed1fe1d613fb061b714fc281cbb0b820" title="current number of overlay terminals">overlayTerminalCount</a>++;
<a name="l00144"></a>00144     <a class="code" href="classInetUnderlayConfigurator.html#a3ce6afb58a3a639cd8fc7977233b02b6" title="number of overall created overlay terminals">numCreated</a>++;
<a name="l00145"></a>00145 
<a name="l00146"></a>00146     <a class="code" href="classUnderlayConfigurator.html#a45b9ecd5f8deb026db63afc69c60d5a5" title="pointer to the ChurnGenerators">churnGenerator</a>[type.<a class="code" href="classNodeType.html#ad6f207541b281c15db64c6d87ee43143">typeID</a>]-&gt;terminalCount++;
<a name="l00147"></a>00147 
<a name="l00148"></a>00148     <a class="code" href="classTransportAddress.html" title="This class implements a common transport address.">TransportAddress</a> *address = <span class="keyword">new</span> <a class="code" href="classTransportAddress.html" title="This class implements a common transport address.">TransportAddress</a>(
<a name="l00149"></a>00149                                        IPAddressResolver().addressOf(node));
<a name="l00150"></a>00150 
<a name="l00151"></a>00151     <span class="comment">// update display</span>
<a name="l00152"></a>00152     <a class="code" href="classInetUnderlayConfigurator.html#a4745a89b7610e8b79207d6ea5b667a92" title="Updates the statistics display string.">setDisplayString</a>();
<a name="l00153"></a>00153 
<a name="l00154"></a>00154     <span class="keywordflow">return</span> address;
<a name="l00155"></a>00155 }
<a name="l00156"></a>00156 
<a name="l00157"></a>00157 <span class="comment">//TODO: getRandomNode()</span>
<a name="l00158"></a><a class="code" href="classInetUnderlayConfigurator.html#ad2416c55aa741e9fb8a5c534c8dbdf58">00158</a> <span class="keywordtype">void</span> <a class="code" href="classInetUnderlayConfigurator.html#ad2416c55aa741e9fb8a5c534c8dbdf58" title="Notifies and schedules overlay nodes for removal.">InetUnderlayConfigurator::preKillNode</a>(<a class="code" href="classNodeType.html" title="Enum specifying node properties.">NodeType</a> type, <a class="code" href="classTransportAddress.html" title="This class implements a common transport address.">TransportAddress</a>* addr)
<a name="l00159"></a>00159 {
<a name="l00160"></a>00160     Enter_Method_Silent();
<a name="l00161"></a>00161 
<a name="l00162"></a>00162     <a class="code" href="classAccessNet.html" title="Configuration module for access networks.">AccessNet</a>* accessNetModule = NULL;
<a name="l00163"></a>00163     <span class="keywordtype">int</span> nodeID;
<a name="l00164"></a>00164     <a class="code" href="classInetInfo.html">InetInfo</a>* info;
<a name="l00165"></a>00165 
<a name="l00166"></a>00166     <span class="comment">// If no address given, get random node</span>
<a name="l00167"></a>00167     <span class="keywordflow">if</span> (addr == NULL) {
<a name="l00168"></a>00168         addr = <a class="code" href="classUnderlayConfigurator.html#a18732aa18ca952e0f7973216692d7777" title="pointer to GlobalNodeList">globalNodeList</a>-&gt;<a class="code" href="classGlobalNodeList.html#afb768cce8523f2c55eb9449b2d489678" title="Selects a random node from the peerSet, which is not already marked for deletion.">getRandomAliveNode</a>(type.<a class="code" href="classNodeType.html#ad6f207541b281c15db64c6d87ee43143">typeID</a>);
<a name="l00169"></a>00169 
<a name="l00170"></a>00170         <span class="keywordflow">if</span> (addr == NULL) {
<a name="l00171"></a>00171             <span class="comment">// all nodes are already prekilled</span>
<a name="l00172"></a>00172             std::cout &lt;&lt; <span class="stringliteral">&quot;all nodes are already prekilled&quot;</span> &lt;&lt; std::endl;
<a name="l00173"></a>00173             <span class="keywordflow">return</span>;
<a name="l00174"></a>00174         }
<a name="l00175"></a>00175     }
<a name="l00176"></a>00176 
<a name="l00177"></a>00177     <span class="comment">// get node information</span>
<a name="l00178"></a>00178     info = <span class="keyword">dynamic_cast&lt;</span><a class="code" href="classInetInfo.html">InetInfo</a>*<span class="keyword">&gt;</span>(<a class="code" href="classUnderlayConfigurator.html#a18732aa18ca952e0f7973216692d7777" title="pointer to GlobalNodeList">globalNodeList</a>-&gt;<a class="code" href="classGlobalNodeList.html#a985bf687f11d68d4a6699e7fa2367e9a" title="Searches the peerSet for the specified node.">getPeerInfo</a>(*addr));
<a name="l00179"></a>00179 
<a name="l00180"></a>00180     <span class="keywordflow">if</span> (info != NULL) {
<a name="l00181"></a>00181         accessNetModule = info-&gt;<a class="code" href="classInetInfo.html#a4daa8d6aa4109c5add6ed2f5da7adf23">getAccessNetModule</a>();
<a name="l00182"></a>00182         nodeID = info-&gt;<a class="code" href="classInetInfo.html#a85bd199781386272bf66bb3af9141a08">getNodeID</a>();
<a name="l00183"></a>00183     } <span class="keywordflow">else</span> {
<a name="l00184"></a>00184         opp_error(<span class="stringliteral">&quot;IPv4UnderlayConfigurator: Trying to pre kill node &quot;</span>
<a name="l00185"></a>00185                   <span class="stringliteral">&quot;with nonexistant TransportAddress!&quot;</span>);
<a name="l00186"></a>00186     }
<a name="l00187"></a>00187 
<a name="l00188"></a>00188     uint32_t effectiveType = info-&gt;<a class="code" href="classPeerInfo.html#a7b01dcdd9a7828c03feef39d5135ab1d" title="returns the type of the node">getTypeID</a>();
<a name="l00189"></a>00189 
<a name="l00190"></a>00190     <span class="comment">// do not kill node that is already scheduled</span>
<a name="l00191"></a>00191     <span class="keywordflow">if</span>(<a class="code" href="classInetUnderlayConfigurator.html#a703bd91d5cc400f60418ef23b40e0944" title="stores nodeIds to prevent migration of prekilled nodes">scheduledID</a>.count(nodeID))
<a name="l00192"></a>00192         <span class="keywordflow">return</span>;
<a name="l00193"></a>00193 
<a name="l00194"></a>00194     cModule* node = accessNetModule-&gt;<a class="code" href="classAccessNet.html#ae8fe2ceae197c110c0da3024082c3fcf" title="searches overlayTerminal[] for a given node">getOverlayNode</a>(nodeID);
<a name="l00195"></a>00195     <a class="code" href="classUnderlayConfigurator.html#a18732aa18ca952e0f7973216692d7777" title="pointer to GlobalNodeList">globalNodeList</a>-&gt;<a class="code" href="classGlobalNodeList.html#ad71420e64d6f5466ecfd95d8ab56ca55" title="Debootstraps peers in the peer set.">removePeer</a>(IPAddressResolver().addressOf(node));
<a name="l00196"></a>00196 
<a name="l00197"></a>00197     <span class="comment">//put node into the kill list and schedule a message for final removal of the node</span>
<a name="l00198"></a>00198     <a class="code" href="classInetUnderlayConfigurator.html#a9dd551ac81ef13c2da0aed929c5c3256" title="stores nodes scheduled to be killed">killList</a>.push_front(IPAddressResolver().addressOf(node));
<a name="l00199"></a>00199     <a class="code" href="classInetUnderlayConfigurator.html#a703bd91d5cc400f60418ef23b40e0944" title="stores nodeIds to prevent migration of prekilled nodes">scheduledID</a>.insert(nodeID);
<a name="l00200"></a>00200 
<a name="l00201"></a>00201     <a class="code" href="classUnderlayConfigurator.html#aed1fe1d613fb061b714fc281cbb0b820" title="current number of overlay terminals">overlayTerminalCount</a>--;
<a name="l00202"></a>00202     <a class="code" href="classInetUnderlayConfigurator.html#aa7434e33dfa90cc8b0b14575a12a33fc" title="number of overall killed overlay terminals">numKilled</a>++;
<a name="l00203"></a>00203 
<a name="l00204"></a>00204     <a class="code" href="classUnderlayConfigurator.html#a45b9ecd5f8deb026db63afc69c60d5a5" title="pointer to the ChurnGenerators">churnGenerator</a>[effectiveType]-&gt;terminalCount--;
<a name="l00205"></a>00205 
<a name="l00206"></a>00206     <span class="comment">// update display</span>
<a name="l00207"></a>00207     <a class="code" href="classInetUnderlayConfigurator.html#a4745a89b7610e8b79207d6ea5b667a92" title="Updates the statistics display string.">setDisplayString</a>();
<a name="l00208"></a>00208 
<a name="l00209"></a>00209     <span class="comment">// inform the notification board about the removal</span>
<a name="l00210"></a>00210     NotificationBoard* nb = check_and_cast&lt;NotificationBoard*&gt;(
<a name="l00211"></a>00211             node-&gt;getSubmodule(<span class="stringliteral">&quot;notificationBoard&quot;</span>));
<a name="l00212"></a>00212     nb-&gt;fireChangeNotification(NF_OVERLAY_NODE_LEAVE);
<a name="l00213"></a>00213 
<a name="l00214"></a>00214     <span class="keywordtype">double</span> random = uniform(0, 1);
<a name="l00215"></a>00215 
<a name="l00216"></a>00216     <span class="keywordflow">if</span> (random &lt; <a class="code" href="classUnderlayConfigurator.html#afac0cabcbc3d20fd6c490ea27918372e" title="probability that node is notified befor removal">gracefulLeaveProbability</a>) {
<a name="l00217"></a>00217         nb-&gt;fireChangeNotification(NF_OVERLAY_NODE_GRACEFUL_LEAVE);
<a name="l00218"></a>00218     }
<a name="l00219"></a>00219 
<a name="l00220"></a>00220     cMessage* msg = <span class="keyword">new</span> cMessage();
<a name="l00221"></a>00221     scheduleAt(simTime() + <a class="code" href="classUnderlayConfigurator.html#a940d214081be6860f8410511c2da7ad5" title="delay until scheduled node is removed from overlay">gracefulLeaveDelay</a>, msg);
<a name="l00222"></a>00222 
<a name="l00223"></a>00223 }
<a name="l00224"></a>00224 
<a name="l00225"></a><a class="code" href="classInetUnderlayConfigurator.html#a66db5fcccbd12df400b1707863cae9e1">00225</a> <span class="keywordtype">void</span> <a class="code" href="classInetUnderlayConfigurator.html#a66db5fcccbd12df400b1707863cae9e1" title="Migrates overlay nodes from one access net to another.">InetUnderlayConfigurator::migrateNode</a>(<a class="code" href="classNodeType.html" title="Enum specifying node properties.">NodeType</a> type, <a class="code" href="classTransportAddress.html" title="This class implements a common transport address.">TransportAddress</a>* addr)
<a name="l00226"></a>00226 {
<a name="l00227"></a>00227     Enter_Method_Silent();
<a name="l00228"></a>00228 
<a name="l00229"></a>00229     <a class="code" href="classAccessNet.html" title="Configuration module for access networks.">AccessNet</a>* accessNetModule = NULL;
<a name="l00230"></a>00230     <span class="keywordtype">int</span> nodeID = -1;
<a name="l00231"></a>00231     <a class="code" href="classInetInfo.html">InetInfo</a>* info;
<a name="l00232"></a>00232 
<a name="l00233"></a>00233     <span class="comment">// If no address given, get random node</span>
<a name="l00234"></a>00234     <span class="keywordflow">if</span>(addr == NULL) {
<a name="l00235"></a>00235         info = <span class="keyword">dynamic_cast&lt;</span><a class="code" href="classInetInfo.html">InetInfo</a>*<span class="keyword">&gt;</span>(<a class="code" href="classUnderlayConfigurator.html#a18732aa18ca952e0f7973216692d7777" title="pointer to GlobalNodeList">globalNodeList</a>-&gt;<a class="code" href="classGlobalNodeList.html#a0b09f249680c3ae737af916a8a54f75f" title="Selects a random node from the peerSet.">getRandomPeerInfo</a>(type.<a class="code" href="classNodeType.html#ad6f207541b281c15db64c6d87ee43143">typeID</a>));
<a name="l00236"></a>00236     } <span class="keywordflow">else</span> {
<a name="l00237"></a>00237         <span class="comment">// get node information</span>
<a name="l00238"></a>00238         info = <span class="keyword">dynamic_cast&lt;</span><a class="code" href="classInetInfo.html">InetInfo</a>*<span class="keyword">&gt;</span>(<a class="code" href="classUnderlayConfigurator.html#a18732aa18ca952e0f7973216692d7777" title="pointer to GlobalNodeList">globalNodeList</a>-&gt;<a class="code" href="classGlobalNodeList.html#a985bf687f11d68d4a6699e7fa2367e9a" title="Searches the peerSet for the specified node.">getPeerInfo</a>(*addr));
<a name="l00239"></a>00239     }
<a name="l00240"></a>00240 
<a name="l00241"></a>00241     <span class="keywordflow">if</span>(info != NULL) {
<a name="l00242"></a>00242         accessNetModule = info-&gt;<a class="code" href="classInetInfo.html#a4daa8d6aa4109c5add6ed2f5da7adf23">getAccessNetModule</a>();
<a name="l00243"></a>00243         nodeID = info-&gt;<a class="code" href="classInetInfo.html#a85bd199781386272bf66bb3af9141a08">getNodeID</a>();
<a name="l00244"></a>00244     } <span class="keywordflow">else</span> {
<a name="l00245"></a>00245         opp_error(<span class="stringliteral">&quot;IPv4UnderlayConfigurator: Trying to pre kill node with nonexistant TransportAddress!&quot;</span>);
<a name="l00246"></a>00246     }
<a name="l00247"></a>00247 
<a name="l00248"></a>00248     <span class="comment">// do not migrate node that is already scheduled</span>
<a name="l00249"></a>00249     <span class="keywordflow">if</span>(<a class="code" href="classInetUnderlayConfigurator.html#a703bd91d5cc400f60418ef23b40e0944" title="stores nodeIds to prevent migration of prekilled nodes">scheduledID</a>.count(nodeID))
<a name="l00250"></a>00250         <span class="keywordflow">return</span>;
<a name="l00251"></a>00251 
<a name="l00252"></a>00252     cModule* node = accessNetModule-&gt;<a class="code" href="classAccessNet.html#a24b138a835855095b3e4482e40c546bc" title="Removes a node from the access net.">removeOverlayNode</a>(nodeID);<span class="comment">//intuniform(0, accessNetModule-&gt;size() - 1));</span>
<a name="l00253"></a>00253 
<a name="l00254"></a>00254     <span class="keywordflow">if</span>(node == NULL)
<a name="l00255"></a>00255         opp_error(<span class="stringliteral">&quot;IPv4UnderlayConfigurator: Trying to remove node which is nonexistant in AccessNet!&quot;</span>);
<a name="l00256"></a>00256 
<a name="l00257"></a>00257     <span class="comment">//remove node from bootstrap oracle</span>
<a name="l00258"></a>00258     <a class="code" href="classUnderlayConfigurator.html#a18732aa18ca952e0f7973216692d7777" title="pointer to GlobalNodeList">globalNodeList</a>-&gt;<a class="code" href="classGlobalNodeList.html#a94d01badb00975930c2ed108e065fdf7" title="Removes a peer from the peerSet.">killPeer</a>(IPAddressResolver().addressOf(node));
<a name="l00259"></a>00259 
<a name="l00260"></a>00260     node-&gt;bubble(<span class="stringliteral">&quot;I am migrating!&quot;</span>);
<a name="l00261"></a>00261 
<a name="l00262"></a>00262     <span class="comment">// connect the node to another access net</span>
<a name="l00263"></a>00263     <a class="code" href="classAccessNet.html" title="Configuration module for access networks.">AccessNet</a>* newAccessNetModule;
<a name="l00264"></a>00264 
<a name="l00265"></a>00265     <span class="keywordflow">do</span> {
<a name="l00266"></a>00266         newAccessNetModule = check_and_cast&lt;<a class="code" href="classAccessNet.html" title="Configuration module for access networks.">AccessNet</a>*&gt;(<a class="code" href="classInetUnderlayConfigurator.html#a8271d89920574711ddd9c8cd4a65fab9" title="stores accessRouter">accessNode</a>[intuniform(0, <a class="code" href="classInetUnderlayConfigurator.html#a8271d89920574711ddd9c8cd4a65fab9" title="stores accessRouter">accessNode</a>.size() - 1)]-&gt;getSubmodule(<span class="stringliteral">&quot;accessNet&quot;</span>));
<a name="l00267"></a>00267     } <span class="keywordflow">while</span>((newAccessNetModule == accessNetModule) &amp;&amp; (<a class="code" href="classInetUnderlayConfigurator.html#a8271d89920574711ddd9c8cd4a65fab9" title="stores accessRouter">accessNode</a>.size() != 1));
<a name="l00268"></a>00268 
<a name="l00269"></a>00269     <span class="comment">// create meta information</span>
<a name="l00270"></a>00270     <a class="code" href="classInetInfo.html">InetInfo</a>* newinfo = <span class="keyword">new</span> <a class="code" href="classInetInfo.html">InetInfo</a>(type.<a class="code" href="classNodeType.html#ad6f207541b281c15db64c6d87ee43143">typeID</a>, node-&gt;getId(), type.<a class="code" href="classNodeType.html#a9490adb73cbd8c8283eba9afc7c61dc7">context</a>);
<a name="l00271"></a>00271 
<a name="l00272"></a>00272     newinfo-&gt;<a class="code" href="classInetInfo.html#a9585d1249c2b1afcfedbf79e7256dcb9" title="setter and getter">setAccessNetModule</a>(newAccessNetModule);
<a name="l00273"></a>00273     newinfo-&gt;<a class="code" href="classInetInfo.html#ad815c71baf87d6e6104aedade4f8aa73">setNodeID</a>(node-&gt;getId());
<a name="l00274"></a>00274 
<a name="l00275"></a>00275     <span class="comment">//add node to a randomly chosen access net bootstrap oracle</span>
<a name="l00276"></a>00276     <a class="code" href="classUnderlayConfigurator.html#a18732aa18ca952e0f7973216692d7777" title="pointer to GlobalNodeList">globalNodeList</a>-&gt;<a class="code" href="classGlobalNodeList.html#a82a6c218304d734e2169e1c8fc5817ee" title="Adds new peers to the peer set.">addPeer</a>(newAccessNetModule-&gt;<a class="code" href="classAccessNet.html#a0fbbc43fd47f107e7f769e2602f0fdad" title="Gathers some information about the terminal and appends it to the overlay terminal vector...">addOverlayNode</a>(node, <span class="keyword">true</span>), newinfo);
<a name="l00277"></a>00277 
<a name="l00278"></a>00278     <span class="comment">// inform the notification board about the migration</span>
<a name="l00279"></a>00279     NotificationBoard* nb = check_and_cast&lt;NotificationBoard*&gt;(node-&gt;getSubmodule(<span class="stringliteral">&quot;notificationBoard&quot;</span>));
<a name="l00280"></a>00280     nb-&gt;fireChangeNotification(NF_OVERLAY_TRANSPORTADDRESS_CHANGED);
<a name="l00281"></a>00281 }
<a name="l00282"></a>00282 
<a name="l00283"></a><a class="code" href="classInetUnderlayConfigurator.html#ab228f2cb20ae7bd43befd637645b4f7e">00283</a> <span class="keywordtype">void</span> <a class="code" href="classInetUnderlayConfigurator.html#ab228f2cb20ae7bd43befd637645b4f7e" title="process timer messages">InetUnderlayConfigurator::handleTimerEvent</a>(cMessage* msg)
<a name="l00284"></a>00284 {
<a name="l00285"></a>00285     Enter_Method_Silent();
<a name="l00286"></a>00286 
<a name="l00287"></a>00287     <span class="comment">// get next scheduled node from the kill list</span>
<a name="l00288"></a>00288     IPvXAddress addr = <a class="code" href="classInetUnderlayConfigurator.html#a9dd551ac81ef13c2da0aed929c5c3256" title="stores nodes scheduled to be killed">killList</a>.back();
<a name="l00289"></a>00289     <a class="code" href="classInetUnderlayConfigurator.html#a9dd551ac81ef13c2da0aed929c5c3256" title="stores nodes scheduled to be killed">killList</a>.pop_back();
<a name="l00290"></a>00290 
<a name="l00291"></a>00291     <a class="code" href="classAccessNet.html" title="Configuration module for access networks.">AccessNet</a>* accessNetModule = NULL;
<a name="l00292"></a>00292     <span class="keywordtype">int</span> nodeID = -1;
<a name="l00293"></a>00293 
<a name="l00294"></a>00294     <a class="code" href="classInetInfo.html">InetInfo</a>* info = <span class="keyword">dynamic_cast&lt;</span><a class="code" href="classInetInfo.html">InetInfo</a>*<span class="keyword">&gt;</span>(<a class="code" href="classUnderlayConfigurator.html#a18732aa18ca952e0f7973216692d7777" title="pointer to GlobalNodeList">globalNodeList</a>-&gt;<a class="code" href="classGlobalNodeList.html#a985bf687f11d68d4a6699e7fa2367e9a" title="Searches the peerSet for the specified node.">getPeerInfo</a>(addr));
<a name="l00295"></a>00295     <span class="keywordflow">if</span>(info != NULL) {
<a name="l00296"></a>00296         accessNetModule = info-&gt;<a class="code" href="classInetInfo.html#a4daa8d6aa4109c5add6ed2f5da7adf23">getAccessNetModule</a>();
<a name="l00297"></a>00297         nodeID = info-&gt;<a class="code" href="classInetInfo.html#a85bd199781386272bf66bb3af9141a08">getNodeID</a>();
<a name="l00298"></a>00298     } <span class="keywordflow">else</span> {
<a name="l00299"></a>00299         opp_error(<span class="stringliteral">&quot;IPv4UnderlayConfigurator: Trying to kill node with nonexistant TransportAddress!&quot;</span>);
<a name="l00300"></a>00300     }
<a name="l00301"></a>00301 
<a name="l00302"></a>00302     <a class="code" href="classInetUnderlayConfigurator.html#a703bd91d5cc400f60418ef23b40e0944" title="stores nodeIds to prevent migration of prekilled nodes">scheduledID</a>.erase(nodeID);
<a name="l00303"></a>00303     <a class="code" href="classUnderlayConfigurator.html#a18732aa18ca952e0f7973216692d7777" title="pointer to GlobalNodeList">globalNodeList</a>-&gt;<a class="code" href="classGlobalNodeList.html#a94d01badb00975930c2ed108e065fdf7" title="Removes a peer from the peerSet.">killPeer</a>(addr);
<a name="l00304"></a>00304 
<a name="l00305"></a>00305     cModule* node = accessNetModule-&gt;<a class="code" href="classAccessNet.html#a24b138a835855095b3e4482e40c546bc" title="Removes a node from the access net.">removeOverlayNode</a>(nodeID);
<a name="l00306"></a>00306 
<a name="l00307"></a>00307     <span class="keywordflow">if</span>(node == NULL)
<a name="l00308"></a>00308         opp_error(<span class="stringliteral">&quot;IPv4UnderlayConfigurator: Trying to remove node which is nonexistant in AccessNet!&quot;</span>);
<a name="l00309"></a>00309 
<a name="l00310"></a>00310     node-&gt;callFinish();
<a name="l00311"></a>00311     node-&gt;deleteModule();
<a name="l00312"></a>00312 
<a name="l00313"></a>00313     <span class="keyword">delete</span> msg;
<a name="l00314"></a>00314 }
<a name="l00315"></a>00315 
<a name="l00316"></a><a class="code" href="classInetUnderlayConfigurator.html#a4745a89b7610e8b79207d6ea5b667a92">00316</a> <span class="keywordtype">void</span> <a class="code" href="classInetUnderlayConfigurator.html#a4745a89b7610e8b79207d6ea5b667a92" title="Updates the statistics display string.">InetUnderlayConfigurator::setDisplayString</a>()
<a name="l00317"></a>00317 {
<a name="l00318"></a>00318     <span class="keywordtype">char</span> buf[80];
<a name="l00319"></a>00319     sprintf(buf, <span class="stringliteral">&quot;%i overlay terminals\n%i access router\n%i overlay access router&quot;</span>,
<a name="l00320"></a>00320             <a class="code" href="classUnderlayConfigurator.html#aed1fe1d613fb061b714fc281cbb0b820" title="current number of overlay terminals">overlayTerminalCount</a>, <a class="code" href="classInetUnderlayConfigurator.html#af94467080ac95c8b5197568da39cb1fe" title="number of access router">accessRouterNum</a>, <a class="code" href="classInetUnderlayConfigurator.html#a9ba1baa1cd1979f23eda0585eadd39e5" title="number of overlayAccessRouter">overlayAccessRouterNum</a>);
<a name="l00321"></a>00321     getDisplayString().setTagArg(<span class="stringliteral">&quot;t&quot;</span>, 0, buf);
<a name="l00322"></a>00322 }
<a name="l00323"></a>00323 
<a name="l00324"></a><a class="code" href="classInetUnderlayConfigurator.html#a49b4205bc24b00ef83d3eb634f6f8f63">00324</a> <span class="keywordtype">void</span> <a class="code" href="classInetUnderlayConfigurator.html#a49b4205bc24b00ef83d3eb634f6f8f63" title="Saves statistics, prints simulation time.">InetUnderlayConfigurator::finishUnderlay</a>()
<a name="l00325"></a>00325 {
<a name="l00326"></a>00326     <span class="comment">// statistics</span>
<a name="l00327"></a>00327     recordScalar(<span class="stringliteral">&quot;Terminals added&quot;</span>, <a class="code" href="classInetUnderlayConfigurator.html#a3ce6afb58a3a639cd8fc7977233b02b6" title="number of overall created overlay terminals">numCreated</a>);
<a name="l00328"></a>00328     recordScalar(<span class="stringliteral">&quot;Terminals removed&quot;</span>, <a class="code" href="classInetUnderlayConfigurator.html#aa7434e33dfa90cc8b0b14575a12a33fc" title="number of overall killed overlay terminals">numKilled</a>);
<a name="l00329"></a>00329 
<a name="l00330"></a>00330     <span class="keywordflow">if</span> (!<a class="code" href="classUnderlayConfigurator.html#a00c2e85286a38799c7a04edb52ae6e76" title="still in initialization phase?">isInInitPhase</a>()) {
<a name="l00331"></a>00331         <span class="keyword">struct </span>timeval now, diff;
<a name="l00332"></a>00332         gettimeofday(&amp;now, NULL);
<a name="l00333"></a>00333         <a class="code" href="UnderlayConfigurator_8h.html#a8b18f762e42417ce5d86090331d3e4eb">timersub</a>(&amp;now, &amp;<a class="code" href="classUnderlayConfigurator.html#a2675d1d01baaac0fe01436d01deabd13" title="timestamp at end of init phase">initFinishedTime</a>, &amp;diff);
<a name="l00334"></a>00334         printf(<span class="stringliteral">&quot;Simulation time: %li.%06li\n&quot;</span>, diff.tv_sec, diff.tv_usec);
<a name="l00335"></a>00335     }
<a name="l00336"></a>00336 }
<a name="l00337"></a>00337 
<a name="l00338"></a><a class="code" href="classInetUnderlayConfigurator.html#a8a7d9b35842e31ffa7a590110d11205a">00338</a> <span class="keywordtype">void</span> <a class="code" href="classInetUnderlayConfigurator.html#a8a7d9b35842e31ffa7a590110d11205a">InetUnderlayConfigurator::setUpIPv4</a>(cTopology &amp;topo)
<a name="l00339"></a>00339 {
<a name="l00340"></a>00340     <span class="comment">// Assign IP addresses to all router modules.</span>
<a name="l00341"></a>00341     std::vector&lt;uint32&gt; nodeAddresses;
<a name="l00342"></a>00342     nodeAddresses.resize(topo.getNumNodes());
<a name="l00343"></a>00343 
<a name="l00344"></a>00344     <span class="comment">// IP addresses for backbone</span>
<a name="l00345"></a>00345     <span class="comment">// Take start IP from config file</span>
<a name="l00346"></a>00346     <span class="comment">// FIXME: Make Netmask for Routers configurable!</span>
<a name="l00347"></a>00347     uint32 lowIPBoundary = IPAddress(par(<span class="stringliteral">&quot;startIPv4&quot;</span>).stringValue()).getInt();
<a name="l00348"></a>00348 
<a name="l00349"></a>00349     <span class="comment">// uint32 lowIPBoundary = uint32((1 &lt;&lt; 24) + 1);</span>
<a name="l00350"></a>00350     <span class="keywordtype">int</span> numIPNodes = 0;
<a name="l00351"></a>00351 
<a name="l00352"></a>00352     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; topo.getNumNodes(); i++) {
<a name="l00353"></a>00353         ++numIPNodes;
<a name="l00354"></a>00354 
<a name="l00355"></a>00355         uint32 addr = lowIPBoundary + uint32(numIPNodes &lt;&lt; 16);
<a name="l00356"></a>00356         nodeAddresses[i] = addr;
<a name="l00357"></a>00357 
<a name="l00358"></a>00358         <span class="comment">// update ip display string</span>
<a name="l00359"></a>00359         <span class="keywordflow">if</span> (ev.isGUI()) {
<a name="l00360"></a>00360             topo.getNode(i)-&gt;getModule()-&gt;getDisplayString().insertTag(<span class="stringliteral">&quot;t&quot;</span>, 0);
<a name="l00361"></a>00361             topo.getNode(i)-&gt;getModule()-&gt;getDisplayString().setTagArg(<span class="stringliteral">&quot;t&quot;</span>, 0,
<a name="l00362"></a>00362                                     const_cast&lt;char*&gt;(IPAddress(addr).str().c_str()));
<a name="l00363"></a>00363             topo.getNode(i)-&gt;getModule()-&gt;getDisplayString().setTagArg(<span class="stringliteral">&quot;t&quot;</span>, 1, <span class="stringliteral">&quot;l&quot;</span>);
<a name="l00364"></a>00364             topo.getNode(i)-&gt;getModule()-&gt;getDisplayString().setTagArg(<span class="stringliteral">&quot;t&quot;</span>, 2, <span class="stringliteral">&quot;red&quot;</span>);
<a name="l00365"></a>00365         }
<a name="l00366"></a>00366 
<a name="l00367"></a>00367         <span class="comment">// find interface table and assign address to all (non-loopback) interfaces</span>
<a name="l00368"></a>00368         IInterfaceTable* ift = IPAddressResolver().interfaceTableOf(topo.getNode(i)-&gt;getModule());
<a name="l00369"></a>00369 
<a name="l00370"></a>00370         <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> k = 0; k &lt; ift-&gt;getNumInterfaces(); k++ ) {
<a name="l00371"></a>00371             InterfaceEntry* ie = ift-&gt;getInterface(k);
<a name="l00372"></a>00372             <span class="keywordflow">if</span> (!ie-&gt;isLoopback()) {
<a name="l00373"></a>00373                 ie-&gt;ipv4Data()-&gt;setIPAddress(IPAddress(addr));
<a name="l00374"></a>00374                 <span class="comment">// full address must match for local delivery</span>
<a name="l00375"></a>00375                 ie-&gt;ipv4Data()-&gt;setNetmask(IPAddress::ALLONES_ADDRESS);
<a name="l00376"></a>00376             }
<a name="l00377"></a>00377         }
<a name="l00378"></a>00378     }
<a name="l00379"></a>00379 
<a name="l00380"></a>00380     <span class="comment">// Fill in routing tables.</span>
<a name="l00381"></a>00381     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; topo.getNumNodes(); i++) {
<a name="l00382"></a>00382         cTopology::Node* destNode = topo.getNode(i);
<a name="l00383"></a>00383         uint32 destAddr = nodeAddresses[i];
<a name="l00384"></a>00384 
<a name="l00385"></a>00385         <span class="comment">// calculate shortest paths from everywhere towards destNode</span>
<a name="l00386"></a>00386         topo.calculateUnweightedSingleShortestPathsTo(destNode);
<a name="l00387"></a>00387 
<a name="l00388"></a>00388         <span class="comment">// add overlayAccessRouters and overlayBackboneRouters</span>
<a name="l00389"></a>00389         <span class="comment">// to the GlobalNodeList</span>
<a name="l00390"></a>00390         <span class="keywordflow">if</span> ((strcmp(destNode-&gt;getModule()-&gt;getName(), <span class="stringliteral">&quot;overlayBackboneRouter&quot;</span>) == 0) ||
<a name="l00391"></a>00391                 (strcmp(destNode-&gt;getModule()-&gt;getName(), <span class="stringliteral">&quot;overlayAccessRouter&quot;</span>) == 0)) {
<a name="l00392"></a>00392             <span class="comment">//add node to bootstrap oracle</span>
<a name="l00393"></a>00393             <a class="code" href="classPeerInfo.html" title="Base class for providing additional underlay specific information associated with a certain transport...">PeerInfo</a>* info = <span class="keyword">new</span> <a class="code" href="classPeerInfo.html" title="Base class for providing additional underlay specific information associated with a certain transport...">PeerInfo</a>(0, destNode-&gt;getModule()-&gt;getId(), NULL);
<a name="l00394"></a>00394             <a class="code" href="classUnderlayConfigurator.html#a18732aa18ca952e0f7973216692d7777" title="pointer to GlobalNodeList">globalNodeList</a>-&gt;<a class="code" href="classGlobalNodeList.html#a82a6c218304d734e2169e1c8fc5817ee" title="Adds new peers to the peer set.">addPeer</a>(IPvXAddress(nodeAddresses[i]), info);
<a name="l00395"></a>00395         }
<a name="l00396"></a>00396 
<a name="l00397"></a>00397 
<a name="l00398"></a>00398         <span class="comment">// If destNode is the outRouter, add a default route</span>
<a name="l00399"></a>00399         <span class="comment">// to outside network via the TunOutDevice and a route to the</span>
<a name="l00400"></a>00400         <span class="comment">// Gateway</span>
<a name="l00401"></a>00401         <span class="keywordflow">if</span> ( strcmp(destNode-&gt;getModule()-&gt;getName(), <span class="stringliteral">&quot;outRouter&quot;</span> ) == 0 ) {
<a name="l00402"></a>00402             IPRoute* defRoute = <span class="keyword">new</span> IPRoute();
<a name="l00403"></a>00403             defRoute-&gt;setHost(IPAddress::UNSPECIFIED_ADDRESS);
<a name="l00404"></a>00404             defRoute-&gt;setNetmask(IPAddress::UNSPECIFIED_ADDRESS);
<a name="l00405"></a>00405             defRoute-&gt;setGateway(IPAddress(par(<span class="stringliteral">&quot;gatewayIP&quot;</span>).stringValue()));
<a name="l00406"></a>00406             defRoute-&gt;setInterface(IPAddressResolver().interfaceTableOf(destNode-&gt;getModule())-&gt;getInterfaceByName(<span class="stringliteral">&quot;tunDev&quot;</span>));
<a name="l00407"></a>00407             defRoute-&gt;setType(IPRoute::REMOTE);
<a name="l00408"></a>00408             defRoute-&gt;setSource(IPRoute::MANUAL);
<a name="l00409"></a>00409             IPAddressResolver().routingTableOf(destNode-&gt;getModule())-&gt;addRoute(defRoute);
<a name="l00410"></a>00410 
<a name="l00411"></a>00411             IPRoute* gwRoute = <span class="keyword">new</span> IPRoute();
<a name="l00412"></a>00412             gwRoute-&gt;setHost(IPAddress(par(<span class="stringliteral">&quot;gatewayIP&quot;</span>).stringValue()));
<a name="l00413"></a>00413             gwRoute-&gt;setNetmask(IPAddress(255, 255, 255, 255));
<a name="l00414"></a>00414             gwRoute-&gt;setInterface(IPAddressResolver().interfaceTableOf(destNode-&gt;getModule())-&gt;getInterfaceByName(<span class="stringliteral">&quot;tunDev&quot;</span>));
<a name="l00415"></a>00415             gwRoute-&gt;setType(IPRoute::DIRECT);
<a name="l00416"></a>00416             gwRoute-&gt;setSource(IPRoute::MANUAL);
<a name="l00417"></a>00417             IPAddressResolver().routingTableOf(destNode-&gt;getModule())-&gt;addRoute(gwRoute);
<a name="l00418"></a>00418         }
<a name="l00419"></a>00419 
<a name="l00420"></a>00420         <span class="comment">// add route (with host=destNode) to every routing table in the network</span>
<a name="l00421"></a>00421         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; topo.getNumNodes(); j++) {
<a name="l00422"></a>00422             <span class="comment">// continue if same node</span>
<a name="l00423"></a>00423             <span class="keywordflow">if</span> (i == j)
<a name="l00424"></a>00424                 <span class="keywordflow">continue</span>;
<a name="l00425"></a>00425 
<a name="l00426"></a>00426             <span class="comment">// cancel simulation if node is not connected with destination</span>
<a name="l00427"></a>00427             cTopology::Node* atNode = topo.getNode(j);
<a name="l00428"></a>00428 
<a name="l00429"></a>00429             <span class="keywordflow">if</span> (atNode-&gt;getNumPaths() == 0) {
<a name="l00430"></a>00430                 <a class="code" href="yang_8cc.html#adb989392f8aada21b0f7ec2f7a41dc00">error</a>((std::string(atNode-&gt;getModule()-&gt;getName()) + <span class="stringliteral">&quot;: Network is not entirely connected.&quot;</span>
<a name="l00431"></a>00431                         <span class="stringliteral">&quot;Please increase your value for the &quot;</span>
<a name="l00432"></a>00432                         <span class="stringliteral">&quot;connectivity parameter&quot;</span>).c_str());
<a name="l00433"></a>00433             }
<a name="l00434"></a>00434 
<a name="l00435"></a>00435             <span class="comment">//</span>
<a name="l00436"></a>00436             <span class="comment">// Add routes at the atNode.</span>
<a name="l00437"></a>00437             <span class="comment">//</span>
<a name="l00438"></a>00438 
<a name="l00439"></a>00439             <span class="comment">// find atNode&#39;s interface and routing table</span>
<a name="l00440"></a>00440             IInterfaceTable* ift = IPAddressResolver().interfaceTableOf(atNode-&gt;getModule());
<a name="l00441"></a>00441             IRoutingTable* rt = IPAddressResolver().routingTableOf(atNode-&gt;getModule());
<a name="l00442"></a>00442 
<a name="l00443"></a>00443             <span class="comment">// find atNode&#39;s interface entry for the next hop node</span>
<a name="l00444"></a>00444             <span class="keywordtype">int</span> outputGateId = atNode-&gt;getPath(0)-&gt;getLocalGate()-&gt;getId();
<a name="l00445"></a>00445             InterfaceEntry *ie = ift-&gt;getInterfaceByNodeOutputGateId(outputGateId);
<a name="l00446"></a>00446 
<a name="l00447"></a>00447             <span class="comment">// find the next hop node on the path towards destNode</span>
<a name="l00448"></a>00448             cModule* next_hop = atNode-&gt;getPath(0)-&gt;getRemoteNode()-&gt;getModule();
<a name="l00449"></a>00449             IPAddress next_hop_ip = IPAddressResolver().addressOf(next_hop).get4();
<a name="l00450"></a>00450 
<a name="l00451"></a>00451 
<a name="l00452"></a>00452             <span class="comment">// Requirement 1: Each router has exactly one routing entry</span>
<a name="l00453"></a>00453             <span class="comment">// (netmask 255.255.0.0) to each other router</span>
<a name="l00454"></a>00454             IPRoute* <a class="code" href="VastDefs_8h.html#a51f63d24f02be00251e895721eae51b0">re</a> = <span class="keyword">new</span> IPRoute();
<a name="l00455"></a>00455 
<a name="l00456"></a>00456             re-&gt;setHost(IPAddress(destAddr));
<a name="l00457"></a>00457             re-&gt;setInterface(ie);
<a name="l00458"></a>00458             re-&gt;setSource(IPRoute::MANUAL);
<a name="l00459"></a>00459             re-&gt;setNetmask(IPAddress(255, 255, 0, 0));
<a name="l00460"></a>00460             re-&gt;setGateway(IPAddress(next_hop_ip));
<a name="l00461"></a>00461             re-&gt;setType(IPRoute::REMOTE);
<a name="l00462"></a>00462 
<a name="l00463"></a>00463             rt-&gt;addRoute(re);
<a name="l00464"></a>00464 
<a name="l00465"></a>00465             <span class="comment">// Requirement 2: Each router has a point-to-point routing</span>
<a name="l00466"></a>00466             <span class="comment">// entry (netmask 255.255.255.255) for each immediate neighbour</span>
<a name="l00467"></a>00467             <span class="keywordflow">if</span> (atNode-&gt;getDistanceToTarget() == 1) {
<a name="l00468"></a>00468                 IPRoute* re2 = <span class="keyword">new</span> IPRoute();
<a name="l00469"></a>00469 
<a name="l00470"></a>00470                 re2-&gt;setHost(IPAddress(destAddr));
<a name="l00471"></a>00471                 re2-&gt;setInterface(ie);
<a name="l00472"></a>00472                 re2-&gt;setSource(IPRoute::MANUAL);
<a name="l00473"></a>00473                 re2-&gt;setNetmask(IPAddress(255, 255, 255, 255));
<a name="l00474"></a>00474                 re2-&gt;setType(IPRoute::DIRECT);
<a name="l00475"></a>00475 
<a name="l00476"></a>00476                 rt-&gt;addRoute(re2);
<a name="l00477"></a>00477             }
<a name="l00478"></a>00478 
<a name="l00479"></a>00479             <span class="comment">// If destNode is the outRouter, add a default route</span>
<a name="l00480"></a>00480             <span class="comment">// to the next hop in the direction of the outRouter</span>
<a name="l00481"></a>00481             <span class="keywordflow">if</span> (strcmp(destNode-&gt;getModule()-&gt;getName(), <span class="stringliteral">&quot;outRouter&quot;</span> ) == 0) {
<a name="l00482"></a>00482                 IPRoute* defRoute = <span class="keyword">new</span> IPRoute();
<a name="l00483"></a>00483                 defRoute-&gt;setHost(IPAddress::UNSPECIFIED_ADDRESS);
<a name="l00484"></a>00484                 defRoute-&gt;setNetmask(IPAddress::UNSPECIFIED_ADDRESS);
<a name="l00485"></a>00485                 defRoute-&gt;setGateway(IPAddress(next_hop_ip));
<a name="l00486"></a>00486                 defRoute-&gt;setInterface(ie);
<a name="l00487"></a>00487                 defRoute-&gt;setType(IPRoute::REMOTE);
<a name="l00488"></a>00488                 defRoute-&gt;setSource(IPRoute::MANUAL);
<a name="l00489"></a>00489 
<a name="l00490"></a>00490                 rt-&gt;addRoute(defRoute);
<a name="l00491"></a>00491             }
<a name="l00492"></a>00492         }
<a name="l00493"></a>00493     }
<a name="l00494"></a>00494 }
<a name="l00495"></a>00495 
<a name="l00496"></a><a class="code" href="classInetUnderlayConfigurator.html#ac37e6f6adee00d6dfbce628b3fc735f9">00496</a> <span class="keywordtype">void</span> <a class="code" href="classInetUnderlayConfigurator.html#ac37e6f6adee00d6dfbce628b3fc735f9">InetUnderlayConfigurator::setUpIPv6</a>(cTopology &amp;topo)
<a name="l00497"></a>00497 {
<a name="l00498"></a>00498     <span class="comment">// Assign IP addresses to all router modules.</span>
<a name="l00499"></a>00499     std::vector&lt;IPv6Words&gt; nodeAddresses;
<a name="l00500"></a>00500     nodeAddresses.resize(topo.getNumNodes());
<a name="l00501"></a>00501 
<a name="l00502"></a>00502     <span class="comment">// IP addresses for backbone</span>
<a name="l00503"></a>00503     <span class="comment">// Take start IP from config file</span>
<a name="l00504"></a>00504     <span class="comment">// FIXME: Make Netmask for Routers configurable!</span>
<a name="l00505"></a>00505     <a class="code" href="structIPv6Words.html" title="Structure to manipulate IPv6 addresses easily.">IPv6Words</a> lowIPBoundary(IPv6Address(par(<span class="stringliteral">&quot;startIPv6&quot;</span>).stringValue()));
<a name="l00506"></a>00506 
<a name="l00507"></a>00507     <span class="comment">// uint32 lowIPBoundary = uint32((1 &lt;&lt; 24) + 1);</span>
<a name="l00508"></a>00508     <span class="keywordtype">int</span> numIPNodes = 0;
<a name="l00509"></a>00509 
<a name="l00510"></a>00510     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; topo.getNumNodes(); i++) {
<a name="l00511"></a>00511         ++numIPNodes;
<a name="l00512"></a>00512 
<a name="l00513"></a>00513         <a class="code" href="structIPv6Words.html" title="Structure to manipulate IPv6 addresses easily.">IPv6Words</a> addr = lowIPBoundary;
<a name="l00514"></a>00514         addr.<a class="code" href="structIPv6Words.html#a02ec1eedad12fdb90a2632a32616aee1">d0</a> += numIPNodes;
<a name="l00515"></a>00515         nodeAddresses[i] = addr;
<a name="l00516"></a>00516 
<a name="l00517"></a>00517         <span class="comment">// update ip display string</span>
<a name="l00518"></a>00518         <span class="keywordflow">if</span> (ev.isGUI()) {
<a name="l00519"></a>00519             topo.getNode(i)-&gt;getModule()-&gt;getDisplayString().insertTag(<span class="stringliteral">&quot;t&quot;</span>, 0);
<a name="l00520"></a>00520             topo.getNode(i)-&gt;getModule()-&gt;getDisplayString().setTagArg(<span class="stringliteral">&quot;t&quot;</span>, 0,
<a name="l00521"></a>00521                                     const_cast&lt;char*&gt;(IPv6Address(addr.<a class="code" href="structIPv6Words.html#a02ec1eedad12fdb90a2632a32616aee1">d0</a>, addr.<a class="code" href="structIPv6Words.html#aec4a2eb8a6be8e6a216e56e2d0a150eb">d1</a>, addr.<a class="code" href="structIPv6Words.html#a8048b4119ed9147a7f38efa7f8038cf3">d2</a>, addr.<a class="code" href="structIPv6Words.html#ad5a73f32f7caaa24ea432f81d38b04ab">d3</a>).str().c_str()));
<a name="l00522"></a>00522             topo.getNode(i)-&gt;getModule()-&gt;getDisplayString().setTagArg(<span class="stringliteral">&quot;t&quot;</span>, 1, <span class="stringliteral">&quot;l&quot;</span>);
<a name="l00523"></a>00523             topo.getNode(i)-&gt;getModule()-&gt;getDisplayString().setTagArg(<span class="stringliteral">&quot;t&quot;</span>, 2, <span class="stringliteral">&quot;red&quot;</span>);
<a name="l00524"></a>00524         }
<a name="l00525"></a>00525 
<a name="l00526"></a>00526         <span class="comment">// find interface table and assign address to all (non-loopback) interfaces</span>
<a name="l00527"></a>00527         IInterfaceTable* ift = IPAddressResolver().interfaceTableOf(topo.getNode(i)-&gt;getModule());
<a name="l00528"></a>00528 
<a name="l00529"></a>00529         <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> k = 0; k &lt; ift-&gt;getNumInterfaces(); k++ ) {
<a name="l00530"></a>00530             InterfaceEntry* ie = ift-&gt;getInterface(k);
<a name="l00531"></a>00531             <span class="keywordflow">if</span> (!ie-&gt;isLoopback() &amp;&amp; ie-&gt;ipv6Data()) {
<a name="l00532"></a>00532                 <span class="comment">//ie-&gt;ipv6Data()-&gt;assignAddress(IPv6Address(addr.d0, addr.d1, addr.d2, addr.d3), false, 0, 0);</span>
<a name="l00533"></a>00533                 <span class="comment">// full address must match for local delivery</span>
<a name="l00534"></a>00534                 IPv6Address prefix(addr.<a class="code" href="structIPv6Words.html#a02ec1eedad12fdb90a2632a32616aee1">d0</a>, addr.<a class="code" href="structIPv6Words.html#aec4a2eb8a6be8e6a216e56e2d0a150eb">d1</a>, addr.<a class="code" href="structIPv6Words.html#a8048b4119ed9147a7f38efa7f8038cf3">d2</a>, addr.<a class="code" href="structIPv6Words.html#ad5a73f32f7caaa24ea432f81d38b04ab">d3</a>);
<a name="l00535"></a>00535                 IPv6InterfaceData::AdvPrefix p;
<a name="l00536"></a>00536                 p.prefix = prefix;
<a name="l00537"></a>00537                 p.prefixLength = 32;
<a name="l00538"></a>00538                 p.advAutonomousFlag = <span class="keyword">true</span>;
<a name="l00539"></a>00539                 p.advPreferredLifetime = 0;
<a name="l00540"></a>00540                 p.advValidLifetime = 0;
<a name="l00541"></a>00541                 p.advOnLinkFlag = <span class="keyword">true</span>;
<a name="l00542"></a>00542                 ie-&gt;ipv6Data()-&gt;addAdvPrefix(p);
<a name="l00543"></a>00543                 ie-&gt;setMACAddress(MACAddress::generateAutoAddress());
<a name="l00544"></a>00544 
<a name="l00545"></a>00545                 ie-&gt;ipv6Data()-&gt;assignAddress(prefix,<span class="keyword">false</span>, 0, 0);
<a name="l00546"></a>00546 
<a name="l00547"></a>00547                 <span class="keywordflow">if</span> (ie-&gt;ipv6Data()-&gt;getLinkLocalAddress().isUnspecified()) {
<a name="l00548"></a>00548                     ie-&gt;ipv6Data()-&gt;assignAddress(IPv6Address::formLinkLocalAddress(ie-&gt;getInterfaceToken()),<span class="keyword">false</span>, 0, 0);
<a name="l00549"></a>00549                 }
<a name="l00550"></a>00550             }
<a name="l00551"></a>00551         }
<a name="l00552"></a>00552     }
<a name="l00553"></a>00553 
<a name="l00554"></a>00554     <span class="comment">// Fill in routing tables.</span>
<a name="l00555"></a>00555     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; topo.getNumNodes(); i++) {
<a name="l00556"></a>00556         cTopology::Node* destNode = topo.getNode(i);
<a name="l00557"></a>00557 
<a name="l00558"></a>00558         <span class="comment">// calculate shortest paths from everywhere towards destNode</span>
<a name="l00559"></a>00559         topo.calculateUnweightedSingleShortestPathsTo(destNode);
<a name="l00560"></a>00560 
<a name="l00561"></a>00561         <span class="comment">// add overlayAccessRouters and overlayBackboneRouters</span>
<a name="l00562"></a>00562         <span class="comment">// to the GlobalNodeList</span>
<a name="l00563"></a>00563         <span class="keywordflow">if</span> ((strcmp(destNode-&gt;getModule()-&gt;getName(), <span class="stringliteral">&quot;overlayBackboneRouter&quot;</span>) == 0) ||
<a name="l00564"></a>00564                 (strcmp(destNode-&gt;getModule()-&gt;getName(), <span class="stringliteral">&quot;overlayAccessRouter&quot;</span>) == 0)) {
<a name="l00565"></a>00565             <span class="comment">//add node to bootstrap oracle</span>
<a name="l00566"></a>00566             <a class="code" href="classPeerInfo.html" title="Base class for providing additional underlay specific information associated with a certain transport...">PeerInfo</a>* info = <span class="keyword">new</span> <a class="code" href="classPeerInfo.html" title="Base class for providing additional underlay specific information associated with a certain transport...">PeerInfo</a>(0, destNode-&gt;getModule()-&gt;getId(), NULL);
<a name="l00567"></a>00567             <a class="code" href="classUnderlayConfigurator.html#a18732aa18ca952e0f7973216692d7777" title="pointer to GlobalNodeList">globalNodeList</a>-&gt;<a class="code" href="classGlobalNodeList.html#a82a6c218304d734e2169e1c8fc5817ee" title="Adds new peers to the peer set.">addPeer</a>(IPvXAddress(IPv6Address(nodeAddresses[i].d0, nodeAddresses[i].d1, nodeAddresses[i].d2, nodeAddresses[i].d3)), info);
<a name="l00568"></a>00568         }
<a name="l00569"></a>00569 
<a name="l00570"></a>00570         <span class="comment">// add route (with host=destNode) to every routing table in the network</span>
<a name="l00571"></a>00571         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; topo.getNumNodes(); j++) {
<a name="l00572"></a>00572             <span class="comment">// continue if same node</span>
<a name="l00573"></a>00573             <span class="keywordflow">if</span> (i == j)
<a name="l00574"></a>00574                 <span class="keywordflow">continue</span>;
<a name="l00575"></a>00575 
<a name="l00576"></a>00576             <span class="comment">// cancel simulation if node is not connected with destination</span>
<a name="l00577"></a>00577             cTopology::Node* atNode = topo.getNode(j);
<a name="l00578"></a>00578 
<a name="l00579"></a>00579             <span class="keywordflow">if</span> (atNode-&gt;getNumPaths() == 0) {
<a name="l00580"></a>00580                 <a class="code" href="yang_8cc.html#adb989392f8aada21b0f7ec2f7a41dc00">error</a>((std::string(atNode-&gt;getModule()-&gt;getName()) + <span class="stringliteral">&quot;: Network is not entirely connected.&quot;</span>
<a name="l00581"></a>00581                         <span class="stringliteral">&quot;Please increase your value for the &quot;</span>
<a name="l00582"></a>00582                         <span class="stringliteral">&quot;connectivity parameter&quot;</span>).c_str());
<a name="l00583"></a>00583             }
<a name="l00584"></a>00584 
<a name="l00585"></a>00585             <span class="comment">//</span>
<a name="l00586"></a>00586             <span class="comment">// Add routes at the atNode.</span>
<a name="l00587"></a>00587             <span class="comment">//</span>
<a name="l00588"></a>00588 
<a name="l00589"></a>00589             <span class="comment">// find atNode&#39;s interface and routing table</span>
<a name="l00590"></a>00590             IInterfaceTable* ift = IPAddressResolver().interfaceTableOf(atNode-&gt;getModule());
<a name="l00591"></a>00591             RoutingTable6* rt = IPAddressResolver().routingTable6Of(atNode-&gt;getModule());
<a name="l00592"></a>00592 
<a name="l00593"></a>00593             <span class="comment">// find atNode&#39;s interface entry for the next hop node</span>
<a name="l00594"></a>00594             <span class="keywordtype">int</span> outputGateId = atNode-&gt;getPath(0)-&gt;getLocalGate()-&gt;getId();
<a name="l00595"></a>00595             InterfaceEntry *ie = ift-&gt;getInterfaceByNodeOutputGateId(outputGateId);
<a name="l00596"></a>00596 
<a name="l00597"></a>00597             <span class="comment">// find the next hop node on the path towards destNode</span>
<a name="l00598"></a>00598             cModule* next_hop = atNode-&gt;getPath(0)-&gt;getRemoteNode()-&gt;getModule();
<a name="l00599"></a>00599             <span class="keywordtype">int</span> destGateId = destNode-&gt;getLinkIn(0)-&gt;getLocalGateId();
<a name="l00600"></a>00600             IInterfaceTable* destIft = IPAddressResolver().interfaceTableOf(destNode-&gt;getModule());
<a name="l00601"></a>00601             <span class="keywordtype">int</span> remoteGateId = atNode-&gt;getPath(0)-&gt;getRemoteGateId();
<a name="l00602"></a>00602             IInterfaceTable* remoteIft = IPAddressResolver().interfaceTableOf(next_hop);
<a name="l00603"></a>00603             IPv6Address next_hop_ip = remoteIft-&gt;getInterfaceByNodeInputGateId(remoteGateId)-&gt;ipv6Data()-&gt;getLinkLocalAddress();
<a name="l00604"></a>00604             IPv6InterfaceData::AdvPrefix destPrefix = destIft-&gt;getInterfaceByNodeInputGateId(destGateId)-&gt;ipv6Data()-&gt;getAdvPrefix(0);
<a name="l00605"></a>00605 
<a name="l00606"></a>00606             <span class="comment">// create routing entry for next hop</span>
<a name="l00607"></a>00607             rt-&gt;addStaticRoute(destPrefix.prefix, destPrefix.prefixLength, ie-&gt;getInterfaceId(), next_hop_ip);
<a name="l00608"></a>00608 
<a name="l00609"></a>00609         }
<a name="l00610"></a>00610     }
<a name="l00611"></a>00611 }
<a name="l00612"></a>00612 
<a name="l00613"></a>00613 
<a name="l00623"></a><a class="code" href="InetUnderlayConfigurator_8h.html#ac3fb363481075d619448cf8ff6c5b681">00623</a> <span class="keywordtype">double</span> <a class="code" href="InetUnderlayConfigurator_8cc.html#ac3fb363481075d619448cf8ff6c5b681" title="Extended uniform() function.">uniform2</a>(<span class="keywordtype">double</span> start, <span class="keywordtype">double</span> end, <span class="keywordtype">double</span> index, <span class="keywordtype">double</span> new_calc)
<a name="l00624"></a>00624 {
<a name="l00625"></a>00625     <span class="keyword">static</span> std::vector&lt;double&gt; value;
<a name="l00626"></a>00626     <span class="keywordflow">if</span> ( (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)index &gt;= value.size() )
<a name="l00627"></a>00627         value.resize((<span class="keywordtype">int</span>)index + 1);
<a name="l00628"></a>00628     <span class="keywordflow">if</span> ( new_calc == 1 )
<a name="l00629"></a>00629         value[(int)index] = uniform(start, end);
<a name="l00630"></a>00630     <span class="keywordflow">return</span> value[(int)index];
<a name="l00631"></a>00631 };
<a name="l00632"></a>00632 
<a name="l00642"></a><a class="code" href="InetUnderlayConfigurator_8h.html#a4069a2b6fca9492d0400992d8cdd2c04">00642</a> <span class="keywordtype">double</span> <a class="code" href="InetUnderlayConfigurator_8cc.html#a4069a2b6fca9492d0400992d8cdd2c04" title="Extended intuniform() function.">intuniform2</a>(<span class="keywordtype">double</span> start, <span class="keywordtype">double</span> end, <span class="keywordtype">double</span> index, <span class="keywordtype">double</span> new_calc)
<a name="l00643"></a>00643 {
<a name="l00644"></a>00644     <span class="keyword">static</span> std::vector&lt;double&gt; value;
<a name="l00645"></a>00645     <span class="keywordflow">if</span> ( (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)index &gt;= value.size() )
<a name="l00646"></a>00646         value.resize((<span class="keywordtype">int</span>)index + 1);
<a name="l00647"></a>00647     <span class="keywordflow">if</span> ( new_calc == 1 )
<a name="l00648"></a>00648         value[(int)index] = (<span class="keywordtype">double</span>)intuniform((<span class="keywordtype">int</span>)start, (<span class="keywordtype">int</span>)end);
<a name="l00649"></a>00649     <span class="keywordflow">return</span> value[(int)index];
<a name="l00650"></a>00650 };
<a name="l00651"></a>00651 
<a name="l00652"></a>00652 <a class="code" href="InetUnderlayConfigurator_8cc.html#a7ef962ca48190143e5593d7976240f2d">Define_NED_Math_Function</a>(<a class="code" href="InetUnderlayConfigurator_8cc.html#ac3fb363481075d619448cf8ff6c5b681" title="Extended uniform() function.">uniform2</a>, 4);
<a name="l00653"></a>00653 <a class="code" href="InetUnderlayConfigurator_8cc.html#a7ef962ca48190143e5593d7976240f2d">Define_NED_Math_Function</a>(<a class="code" href="InetUnderlayConfigurator_8cc.html#a4069a2b6fca9492d0400992d8cdd2c04" title="Extended intuniform() function.">intuniform2</a>, 4);
</pre></div></div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="InetUnderlayConfigurator_8cc.html">InetUnderlayConfigurator.cc</a>      </li>

    <li class="footer">Generated on Thu Mar 6 2014 14:06:28 for OverSim by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.5.1 </li>
   </ul>
 </div>


</body>
</html>
