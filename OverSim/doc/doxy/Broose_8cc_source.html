<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OverSim: Broose.cc Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">OverSim
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('Broose_8cc.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Broose.cc</div>  </div>
</div>
<div class="contents">
<a href="Broose_8cc.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">//</span>
<a name="l00002"></a>00002 <span class="comment">// Copyright (C) 2007 Institut fuer Telematik, Universitaet Karlsruhe (TH)</span>
<a name="l00003"></a>00003 <span class="comment">//</span>
<a name="l00004"></a>00004 <span class="comment">// This program is free software; you can redistribute it and/or</span>
<a name="l00005"></a>00005 <span class="comment">// modify it under the terms of the GNU General Public License</span>
<a name="l00006"></a>00006 <span class="comment">// as published by the Free Software Foundation; either version 2</span>
<a name="l00007"></a>00007 <span class="comment">// of the License, or (at your option) any later version.</span>
<a name="l00008"></a>00008 <span class="comment">//</span>
<a name="l00009"></a>00009 <span class="comment">// This program is distributed in the hope that it will be useful,</span>
<a name="l00010"></a>00010 <span class="comment">// but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00011"></a>00011 <span class="comment">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00012"></a>00012 <span class="comment">// GNU General Public License for more details.</span>
<a name="l00013"></a>00013 <span class="comment">//</span>
<a name="l00014"></a>00014 <span class="comment">// You should have received a copy of the GNU General Public License</span>
<a name="l00015"></a>00015 <span class="comment">// along with this program; if not, write to the Free Software</span>
<a name="l00016"></a>00016 <span class="comment">// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.</span>
<a name="l00017"></a>00017 <span class="comment">//</span>
<a name="l00018"></a>00018 
<a name="l00024"></a>00024 <span class="preprocessor">#include &quot;<a class="code" href="Broose_8h.html">Broose.h</a>&quot;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;<a class="code" href="RpcMacros_8h.html" title="This file declares some macros for RPC implementation.">RpcMacros.h</a>&gt;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;<a class="code" href="GlobalStatistics_8h.html">GlobalStatistics.h</a>&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;IPAddressResolver.h&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;<a class="code" href="BootstrapList_8h.html">BootstrapList.h</a>&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;<a class="code" href="LookupListener_8h.html">LookupListener.h</a>&gt;</span>
<a name="l00030"></a>00030 
<a name="l00031"></a>00031 <span class="keyword">using namespace </span>std;
<a name="l00032"></a>00032 
<a name="l00033"></a>00033 <a class="code" href="ALMTest_8cc.html#a3b5014f410c7989e8bad4b467ecc94cd">Define_Module</a>(<a class="code" href="classBroose.html" title="Broose overlay module.">Broose</a>);
<a name="l00034"></a>00034 
<a name="l00035"></a><a class="code" href="classBrooseLookupListener.html">00035</a> <span class="keyword">class </span><a class="code" href="classBrooseLookupListener.html">BrooseLookupListener</a> : <span class="keyword">public</span> <a class="code" href="classLookupListener.html" title="This class declares an abstract lookup listener.">LookupListener</a>
<a name="l00036"></a>00036 {
<a name="l00037"></a>00037 <span class="keyword">private</span>:
<a name="l00038"></a><a class="code" href="classBrooseLookupListener.html#a5368aab1d810754eaa80d22be08e3ee7">00038</a>     <a class="code" href="classBroose.html" title="Broose overlay module.">Broose</a>* <a class="code" href="classBrooseLookupListener.html#a5368aab1d810754eaa80d22be08e3ee7">overlay</a>;
<a name="l00039"></a>00039 <span class="keyword">public</span>:
<a name="l00040"></a><a class="code" href="classBrooseLookupListener.html#ab2655dab334af24a378e56bf30a82acd">00040</a>     <a class="code" href="classBrooseLookupListener.html">BrooseLookupListener</a>(<a class="code" href="classBroose.html" title="Broose overlay module.">Broose</a>* overlay)
<a name="l00041"></a>00041     {
<a name="l00042"></a>00042         this-&gt;overlay = overlay;
<a name="l00043"></a>00043     }
<a name="l00044"></a>00044 
<a name="l00045"></a><a class="code" href="classBrooseLookupListener.html#a660df5312183541a9f8e36db3afad132">00045</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> lookupFinished(<a class="code" href="classAbstractLookup.html" title="This class declares an abstract iterative lookup.">AbstractLookup</a> *lookup)
<a name="l00046"></a>00046     {
<a name="l00047"></a>00047         <span class="keyword">delete</span> <span class="keyword">this</span>;
<a name="l00048"></a>00048     }
<a name="l00049"></a>00049 };
<a name="l00050"></a>00050 
<a name="l00051"></a><a class="code" href="classBroose.html#acfbf2b4f5696183209f9d0546e772821">00051</a> <a class="code" href="classBroose.html#acfbf2b4f5696183209f9d0546e772821">Broose::Broose</a>()
<a name="l00052"></a>00052 {
<a name="l00053"></a>00053     join_timer = NULL;
<a name="l00054"></a>00054     bucket_timer = NULL;
<a name="l00055"></a>00055     rBucket = NULL;
<a name="l00056"></a>00056     lBucket = NULL;
<a name="l00057"></a>00057     bBucket =  NULL;
<a name="l00058"></a>00058 }
<a name="l00059"></a><a class="code" href="classBroose.html#a3b0bca5bf25266faf0ffe7194f322805">00059</a> <a class="code" href="classBroose.html#a3b0bca5bf25266faf0ffe7194f322805">Broose::~Broose</a>()
<a name="l00060"></a>00060 {
<a name="l00061"></a>00061     <span class="comment">// delete timers</span>
<a name="l00062"></a>00062     cancelAndDelete(join_timer);
<a name="l00063"></a>00063     cancelAndDelete(bucket_timer);
<a name="l00064"></a>00064 }
<a name="l00065"></a>00065 
<a name="l00066"></a><a class="code" href="classBroose.html#a98565a4675febbe6e107e4c49dc58450">00066</a> <span class="keywordtype">void</span> <a class="code" href="classBroose.html#a98565a4675febbe6e107e4c49dc58450" title="Initializes derived-class-attributes.">Broose::initializeOverlay</a>(<span class="keywordtype">int</span> stage)
<a name="l00067"></a>00067 {
<a name="l00068"></a>00068     <span class="comment">// because of IPAddressResolver, we need to wait until interfaces</span>
<a name="l00069"></a>00069     <span class="comment">// are registered, address auto-assignment takes place etc.</span>
<a name="l00070"></a>00070     <span class="keywordflow">if</span> (stage != <a class="code" href="InitStages_8h.html#a42fde1aa1e14a1c45d29061d6e87e532a58e83c497c7c8495e9c592ff3148b6b9" title="first stage for overlay modules (Tier 0 / KBR)">MIN_STAGE_OVERLAY</a>)
<a name="l00071"></a>00071         <span class="keywordflow">return</span>;
<a name="l00072"></a>00072 
<a name="l00073"></a>00073     <span class="comment">// Broose provides KBR services</span>
<a name="l00074"></a>00074     kbr = <span class="keyword">true</span>;
<a name="l00075"></a>00075 
<a name="l00076"></a>00076     <span class="comment">// fetch some parameters</span>
<a name="l00077"></a>00077     bucketSize = par(<span class="stringliteral">&quot;bucketSize&quot;</span>); <span class="comment">// = k</span>
<a name="l00078"></a>00078     rBucketSize = par(<span class="stringliteral">&quot;rBucketSize&quot;</span>); <span class="comment">// = k&#39;</span>
<a name="l00079"></a>00079     joinDelay = par(<span class="stringliteral">&quot;joinDelay&quot;</span>);
<a name="l00080"></a>00080     shiftingBits = par(<span class="stringliteral">&quot;brooseShiftingBits&quot;</span>);
<a name="l00081"></a>00081     userDist = par(<span class="stringliteral">&quot;userDist&quot;</span>);
<a name="l00082"></a>00082     refreshTime = par(<span class="stringliteral">&quot;refreshTime&quot;</span>);
<a name="l00083"></a>00083     numberRetries = par(<span class="stringliteral">&quot;numberRetries&quot;</span>);
<a name="l00084"></a>00084     stab1 = par(<span class="stringliteral">&quot;stab1&quot;</span>);
<a name="l00085"></a>00085     stab2 = par(<span class="stringliteral">&quot;stab2&quot;</span>);
<a name="l00086"></a>00086 
<a name="l00087"></a>00087     <span class="comment">//statistics</span>
<a name="l00088"></a>00088     bucketCount = 0;
<a name="l00089"></a>00089     bucketBytesSent = 0;
<a name="l00090"></a>00090 
<a name="l00091"></a>00091     <span class="comment">//init local parameters</span>
<a name="l00092"></a>00092     chooseLookup = 0;
<a name="l00093"></a>00093     receivedJoinResponse = 0;
<a name="l00094"></a>00094     receivedBBucketLookup = 0;
<a name="l00095"></a>00095     numberBBucketLookup = 0;
<a name="l00096"></a>00096     receivedLBucketLookup = 0;
<a name="l00097"></a>00097     numberLBucketLookup = 0;
<a name="l00098"></a>00098     powShiftingBits = 1 &lt;&lt; shiftingBits;
<a name="l00099"></a>00099     keyLength = <a class="code" href="classOverlayKey.html#af855a4dfc0e5dc0d2afc6b87fa1d7426" title="Returns the length in number of bits.">OverlayKey::getLength</a>();
<a name="l00100"></a>00100     numFailedPackets = 0;
<a name="l00101"></a>00101     bucketRetries = 0;
<a name="l00102"></a>00102 
<a name="l00103"></a>00103     <span class="comment">// add some watches</span>
<a name="l00104"></a>00104     WATCH(receivedJoinResponse);
<a name="l00105"></a>00105     WATCH(receivedBBucketLookup);
<a name="l00106"></a>00106     WATCH(numberBBucketLookup);
<a name="l00107"></a>00107     WATCH(receivedLBucketLookup);
<a name="l00108"></a>00108     WATCH(numberLBucketLookup);
<a name="l00109"></a>00109     WATCH(state);
<a name="l00110"></a>00110 
<a name="l00111"></a>00111     <span class="comment">// get module pointers for all buckets</span>
<a name="l00112"></a>00112     rBucket = <span class="keyword">new</span> <a class="code" href="classBrooseBucket.html" title="Broose bucket module.">BrooseBucket</a>*[powShiftingBits];
<a name="l00113"></a>00113 
<a name="l00114"></a>00114     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; powShiftingBits; i++) {
<a name="l00115"></a>00115         rBucket[i] = check_and_cast&lt;<a class="code" href="classBrooseBucket.html" title="Broose bucket module.">BrooseBucket</a>*&gt;
<a name="l00116"></a>00116                      (getParentModule()-&gt;getSubmodule(<span class="stringliteral">&quot;rBucket&quot;</span>,i));
<a name="l00117"></a>00117         bucketVector.push_back(rBucket[i]);
<a name="l00118"></a>00118     }
<a name="l00119"></a>00119 
<a name="l00120"></a>00120     lBucket = check_and_cast&lt;<a class="code" href="classBrooseBucket.html" title="Broose bucket module.">BrooseBucket</a>*&gt;
<a name="l00121"></a>00121               (getParentModule()-&gt;getSubmodule(<span class="stringliteral">&quot;lBucket&quot;</span>));
<a name="l00122"></a>00122     bucketVector.push_back(lBucket);
<a name="l00123"></a>00123 
<a name="l00124"></a>00124     bBucket = check_and_cast&lt;<a class="code" href="classBrooseBucket.html" title="Broose bucket module.">BrooseBucket</a>*&gt;
<a name="l00125"></a>00125               (getParentModule()-&gt;getSubmodule(<span class="stringliteral">&quot;bBucket&quot;</span>));
<a name="l00126"></a>00126     bucketVector.push_back(bBucket);
<a name="l00127"></a>00127 
<a name="l00128"></a>00128     <span class="comment">// create join and bucket timer</span>
<a name="l00129"></a>00129     join_timer = <span class="keyword">new</span> cMessage(<span class="stringliteral">&quot;join_timer&quot;</span>);
<a name="l00130"></a>00130     bucket_timer = <span class="keyword">new</span> cMessage(<span class="stringliteral">&quot;bucket_timer&quot;</span>);
<a name="l00131"></a>00131 }
<a name="l00132"></a>00132 
<a name="l00133"></a><a class="code" href="classBroose.html#a6e8d0813889738a8c12c47cce18586e5">00133</a> <span class="keywordtype">void</span> <a class="code" href="classBroose.html#a6e8d0813889738a8c12c47cce18586e5" title="Join the overlay with a given nodeID in thisNode.key.">Broose::joinOverlay</a>()
<a name="l00134"></a>00134 {
<a name="l00135"></a>00135     changeState(INIT);
<a name="l00136"></a>00136 
<a name="l00137"></a>00137     <span class="comment">// if the bootstrap node is unspecified we are the only node in the network</span>
<a name="l00138"></a>00138     <span class="comment">// so we can skip the &quot;normal&quot; join protocol</span>
<a name="l00139"></a>00139     <span class="keywordflow">if</span> (bootstrapNode.isUnspecified()) {
<a name="l00140"></a>00140         changeState(READY);
<a name="l00141"></a>00141     }
<a name="l00142"></a>00142 }
<a name="l00143"></a>00143 
<a name="l00144"></a>00144 
<a name="l00145"></a><a class="code" href="classBroose.html#a14b5e34e7b68ef3dcd588ca67e477e51">00145</a> <span class="keywordtype">void</span> <a class="code" href="classBroose.html#a14b5e34e7b68ef3dcd588ca67e477e51" title="changes the node&#39;s state">Broose::changeState</a>(<span class="keywordtype">int</span> toState)
<a name="l00146"></a>00146 {
<a name="l00147"></a>00147     <span class="keywordflow">switch</span> (toState) {
<a name="l00148"></a>00148     <span class="keywordflow">case</span> INIT: {
<a name="l00149"></a>00149         state = INIT;
<a name="l00150"></a>00150 
<a name="l00151"></a>00151         <span class="comment">// find a new bootstrap node and enroll to the bootstrap list</span>
<a name="l00152"></a>00152         bootstrapNode = bootstrapList-&gt;getBootstrapNode();
<a name="l00153"></a>00153 
<a name="l00154"></a>00154         cancelEvent(join_timer);
<a name="l00155"></a>00155         scheduleAt(simTime(), join_timer);
<a name="l00156"></a>00156 
<a name="l00157"></a>00157         <span class="comment">// initialize respectively clear the buckets</span>
<a name="l00158"></a>00158         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; powShiftingBits; i++) {
<a name="l00159"></a>00159             rBucket[i]-&gt;initializeBucket(shiftingBits, i, rBucketSize, <span class="keyword">this</span>);
<a name="l00160"></a>00160         }
<a name="l00161"></a>00161 
<a name="l00162"></a>00162         lBucket-&gt;initializeBucket(-shiftingBits, 0, powShiftingBits*rBucketSize,
<a name="l00163"></a>00163                                   <span class="keyword">this</span>);
<a name="l00164"></a>00164         bBucket-&gt;initializeBucket(0, 0, 7*bucketSize, <span class="keyword">this</span>, <span class="keyword">true</span>);
<a name="l00165"></a>00165 
<a name="l00166"></a>00166         <span class="comment">// if we have restarted the join protocol reset parameters</span>
<a name="l00167"></a>00167         receivedBBucketLookup = 0;
<a name="l00168"></a>00168         receivedLBucketLookup = 0;
<a name="l00169"></a>00169         receivedJoinResponse = 0;
<a name="l00170"></a>00170 
<a name="l00171"></a>00171         getParentModule()-&gt;getParentModule()-&gt;bubble(<span class="stringliteral">&quot;Enter INIT state.&quot;</span>);
<a name="l00172"></a>00172         updateTooltip();
<a name="l00173"></a>00173         <span class="keywordflow">break</span>;
<a name="l00174"></a>00174     }
<a name="l00175"></a>00175 
<a name="l00176"></a>00176     <span class="keywordflow">case</span> RSET: {
<a name="l00177"></a>00177         state = RSET;
<a name="l00178"></a>00178 
<a name="l00179"></a>00179         <a class="code" href="classBrooseBucket.html" title="Broose bucket module.">BrooseBucket</a>* tmpBucket = <span class="keyword">new</span> <a class="code" href="classBrooseBucket.html" title="Broose bucket module.">BrooseBucket</a>();
<a name="l00180"></a>00180         tmpBucket-&gt;<a class="code" href="classBrooseBucket.html#ac54c82db0009034bcbf028c86ae8045a" title="initializes a bucket">initializeBucket</a>(0, 0, powShiftingBits*rBucketSize, <span class="keyword">this</span>);
<a name="l00181"></a>00181 
<a name="l00182"></a>00182         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; powShiftingBits; i++) {
<a name="l00183"></a>00183             <span class="keywordtype">int</span> size = rBucket[i]-&gt;getSize();
<a name="l00184"></a>00184 
<a name="l00185"></a>00185             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; size; j++) {
<a name="l00186"></a>00186                 tmpBucket-&gt;<a class="code" href="classBrooseBucket.html#ab3f7ae9d8575f049bc3ce6f501177f0c" title="adds a broose node handle to the bucket">add</a>(rBucket[i]-&gt;<span class="keyword">get</span>(j));
<a name="l00187"></a>00187             }
<a name="l00188"></a>00188         }
<a name="l00189"></a>00189 
<a name="l00190"></a>00190         <a class="code" href="classBucketCall.html" title="Class generated from overlay/broose/BrooseMessage.msg by opp_msgc.">BucketCall</a>** bCall = <span class="keyword">new</span> <a class="code" href="classBucketCall.html" title="Class generated from overlay/broose/BrooseMessage.msg by opp_msgc.">BucketCall</a>*[tmpBucket-&gt;<a class="code" href="classBrooseBucket.html#a7ef01cbcf70e7e8621793c8e94fa5198" title="returns number of current entries">getSize</a>()];
<a name="l00191"></a>00191         <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; tmpBucket-&gt;<a class="code" href="classBrooseBucket.html#a7ef01cbcf70e7e8621793c8e94fa5198" title="returns number of current entries">getSize</a>(); i++) {
<a name="l00192"></a>00192             bCall[i] = <span class="keyword">new</span> <a class="code" href="classBucketCall.html" title="Class generated from overlay/broose/BrooseMessage.msg by opp_msgc.">BucketCall</a>(<span class="stringliteral">&quot;LBucketCall&quot;</span>);
<a name="l00193"></a>00193             bCall[i]-&gt;<a class="code" href="classBucketCall.html#ab04b51e392e17924454bb4e5a1f9368a">setBucketType</a>(<a class="code" href="BrooseMessage__m_8h.html#a0d72090ca3225dfb0af1767bf6390a40adb45120aafd37a973140edee24708065">LEFT</a>);
<a name="l00194"></a>00194             bCall[i]-&gt;<a class="code" href="classBucketCall.html#ab2256565d62dea3e984dee2c51bfa7f1">setProState</a>(<a class="code" href="BrooseMessage__m_8h.html#a1e4df1e60bb9501df7c024063484d127aa90bbfe38513a4fab312de105624e88e">PRSET</a>);
<a name="l00195"></a>00195             bCall[i]-&gt;setBitLength(<a class="code" href="BrooseMessage__m_8h.html#a828592e4207a671e7eb7011a5cce9bc1">BUCKETCALL_L</a>(bcall[i]));
<a name="l00196"></a>00196 
<a name="l00197"></a>00197             sendUdpRpcCall(tmpBucket-&gt;<a class="code" href="classBrooseBucket.html#a9031c9a358274b8192b454a27eb0845e" title="returns a specific broose handle">get</a>(i), bCall[i], NULL,
<a name="l00198"></a>00198                            10);
<a name="l00199"></a>00199         }
<a name="l00200"></a>00200 
<a name="l00201"></a>00201         <span class="comment">// half of the calls must return for a state change</span>
<a name="l00202"></a>00202         numberBBucketLookup = ceil((<span class="keywordtype">double</span>)tmpBucket-&gt;<a class="code" href="classBrooseBucket.html#a7ef01cbcf70e7e8621793c8e94fa5198" title="returns number of current entries">getSize</a>() / 2);
<a name="l00203"></a>00203 
<a name="l00204"></a>00204         <span class="keyword">delete</span> tmpBucket;
<a name="l00205"></a>00205 
<a name="l00206"></a>00206         getParentModule()-&gt;getParentModule()-&gt;bubble(<span class="stringliteral">&quot;Enter RSET state.&quot;</span>);
<a name="l00207"></a>00207         <span class="keywordflow">break</span>;
<a name="l00208"></a>00208     }
<a name="l00209"></a>00209 
<a name="l00210"></a>00210     <span class="keywordflow">case</span> BSET: {
<a name="l00211"></a>00211         state = BSET;
<a name="l00212"></a>00212 
<a name="l00213"></a>00213         <span class="comment">// half of the calls must return for a state change</span>
<a name="l00214"></a>00214         numberLBucketLookup = ceil((<span class="keywordtype">double</span>)bBucket-&gt;getSize() / 2);
<a name="l00215"></a>00215 
<a name="l00216"></a>00216         <span class="comment">// send messages to all entries of the B Bucket</span>
<a name="l00217"></a>00217         <span class="keywordtype">int</span> size2 = bBucket-&gt;<a class="code" href="classBrooseBucket.html#a7ef01cbcf70e7e8621793c8e94fa5198" title="returns number of current entries">getSize</a>();
<a name="l00218"></a>00218         <a class="code" href="classBucketCall.html" title="Class generated from overlay/broose/BrooseMessage.msg by opp_msgc.">BucketCall</a>** bCall2 = <span class="keyword">new</span> <a class="code" href="classBucketCall.html" title="Class generated from overlay/broose/BrooseMessage.msg by opp_msgc.">BucketCall</a>*[size2];
<a name="l00219"></a>00219         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; size2; i++) {
<a name="l00220"></a>00220             bCall2[i] = <span class="keyword">new</span> <a class="code" href="classBucketCall.html" title="Class generated from overlay/broose/BrooseMessage.msg by opp_msgc.">BucketCall</a>(<span class="stringliteral">&quot;LBucketCall&quot;</span>);
<a name="l00221"></a>00221             bCall2[i]-&gt;<a class="code" href="classBucketCall.html#ab04b51e392e17924454bb4e5a1f9368a">setBucketType</a>(<a class="code" href="BrooseMessage__m_8h.html#a0d72090ca3225dfb0af1767bf6390a40adb45120aafd37a973140edee24708065">LEFT</a>);
<a name="l00222"></a>00222             bCall2[i]-&gt;<a class="code" href="classBucketCall.html#ab2256565d62dea3e984dee2c51bfa7f1">setProState</a>(<a class="code" href="BrooseMessage__m_8h.html#a1e4df1e60bb9501df7c024063484d127a59443e9ea684a77445f11ef9ebccebbd">PBSET</a>);
<a name="l00223"></a>00223             bCall2[i]-&gt;setBitLength(<a class="code" href="BrooseMessage__m_8h.html#a828592e4207a671e7eb7011a5cce9bc1">BUCKETCALL_L</a>(bcall2[i]));
<a name="l00224"></a>00224 
<a name="l00225"></a>00225             sendUdpRpcCall(bBucket-&gt;get(i), bCall2[i], NULL,
<a name="l00226"></a>00226                            10);
<a name="l00227"></a>00227         }
<a name="l00228"></a>00228 
<a name="l00229"></a>00229         getParentModule()-&gt;getParentModule()-&gt;bubble(<span class="stringliteral">&quot;Enter BSET state.&quot;</span>);
<a name="l00230"></a>00230         <span class="keywordflow">break</span>;
<a name="l00231"></a>00231     }
<a name="l00232"></a>00232 
<a name="l00233"></a>00233     <span class="keywordflow">case</span> READY: {
<a name="l00234"></a>00234         state = READY;
<a name="l00235"></a>00235 
<a name="l00236"></a>00236         <span class="comment">// fill the bucket also with this node</span>
<a name="l00237"></a>00237         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; bucketVector.size(); i++) {
<a name="l00238"></a>00238             bucketVector[i]-&gt;add(thisNode);
<a name="l00239"></a>00239         }
<a name="l00240"></a>00240 
<a name="l00241"></a>00241         <span class="comment">// to disable the ping protocol a pingDelay or</span>
<a name="l00242"></a>00242         <span class="comment">// refreshTime of zero was given</span>
<a name="l00243"></a>00243         <span class="keywordflow">if</span> (refreshTime != 0) {
<a name="l00244"></a>00244             cancelEvent(bucket_timer);
<a name="l00245"></a>00245             scheduleAt(simTime() + (refreshTime / 2.0), bucket_timer);
<a name="l00246"></a>00246         }
<a name="l00247"></a>00247 
<a name="l00248"></a>00248         getParentModule()-&gt;getParentModule()-&gt;bubble(<span class="stringliteral">&quot;Enter READY state.&quot;</span>);
<a name="l00249"></a>00249 
<a name="l00250"></a>00250         updateTooltip();
<a name="l00251"></a>00251         <span class="keywordflow">break</span>;
<a name="l00252"></a>00252     }
<a name="l00253"></a>00253 
<a name="l00254"></a>00254     }
<a name="l00255"></a>00255     setOverlayReady(state == READY);
<a name="l00256"></a>00256 }
<a name="l00257"></a>00257 
<a name="l00258"></a><a class="code" href="classBroose.html#ac0e5eb20a2e995afeccc2b35a8e97967">00258</a> <span class="keywordtype">void</span> <a class="code" href="classBroose.html#ac0e5eb20a2e995afeccc2b35a8e97967">Broose::handleTimerEvent</a>(cMessage* msg)
<a name="l00259"></a>00259 {
<a name="l00260"></a>00260     <span class="keywordflow">if</span> (msg == join_timer)
<a name="l00261"></a>00261         handleJoinTimerExpired(msg);
<a name="l00262"></a>00262     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (msg == bucket_timer)
<a name="l00263"></a>00263         handleBucketTimerExpired(msg);
<a name="l00264"></a>00264     <span class="keywordflow">else</span>
<a name="l00265"></a>00265         <a class="code" href="yang_8cc.html#adb989392f8aada21b0f7ec2f7a41dc00">error</a>(<span class="stringliteral">&quot;Broose::handleTimerEvent - no other timer currently in use!&quot;</span>);
<a name="l00266"></a>00266 }
<a name="l00267"></a>00267 
<a name="l00268"></a><a class="code" href="classBroose.html#a2c835e754977b5781ca74d9da3470721">00268</a> <span class="keywordtype">void</span> <a class="code" href="classBroose.html#a2c835e754977b5781ca74d9da3470721" title="handles a expired join timer">Broose::handleJoinTimerExpired</a>(cMessage* msg)
<a name="l00269"></a>00269 {
<a name="l00270"></a>00270     <span class="keywordflow">if</span> (state == READY)
<a name="l00271"></a>00271         <span class="keywordflow">return</span>;
<a name="l00272"></a>00272 
<a name="l00273"></a>00273     <span class="keywordflow">if</span> (!bootstrapNode.isUnspecified()) {
<a name="l00274"></a>00274         <span class="comment">// create new lookup message</span>
<a name="l00275"></a>00275 <span class="preprocessor">#if 0</span>
<a name="l00276"></a>00276 <span class="preprocessor"></span>        <a class="code" href="classBucketCall.html" title="Class generated from overlay/broose/BrooseMessage.msg by opp_msgc.">BucketCall</a>* bCall = <span class="keyword">new</span> <a class="code" href="classBucketCall.html" title="Class generated from overlay/broose/BrooseMessage.msg by opp_msgc.">BucketCall</a>();
<a name="l00277"></a>00277         bCall-&gt;<a class="code" href="classBucketCall.html#ab04b51e392e17924454bb4e5a1f9368a">setBucketType</a>(<a class="code" href="BrooseMessage__m_8h.html#a0d72090ca3225dfb0af1767bf6390a40a0448a6480348702c480296969de6dca0">BROTHER</a>);
<a name="l00278"></a>00278         bCall-&gt;<a class="code" href="classBucketCall.html#ab2256565d62dea3e984dee2c51bfa7f1">setProState</a>(FAILED);
<a name="l00279"></a>00279         bCall-&gt;setBitLength(<a class="code" href="BrooseMessage__m_8h.html#a828592e4207a671e7eb7011a5cce9bc1">BUCKETCALL_L</a>(call));
<a name="l00280"></a>00280         sendRouteRpcCall(<a class="code" href="CommonMessages__m_8h.html#aad57ef0110fe8675eb299d467148bc5ead1b904580b02f8adaa1ab2de239c4c79">OVERLAY_COMP</a>, bootstrapNode, thisNode.getKey(),
<a name="l00281"></a>00281                          bCall);
<a name="l00282"></a>00282 
<a name="l00283"></a>00283         <a class="code" href="classBucketCall.html" title="Class generated from overlay/broose/BrooseMessage.msg by opp_msgc.">BucketCall</a>* lCall = <span class="keyword">new</span> <a class="code" href="classBucketCall.html" title="Class generated from overlay/broose/BrooseMessage.msg by opp_msgc.">BucketCall</a>();
<a name="l00284"></a>00284         lCall-&gt;setBucketType(<a class="code" href="BrooseMessage__m_8h.html#a0d72090ca3225dfb0af1767bf6390a40a0448a6480348702c480296969de6dca0">BROTHER</a>);
<a name="l00285"></a>00285         lCall-&gt;setProState(FAILED);
<a name="l00286"></a>00286         lCall-&gt;setBitLength(<a class="code" href="BrooseMessage__m_8h.html#a828592e4207a671e7eb7011a5cce9bc1">BUCKETCALL_L</a>(call));
<a name="l00287"></a>00287         sendRouteRpcCall(<a class="code" href="CommonMessages__m_8h.html#aad57ef0110fe8675eb299d467148bc5ead1b904580b02f8adaa1ab2de239c4c79">OVERLAY_COMP</a>, bootstrapNode,
<a name="l00288"></a>00288                          thisNode.getKey() &lt;&lt; shiftingBits, lCall);
<a name="l00289"></a>00289 <span class="preprocessor">#endif</span>
<a name="l00290"></a>00290 <span class="preprocessor"></span>        <span class="comment">// do lookups for key &gt;&gt; shiftingBits for each prefix</span>
<a name="l00291"></a>00291         <a class="code" href="classOverlayKey.html" title="A common overlay key class.">OverlayKey</a> newKey = thisNode.getKey() &gt;&gt; shiftingBits;
<a name="l00292"></a>00292         <a class="code" href="classBucketCall.html" title="Class generated from overlay/broose/BrooseMessage.msg by opp_msgc.">BucketCall</a>* bCallArray[powShiftingBits];
<a name="l00293"></a>00293         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; powShiftingBits; i++) {
<a name="l00294"></a>00294             <a class="code" href="classOverlayKey.html" title="A common overlay key class.">OverlayKey</a> add(i);
<a name="l00295"></a>00295             add = add &lt;&lt; (keyLength - shiftingBits);
<a name="l00296"></a>00296             add += newKey;
<a name="l00297"></a>00297 
<a name="l00298"></a>00298             bCallArray[i] = <span class="keyword">new</span> <a class="code" href="classBucketCall.html" title="Class generated from overlay/broose/BrooseMessage.msg by opp_msgc.">BucketCall</a>(<span class="stringliteral">&quot;BBucketCall&quot;</span>);
<a name="l00299"></a>00299             bCallArray[i]-&gt;<a class="code" href="classBucketCall.html#ab04b51e392e17924454bb4e5a1f9368a">setBucketType</a>(<a class="code" href="BrooseMessage__m_8h.html#a0d72090ca3225dfb0af1767bf6390a40a0448a6480348702c480296969de6dca0">BROTHER</a>);
<a name="l00300"></a>00300             bCallArray[i]-&gt;<a class="code" href="classBucketCall.html#a4995fef3fcda1932032d869b4b0882d6">setBucketIndex</a>(i);
<a name="l00301"></a>00301             bCallArray[i]-&gt;<a class="code" href="classBucketCall.html#ab2256565d62dea3e984dee2c51bfa7f1">setProState</a>(<a class="code" href="BrooseMessage__m_8h.html#a1e4df1e60bb9501df7c024063484d127a544019da4a7a9284830c20e6c4f5a5a8">PINIT</a>);
<a name="l00302"></a>00302             bCallArray[i]-&gt;setBitLength(<a class="code" href="BrooseMessage__m_8h.html#a828592e4207a671e7eb7011a5cce9bc1">BUCKETCALL_L</a>(bCallArray[i]));
<a name="l00303"></a>00303 
<a name="l00304"></a>00304             <span class="comment">// restart join protocol if one call times out</span>
<a name="l00305"></a>00305             <span class="comment">// otherwise the node might be isolated</span>
<a name="l00306"></a>00306             sendRouteRpcCall(<a class="code" href="CommonMessages__m_8h.html#aad57ef0110fe8675eb299d467148bc5ead1b904580b02f8adaa1ab2de239c4c79">OVERLAY_COMP</a>, bootstrapNode, add,
<a name="l00307"></a>00307                              bCallArray[i]);
<a name="l00308"></a>00308         }
<a name="l00309"></a>00309         <span class="comment">//createLookup()-&gt;lookup(getThisNode().getKey() + 1, 0, 0, 0,</span>
<a name="l00310"></a>00310         <span class="comment">//                       new BrooseLookupListener(this));</span>
<a name="l00311"></a>00311     } <span class="keywordflow">else</span> {
<a name="l00312"></a>00312         <span class="comment">// if the bootstrap node is unspecified we are the only node in the network</span>
<a name="l00313"></a>00313         <span class="comment">// so we can skip the &quot;normal&quot; join protocol</span>
<a name="l00314"></a>00314         changeState(READY);
<a name="l00315"></a>00315     }
<a name="l00316"></a>00316 }
<a name="l00317"></a>00317 
<a name="l00318"></a><a class="code" href="classBroose.html#a1077711ecf1d2da2cd87ab71766d2ade">00318</a> <span class="keywordtype">void</span> <a class="code" href="classBroose.html#a1077711ecf1d2da2cd87ab71766d2ade" title="handles a expired bucket refresh timer">Broose::handleBucketTimerExpired</a>(cMessage* msg)
<a name="l00319"></a>00319 {
<a name="l00320"></a>00320     <a class="code" href="classBrooseBucket.html" title="Broose bucket module.">BrooseBucket</a>* tmpBucket = <span class="keyword">new</span> <a class="code" href="classBrooseBucket.html" title="Broose bucket module.">BrooseBucket</a>();
<a name="l00321"></a>00321     tmpBucket-&gt;<a class="code" href="classBrooseBucket.html#ac54c82db0009034bcbf028c86ae8045a" title="initializes a bucket">initializeBucket</a>(0, 0,
<a name="l00322"></a>00322                                 (2*powShiftingBits*rBucketSize + 7*bucketSize),
<a name="l00323"></a>00323                                 <span class="keyword">this</span>);
<a name="l00324"></a>00324 
<a name="l00325"></a>00325     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; bucketVector.size(); i++) {
<a name="l00326"></a>00326         <span class="keywordflow">for</span>(uint32_t j = 0; j &lt; bucketVector[i]-&gt;getSize(); j++) {
<a name="l00327"></a>00327             <span class="keywordflow">if</span> ((simTime() - bucketVector[i]-&gt;getLastSeen(
<a name="l00328"></a>00328                         bucketVector[i]-&gt;<span class="keyword">get</span>(j))) &gt; refreshTime
<a name="l00329"></a>00329                     || bucketVector[i]-&gt;getRTT(bucketVector[i]-&gt;<span class="keyword">get</span>(j)) == -1) {
<a name="l00330"></a>00330 
<a name="l00331"></a>00331                 tmpBucket-&gt;<a class="code" href="classBrooseBucket.html#ab3f7ae9d8575f049bc3ce6f501177f0c" title="adds a broose node handle to the bucket">add</a>(<a class="code" href="classBrooseHandle.html">BrooseHandle</a>(bucketVector[i]-&gt;<span class="keyword">get</span>(j)));
<a name="l00332"></a>00332             }
<a name="l00333"></a>00333         }
<a name="l00334"></a>00334     }
<a name="l00335"></a>00335 
<a name="l00336"></a>00336     <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; tmpBucket-&gt;<a class="code" href="classBrooseBucket.html#a7ef01cbcf70e7e8621793c8e94fa5198" title="returns number of current entries">getSize</a>(); i++) {
<a name="l00337"></a>00337         pingNode(tmpBucket-&gt;<a class="code" href="classBrooseBucket.html#a9031c9a358274b8192b454a27eb0845e" title="returns a specific broose handle">get</a>(i));
<a name="l00338"></a>00338     }
<a name="l00339"></a>00339 
<a name="l00340"></a>00340     <span class="keyword">delete</span> tmpBucket;
<a name="l00341"></a>00341 
<a name="l00342"></a>00342     scheduleAt(simTime() + (refreshTime / 2.0), bucket_timer);
<a name="l00343"></a>00343 }
<a name="l00344"></a>00344 
<a name="l00345"></a>00345 
<a name="l00346"></a><a class="code" href="classBroose.html#ade0172a588daa00efd1a0db945579047">00346</a> <span class="keywordtype">int</span> <a class="code" href="classBroose.html#ade0172a588daa00efd1a0db945579047" title="Query the maximum number of siblings (nodes close to a key) that are maintained by this overlay proto...">Broose::getMaxNumSiblings</a>()
<a name="l00347"></a>00347 {
<a name="l00348"></a>00348     <span class="keywordflow">return</span> bucketSize;
<a name="l00349"></a>00349 }
<a name="l00350"></a>00350 
<a name="l00351"></a><a class="code" href="classBroose.html#a510ec0b3d3378fc4ebb2a276cdff829b">00351</a> <span class="keywordtype">int</span> <a class="code" href="classBroose.html#a510ec0b3d3378fc4ebb2a276cdff829b" title="Query the maximum number of redundant next hop nodes that are returned by findNode().">Broose::getMaxNumRedundantNodes</a>()
<a name="l00352"></a>00352 {
<a name="l00353"></a>00353     <span class="keywordflow">return</span> bucketSize;
<a name="l00354"></a>00354 }
<a name="l00355"></a>00355 
<a name="l00356"></a><a class="code" href="classBroose.html#a2f8c758024a30b07ed271accebebd288">00356</a> <span class="keywordtype">int</span> <a class="code" href="classBroose.html#a2f8c758024a30b07ed271accebebd288" title="calculates the de-buijn distance between a key and a nodeId">Broose::getRoutingDistance</a>(<span class="keyword">const</span> <a class="code" href="classOverlayKey.html" title="A common overlay key class.">OverlayKey</a>&amp; key, <span class="keyword">const</span> <a class="code" href="classOverlayKey.html" title="A common overlay key class.">OverlayKey</a>&amp; node,
<a name="l00357"></a>00357                                <span class="keywordtype">int</span> dist)
<a name="l00358"></a>00358 {
<a name="l00359"></a>00359     <span class="keywordflow">for</span> (uint i = 0; i &lt; (uint)abs(dist); i++) {
<a name="l00360"></a>00360         <span class="keywordflow">if</span> (node.<a class="code" href="classOverlayKey.html#a0a44da45d3d52ce2ad76dad4e06a2888" title="Calculates the number of equal bits (digits) from the left with another Key (shared prefix length)...">sharedPrefixLength</a>(key &lt;&lt; i) &gt;= (abs(dist) - i)) {
<a name="l00361"></a>00361              <span class="keywordflow">return</span> i; <span class="comment">// right shifting</span>
<a name="l00362"></a>00362          }
<a name="l00363"></a>00363         <span class="keywordflow">if</span> (key.<a class="code" href="classOverlayKey.html#a0a44da45d3d52ce2ad76dad4e06a2888" title="Calculates the number of equal bits (digits) from the left with another Key (shared prefix length)...">sharedPrefixLength</a>(node &lt;&lt; i) &gt;= (abs(dist) - i)) {
<a name="l00364"></a>00364             <span class="keywordflow">return</span> -i; <span class="comment">// left shifting</span>
<a name="l00365"></a>00365         }
<a name="l00366"></a>00366     }
<a name="l00367"></a>00367 
<a name="l00368"></a>00368     <span class="keywordflow">if</span> (((chooseLookup++) % 2) == 0) {
<a name="l00369"></a>00369         <span class="keywordflow">return</span> -dist;
<a name="l00370"></a>00370     } <span class="keywordflow">else</span> {
<a name="l00371"></a>00371         <span class="keywordflow">return</span> dist;
<a name="l00372"></a>00372     }
<a name="l00373"></a>00373 }
<a name="l00374"></a>00374 
<a name="l00375"></a>00375 <span class="preprocessor">#if 0</span>
<a name="l00376"></a>00376 <span class="preprocessor"></span><span class="comment">// TODO: work in progress: new findNode() code which tries to calculate</span>
<a name="l00377"></a>00377 <span class="comment">//       the distance approximation and new routing key in each routing step</span>
<a name="l00378"></a>00378 <a class="code" href="classBaseKeySortedVector.html">NodeVector</a>* <a class="code" href="classBroose.html#a7af9754f05bb7e0e7a53a9334ada5784" title="Implements the find node call.">Broose::findNode</a>(<span class="keyword">const</span> <a class="code" href="classOverlayKey.html" title="A common overlay key class.">OverlayKey</a>&amp; key,
<a name="l00379"></a>00379                              <span class="keywordtype">int</span> numRedundantNodes,
<a name="l00380"></a>00380                              <span class="keywordtype">int</span> numSiblings,
<a name="l00381"></a>00381                              <a class="code" href="classBaseOverlayMessage.html" title="Class generated from common/CommonMessages.msg by opp_msgc.">BaseOverlayMessage</a>* msg)
<a name="l00382"></a>00382 {
<a name="l00383"></a>00383     <a class="code" href="classBrooseFindNodeExtMessage.html" title="Class generated from overlay/broose/BrooseMessage.msg by opp_msgc.">BrooseFindNodeExtMessage</a> *findNodeExt = NULL;
<a name="l00384"></a>00384     <span class="keywordtype">bool</span> err;
<a name="l00385"></a>00385     <span class="keywordtype">bool</span> isSibling = isSiblingFor(thisNode, key, numSiblings, &amp;err);
<a name="l00386"></a>00386     <span class="keywordtype">int</span> resultSize;
<a name="l00387"></a>00387 
<a name="l00388"></a>00388     <span class="keywordflow">if</span> (numSiblings &lt; 0) {
<a name="l00389"></a>00389         <span class="comment">// exhaustive iterative doesn&#39;t care about siblings</span>
<a name="l00390"></a>00390         resultSize = numRedundantNodes;
<a name="l00391"></a>00391     } <span class="keywordflow">else</span> {
<a name="l00392"></a>00392         resultSize = isSibling ? (numSiblings ? numSiblings : 1)
<a name="l00393"></a>00393                                                       : numRedundantNodes;
<a name="l00394"></a>00394     }
<a name="l00395"></a>00395     assert(numSiblings || numRedundantNodes);
<a name="l00396"></a>00396     <a class="code" href="classBaseKeySortedVector.html">NodeVector</a>* result = <span class="keyword">new</span> <a class="code" href="NodeVector_8h.html#a442f90b66b22aa9fca51f83c5ce1b02b">NodeVector</a>(resultSize);
<a name="l00397"></a>00397 
<a name="l00398"></a>00398     <span class="keywordflow">if</span> (isSibling) {
<a name="l00399"></a>00399         <span class="comment">//return the closest nodes</span>
<a name="l00400"></a>00400         <span class="comment">// sort with XOR distance to key</span>
<a name="l00401"></a>00401         <a class="code" href="classKeyDistanceComparator.html">KeyDistanceComparator&lt;KeyXorMetric&gt;</a>* comp =
<a name="l00402"></a>00402             <span class="keyword">new</span> <a class="code" href="classKeyDistanceComparator.html">KeyDistanceComparator&lt;KeyXorMetric&gt;</a>(key);
<a name="l00403"></a>00403         result-&gt;<a class="code" href="classBaseKeySortedVector.html#ac509494faf9fa46ca1d11964a21c8247">setComparator</a>(comp);
<a name="l00404"></a>00404 
<a name="l00405"></a>00405         bBucket-&gt;fillVector(result);
<a name="l00406"></a>00406         result-&gt;<a class="code" href="classBaseKeySortedVector.html#afbcdfbd9680a475cceb48ccc841140cd" title="adds an element of type T in increasing order to the NodeVector and returns the position of the added...">add</a>(thisNode);
<a name="l00407"></a>00407 
<a name="l00408"></a>00408         <span class="keyword">delete</span> comp;
<a name="l00409"></a>00409 
<a name="l00410"></a>00410 
<a name="l00411"></a>00411         std::cout &lt;&lt; <span class="stringliteral">&quot;key: &quot;</span> &lt;&lt; key.<a class="code" href="classOverlayKey.html#aabeb4fd284a630a82e982ba34ece4fd9" title="Returns a string representation of this key.">toString</a>(2).substr(0, 8)
<a name="l00412"></a>00412                   &lt;&lt; <span class="stringliteral">&quot; ThisNode: &quot;</span> &lt;&lt; thisNode.getKey().toString(2).substr(0, 8);
<a name="l00413"></a>00413         <span class="keywordflow">if</span> (result-&gt;size() &gt; 0) {
<a name="l00414"></a>00414             std::cout &lt;&lt; <span class="stringliteral">&quot; next hop (final): &quot;</span> &lt;&lt; (*result)[0].getKey().toString(2).substr(0, 8);
<a name="l00415"></a>00415         } <span class="keywordflow">else</span> {
<a name="l00416"></a>00416             std::cout &lt;&lt; <span class="stringliteral">&quot; no next hop! (final)&quot;</span>;
<a name="l00417"></a>00417         }
<a name="l00418"></a>00418         std::cout &lt;&lt; std::endl &lt;&lt; std::endl;
<a name="l00419"></a>00419 
<a name="l00420"></a>00420 
<a name="l00421"></a>00421         <span class="keywordflow">return</span> result;
<a name="l00422"></a>00422     }
<a name="l00423"></a>00423 
<a name="l00424"></a>00424     <span class="comment">// estimate distance</span>
<a name="l00425"></a>00425     <span class="keywordtype">int</span> dist = max(rBucket[0]-&gt;longestPrefix(),
<a name="l00426"></a>00426                    rBucket[1]-&gt;longestPrefix()) + 1 + userDist;
<a name="l00427"></a>00427 
<a name="l00428"></a>00428     <span class="keywordflow">if</span> ((dist % shiftingBits) != 0)
<a name="l00429"></a>00429         dist += (shiftingBits - (dist % shiftingBits));
<a name="l00430"></a>00430 
<a name="l00431"></a>00431     <span class="keywordflow">if</span> (dist &gt; keyLength) {
<a name="l00432"></a>00432         <span class="keywordflow">if</span> ((keyLength % shiftingBits) == 0) {
<a name="l00433"></a>00433             dist = keyLength;
<a name="l00434"></a>00434         } <span class="keywordflow">else</span> {
<a name="l00435"></a>00435             dist = (keyLength - keyLength % shiftingBits);
<a name="l00436"></a>00436         }
<a name="l00437"></a>00437     }
<a name="l00438"></a>00438 
<a name="l00439"></a>00439     <span class="keywordflow">if</span> (msg != NULL) {
<a name="l00440"></a>00440         <span class="keywordflow">if</span> (!msg-&gt;hasObject(<span class="stringliteral">&quot;findNodeExt&quot;</span>)) {
<a name="l00441"></a>00441             findNodeExt = <span class="keyword">new</span> <a class="code" href="classBrooseFindNodeExtMessage.html" title="Class generated from overlay/broose/BrooseMessage.msg by opp_msgc.">BrooseFindNodeExtMessage</a>(<span class="stringliteral">&quot;findNodeExt&quot;</span>);
<a name="l00442"></a>00442 
<a name="l00443"></a>00443             findNodeExt-&gt;<a class="code" href="classBrooseFindNodeExtMessage.html#a117959e63891126094e11bf9439cedaf">setMaxDistance</a>(dist);
<a name="l00444"></a>00444 
<a name="l00445"></a>00445             <span class="comment">//add contact for next Hop</span>
<a name="l00446"></a>00446             findNodeExt-&gt;<a class="code" href="classBrooseFindNodeExtMessage.html#a1045ab713622587d65f1f5b700f8983a">setLastNode</a>(thisNode);
<a name="l00447"></a>00447             findNodeExt-&gt;setBitLength(<a class="code" href="BrooseMessage__m_8h.html#a16ba8d8ad06fbd2154037234fa035de7">BROOSEFINDNODEEXTMESSAGE_L</a>);
<a name="l00448"></a>00448 
<a name="l00449"></a>00449             msg-&gt;addObject( findNodeExt );
<a name="l00450"></a>00450         }
<a name="l00451"></a>00451 
<a name="l00452"></a>00452         findNodeExt = (<a class="code" href="classBrooseFindNodeExtMessage.html" title="Class generated from overlay/broose/BrooseMessage.msg by opp_msgc.">BrooseFindNodeExtMessage</a>*) msg-&gt;getObject(<span class="stringliteral">&quot;findNodeExt&quot;</span>);
<a name="l00453"></a>00453     }
<a name="l00454"></a>00454 
<a name="l00455"></a>00455     <span class="comment">// update buckets with last hop</span>
<a name="l00456"></a>00456     routingAdd(findNodeExt-&gt;<a class="code" href="classBrooseFindNodeExtMessage.html#a4645c8c25ebba1bdf48fd9f2919720ff">getLastNode</a>(), <span class="keyword">true</span>);
<a name="l00457"></a>00457 
<a name="l00458"></a>00458     <span class="comment">// replace last hop contact information with</span>
<a name="l00459"></a>00459     <span class="comment">// this hop contact information</span>
<a name="l00460"></a>00460     findNodeExt-&gt;<a class="code" href="classBrooseFindNodeExtMessage.html#a1045ab713622587d65f1f5b700f8983a">setLastNode</a>(thisNode);
<a name="l00461"></a>00461 
<a name="l00462"></a>00462     <span class="comment">//findNodeExt-&gt;setMaxDistance(max(findNodeExt-&gt;getMaxDistance(), dist));</span>
<a name="l00463"></a>00463 
<a name="l00464"></a>00464     <span class="keywordtype">int</span> step = getRoutingDistance(key, thisNode.getKey(),
<a name="l00465"></a>00465                                   findNodeExt-&gt;<a class="code" href="classBrooseFindNodeExtMessage.html#ab5f1846b483894df0e36b581fd0df980">getMaxDistance</a>());
<a name="l00466"></a>00466 
<a name="l00467"></a>00467     <span class="keywordtype">bool</span> leftShifting;
<a name="l00468"></a>00468     <span class="keywordflow">if</span> (step &lt; 0) {
<a name="l00469"></a>00469         leftShifting = <span class="keyword">true</span>;
<a name="l00470"></a>00470         step *= -1;
<a name="l00471"></a>00471     }
<a name="l00472"></a>00472 
<a name="l00473"></a>00473     <span class="keywordflow">if</span> ((step % shiftingBits) != 0)
<a name="l00474"></a>00474         step += (shiftingBits - (step % shiftingBits));
<a name="l00475"></a>00475 
<a name="l00476"></a>00476     <span class="keywordflow">if</span> (step &gt; keyLength) {
<a name="l00477"></a>00477         <span class="keywordflow">if</span> ((keyLength % shiftingBits) == 0) {
<a name="l00478"></a>00478             step = keyLength;
<a name="l00479"></a>00479         } <span class="keywordflow">else</span> {
<a name="l00480"></a>00480             step = (keyLength - keyLength % shiftingBits);
<a name="l00481"></a>00481         }
<a name="l00482"></a>00482     }
<a name="l00483"></a>00483 
<a name="l00484"></a>00484     <span class="keywordflow">if</span> (leftShifting) {
<a name="l00485"></a>00485         step *= -1;
<a name="l00486"></a>00486     }
<a name="l00487"></a>00487 
<a name="l00488"></a>00488     <span class="comment">// check for messages which couldn&#39;t be routed</span>
<a name="l00489"></a>00489     <span class="keywordflow">if</span> (step == 0) {
<a name="l00490"></a>00490         <span class="comment">//return the closest nodes</span>
<a name="l00491"></a>00491         <span class="comment">// sort with XOR distance to key</span>
<a name="l00492"></a>00492         <a class="code" href="classKeyDistanceComparator.html">KeyDistanceComparator&lt;KeyXorMetric&gt;</a>* comp =
<a name="l00493"></a>00493             <span class="keyword">new</span> <a class="code" href="classKeyDistanceComparator.html">KeyDistanceComparator&lt;KeyXorMetric&gt;</a>(key);
<a name="l00494"></a>00494         result-&gt;<a class="code" href="classBaseKeySortedVector.html#ac509494faf9fa46ca1d11964a21c8247">setComparator</a>(comp);
<a name="l00495"></a>00495 
<a name="l00496"></a>00496         bBucket-&gt;fillVector(result);
<a name="l00497"></a>00497         result-&gt;<a class="code" href="classBaseKeySortedVector.html#afbcdfbd9680a475cceb48ccc841140cd" title="adds an element of type T in increasing order to the NodeVector and returns the position of the added...">add</a>(thisNode);
<a name="l00498"></a>00498 
<a name="l00499"></a>00499 
<a name="l00500"></a>00500         std::cout &lt;&lt; <span class="stringliteral">&quot;key: &quot;</span> &lt;&lt; key.<a class="code" href="classOverlayKey.html#aabeb4fd284a630a82e982ba34ece4fd9" title="Returns a string representation of this key.">toString</a>(2).substr(0, 8)
<a name="l00501"></a>00501                   &lt;&lt; <span class="stringliteral">&quot; dist: &quot;</span> &lt;&lt; step &lt;&lt; <span class="stringliteral">&quot; (max: &quot;</span> &lt;&lt; findNodeExt-&gt;<a class="code" href="classBrooseFindNodeExtMessage.html#ab5f1846b483894df0e36b581fd0df980">getMaxDistance</a>() &lt;&lt; <span class="stringliteral">&quot;)&quot;</span>
<a name="l00502"></a>00502                   &lt;&lt; <span class="stringliteral">&quot; rtkey: &quot;</span> &lt;&lt; thisNode.getKey().toString(2).substr(0, 8)
<a name="l00503"></a>00503                   &lt;&lt; <span class="stringliteral">&quot; ThisNode: &quot;</span> &lt;&lt; thisNode.getKey().toString(2).substr(0, 8);
<a name="l00504"></a>00504         <span class="keywordflow">if</span> (result-&gt;size() &gt; 0) {
<a name="l00505"></a>00505             std::cout &lt;&lt; <span class="stringliteral">&quot; next hop: &quot;</span> &lt;&lt; (*result)[0].getKey().toString(2).substr(0, 8);
<a name="l00506"></a>00506         } <span class="keywordflow">else</span> {
<a name="l00507"></a>00507             std::cout &lt;&lt; <span class="stringliteral">&quot; no next hop!&quot;</span>;
<a name="l00508"></a>00508         }
<a name="l00509"></a>00509         std::cout &lt;&lt; std::endl &lt;&lt; std::endl;
<a name="l00510"></a>00510 
<a name="l00511"></a>00511 
<a name="l00512"></a>00512         <span class="keyword">delete</span> comp;
<a name="l00513"></a>00513         <span class="keywordflow">return</span> result;
<a name="l00514"></a>00514     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (step &lt; 0) {
<a name="l00515"></a>00515         <span class="keywordflow">if</span> (state == BSET) {
<a name="l00516"></a>00516             <span class="keywordflow">return</span> result;
<a name="l00517"></a>00517         }
<a name="l00518"></a>00518         <span class="comment">// Left Shifting Lookup</span>
<a name="l00519"></a>00519         <a class="code" href="classOverlayKey.html" title="A common overlay key class.">OverlayKey</a> routingKey = key &gt;&gt; (-step - 1);
<a name="l00520"></a>00520         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; (-step - 1); i++) {
<a name="l00521"></a>00521             routingKey.<a class="code" href="classOverlayKey.html#a557441f4e89a3f5b90832ca8c1bfc46f" title="sets a bit of this-&gt;key">setBit</a>(<a class="code" href="classOverlayKey.html#af855a4dfc0e5dc0d2afc6b87fa1d7426" title="Returns the length in number of bits.">OverlayKey::getLength</a>() - i - 1,
<a name="l00522"></a>00522                               thisNode.getKey().getBit(
<a name="l00523"></a>00523                               <a class="code" href="classOverlayKey.html#af855a4dfc0e5dc0d2afc6b87fa1d7426" title="Returns the length in number of bits.">OverlayKey::getLength</a>() - i - 2));
<a name="l00524"></a>00524         }
<a name="l00525"></a>00525 
<a name="l00526"></a>00526         <a class="code" href="classKeyDistanceComparator.html">KeyDistanceComparator&lt;KeyXorMetric&gt;</a>* comp =
<a name="l00527"></a>00527             <span class="keyword">new</span> <a class="code" href="classKeyDistanceComparator.html">KeyDistanceComparator&lt;KeyXorMetric&gt;</a>(routingKey);
<a name="l00528"></a>00528 
<a name="l00529"></a>00529         result-&gt;<a class="code" href="classBaseKeySortedVector.html#ac509494faf9fa46ca1d11964a21c8247">setComparator</a>(comp);
<a name="l00530"></a>00530         lBucket-&gt;fillVector(result);
<a name="l00531"></a>00531         result-&gt;<a class="code" href="classBaseKeySortedVector.html#afbcdfbd9680a475cceb48ccc841140cd" title="adds an element of type T in increasing order to the NodeVector and returns the position of the added...">add</a>(thisNode);
<a name="l00532"></a>00532         <span class="keyword">delete</span> comp;
<a name="l00533"></a>00533 
<a name="l00534"></a>00534         std::cout &lt;&lt; <span class="stringliteral">&quot;key: &quot;</span> &lt;&lt; key.<a class="code" href="classOverlayKey.html#aabeb4fd284a630a82e982ba34ece4fd9" title="Returns a string representation of this key.">toString</a>(2).substr(0, 8)
<a name="l00535"></a>00535                   &lt;&lt; <span class="stringliteral">&quot; dist: &quot;</span> &lt;&lt; step &lt;&lt; <span class="stringliteral">&quot; (max: &quot;</span> &lt;&lt; findNodeExt-&gt;<a class="code" href="classBrooseFindNodeExtMessage.html#ab5f1846b483894df0e36b581fd0df980">getMaxDistance</a>() &lt;&lt; <span class="stringliteral">&quot;)&quot;</span>
<a name="l00536"></a>00536                   &lt;&lt; <span class="stringliteral">&quot; rtkey: &quot;</span> &lt;&lt; routingKey.<a class="code" href="classOverlayKey.html#aabeb4fd284a630a82e982ba34ece4fd9" title="Returns a string representation of this key.">toString</a>(2).substr(0, 8)
<a name="l00537"></a>00537                   &lt;&lt; <span class="stringliteral">&quot; ThisNode: &quot;</span> &lt;&lt; thisNode.getKey().toString(2).substr(0, 8);
<a name="l00538"></a>00538         <span class="keywordflow">if</span> (result-&gt;size() &gt; 0) {
<a name="l00539"></a>00539             std::cout &lt;&lt; <span class="stringliteral">&quot; next hop: &quot;</span> &lt;&lt; (*result)[0].getKey().toString(2).substr(0, 8);
<a name="l00540"></a>00540         } <span class="keywordflow">else</span> {
<a name="l00541"></a>00541             std::cout &lt;&lt; <span class="stringliteral">&quot; no next hop!&quot;</span>;
<a name="l00542"></a>00542         }
<a name="l00543"></a>00543         std::cout &lt;&lt; std::endl &lt;&lt; std::endl;
<a name="l00544"></a>00544 
<a name="l00545"></a>00545 
<a name="l00546"></a>00546     } <span class="keywordflow">else</span> {
<a name="l00547"></a>00547         <span class="comment">// Right Shifting Lookup</span>
<a name="l00548"></a>00548         <a class="code" href="classKeyDistanceComparator.html">KeyDistanceComparator&lt;KeyXorMetric&gt;</a>* comp = NULL;
<a name="l00549"></a>00549             comp = <span class="keyword">new</span> <a class="code" href="classKeyDistanceComparator.html">KeyDistanceComparator&lt;KeyXorMetric&gt;</a>(key &lt;&lt; (step - shiftingBits));
<a name="l00550"></a>00550 
<a name="l00551"></a>00551         result-&gt;<a class="code" href="classBaseKeySortedVector.html#ac509494faf9fa46ca1d11964a21c8247">setComparator</a>(comp);
<a name="l00552"></a>00552         rBucket[key.<a class="code" href="classOverlayKey.html#a25b2a67642f29fe2035a0abf74de3dd1" title="Returns a sub integer at position p with n-bits.">getBitRange</a>(key.<a class="code" href="classOverlayKey.html#af855a4dfc0e5dc0d2afc6b87fa1d7426" title="Returns the length in number of bits.">getLength</a>() - step - 1,
<a name="l00553"></a>00553                                 shiftingBits)]-&gt;fillVector(result);
<a name="l00554"></a>00554         result-&gt;<a class="code" href="classBaseKeySortedVector.html#afbcdfbd9680a475cceb48ccc841140cd" title="adds an element of type T in increasing order to the NodeVector and returns the position of the added...">add</a>(thisNode);
<a name="l00555"></a>00555         <span class="keyword">delete</span> comp;
<a name="l00556"></a>00556 
<a name="l00557"></a>00557         std::cout &lt;&lt; <span class="stringliteral">&quot;key: &quot;</span> &lt;&lt; key.<a class="code" href="classOverlayKey.html#aabeb4fd284a630a82e982ba34ece4fd9" title="Returns a string representation of this key.">toString</a>(2).substr(0, 8)
<a name="l00558"></a>00558                   &lt;&lt; <span class="stringliteral">&quot; dist: &quot;</span> &lt;&lt; step &lt;&lt; <span class="stringliteral">&quot; (max: &quot;</span> &lt;&lt; findNodeExt-&gt;<a class="code" href="classBrooseFindNodeExtMessage.html#ab5f1846b483894df0e36b581fd0df980">getMaxDistance</a>() &lt;&lt; <span class="stringliteral">&quot;)&quot;</span>
<a name="l00559"></a>00559                   &lt;&lt; <span class="stringliteral">&quot; rtkey: &quot;</span> &lt;&lt; (key &gt;&gt; step).toString(2).substr(0, 8)
<a name="l00560"></a>00560                   &lt;&lt; <span class="stringliteral">&quot; ThisNode: &quot;</span> &lt;&lt; thisNode.getKey().toString(2).substr(0, 8);
<a name="l00561"></a>00561         <span class="keywordflow">if</span> (result-&gt;size() &gt; 0) {
<a name="l00562"></a>00562             std::cout &lt;&lt; <span class="stringliteral">&quot; next hop: &quot;</span> &lt;&lt; (*result)[0].getKey().toString(2).substr(0, 8);
<a name="l00563"></a>00563         } <span class="keywordflow">else</span> {
<a name="l00564"></a>00564             std::cout &lt;&lt; <span class="stringliteral">&quot; no next hop!&quot;</span>;
<a name="l00565"></a>00565         }
<a name="l00566"></a>00566         std::cout &lt;&lt; std::endl &lt;&lt; std::endl;
<a name="l00567"></a>00567 
<a name="l00568"></a>00568     }
<a name="l00569"></a>00569 
<a name="l00570"></a>00570     <span class="keywordflow">return</span> result;
<a name="l00571"></a>00571 }
<a name="l00572"></a>00572 <span class="preprocessor">#endif</span>
<a name="l00573"></a>00573 <span class="preprocessor"></span>
<a name="l00574"></a><a class="code" href="classBroose.html#a7af9754f05bb7e0e7a53a9334ada5784">00574</a> <a class="code" href="classBaseKeySortedVector.html">NodeVector</a>* <a class="code" href="classBroose.html#a7af9754f05bb7e0e7a53a9334ada5784" title="Implements the find node call.">Broose::findNode</a>(<span class="keyword">const</span> <a class="code" href="classOverlayKey.html" title="A common overlay key class.">OverlayKey</a>&amp; key,
<a name="l00575"></a>00575                              <span class="keywordtype">int</span> numRedundantNodes,
<a name="l00576"></a>00576                              <span class="keywordtype">int</span> numSiblings,
<a name="l00577"></a>00577                              <a class="code" href="classBaseOverlayMessage.html" title="Class generated from common/CommonMessages.msg by opp_msgc.">BaseOverlayMessage</a>* msg)
<a name="l00578"></a>00578 {
<a name="l00579"></a>00579     <span class="keywordflow">if</span> ((state == INIT) || (state == RSET) || (state == FAILED))
<a name="l00580"></a>00580         <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="NodeVector_8h.html#a442f90b66b22aa9fca51f83c5ce1b02b">NodeVector</a>();
<a name="l00581"></a>00581 
<a name="l00582"></a>00582     <a class="code" href="classBrooseFindNodeExtMessage.html" title="Class generated from overlay/broose/BrooseMessage.msg by opp_msgc.">BrooseFindNodeExtMessage</a> *findNodeExt = NULL;
<a name="l00583"></a>00583     <span class="keywordtype">bool</span> err;
<a name="l00584"></a>00584     <span class="keywordtype">bool</span> isSibling = isSiblingFor(thisNode, key, numSiblings, &amp;err);
<a name="l00585"></a>00585     <span class="keywordtype">int</span> resultSize;
<a name="l00586"></a>00586 
<a name="l00587"></a>00587     <span class="keywordflow">if</span> (numSiblings &lt; 0) {
<a name="l00588"></a>00588         <span class="comment">// exhaustive iterative doesn&#39;t care about siblings</span>
<a name="l00589"></a>00589         resultSize = numRedundantNodes;
<a name="l00590"></a>00590     } <span class="keywordflow">else</span> {
<a name="l00591"></a>00591         resultSize = isSibling ? (numSiblings ? numSiblings : 1)
<a name="l00592"></a>00592                                                       : numRedundantNodes;
<a name="l00593"></a>00593     }
<a name="l00594"></a>00594     assert(numSiblings || numRedundantNodes);
<a name="l00595"></a>00595     <a class="code" href="classBaseKeySortedVector.html">NodeVector</a>* result = <span class="keyword">new</span> <a class="code" href="NodeVector_8h.html#a442f90b66b22aa9fca51f83c5ce1b02b">NodeVector</a>(resultSize);
<a name="l00596"></a>00596 
<a name="l00597"></a>00597     <span class="keywordflow">if</span> (isSibling) {
<a name="l00598"></a>00598         <span class="comment">//return the closest nodes</span>
<a name="l00599"></a>00599         <span class="comment">// sort with XOR distance to key</span>
<a name="l00600"></a>00600         <a class="code" href="classKeyDistanceComparator.html">KeyDistanceComparator&lt;KeyXorMetric&gt;</a>* comp =
<a name="l00601"></a>00601             <span class="keyword">new</span> <a class="code" href="classKeyDistanceComparator.html">KeyDistanceComparator&lt;KeyXorMetric&gt;</a>(key);
<a name="l00602"></a>00602         result-&gt;<a class="code" href="classBaseKeySortedVector.html#ac509494faf9fa46ca1d11964a21c8247">setComparator</a>(comp);
<a name="l00603"></a>00603 
<a name="l00604"></a>00604         bBucket-&gt;fillVector(result);
<a name="l00605"></a>00605         result-&gt;<a class="code" href="classBaseKeySortedVector.html#afbcdfbd9680a475cceb48ccc841140cd" title="adds an element of type T in increasing order to the NodeVector and returns the position of the added...">add</a>(thisNode);
<a name="l00606"></a>00606 
<a name="l00607"></a>00607         <span class="keyword">delete</span> comp;
<a name="l00608"></a>00608 
<a name="l00609"></a>00609         <span class="comment">/*</span>
<a name="l00610"></a>00610 <span class="comment">        std::cout &lt;&lt; &quot;key: &quot; &lt;&lt; key.toString(2).substr(0, 8)</span>
<a name="l00611"></a>00611 <span class="comment">                  &lt;&lt; &quot; ThisNode: &quot; &lt;&lt; thisNode.getKey().toString(2).substr(0, 8);</span>
<a name="l00612"></a>00612 <span class="comment">        if (result-&gt;size() &gt; 0) {</span>
<a name="l00613"></a>00613 <span class="comment">            std::cout &lt;&lt; &quot; next hop (final): &quot; &lt;&lt; (*result)[0].getKey().toString(2).substr(0, 8);</span>
<a name="l00614"></a>00614 <span class="comment">        } else {</span>
<a name="l00615"></a>00615 <span class="comment">            std::cout &lt;&lt; &quot; no next hop! (final)&quot;;</span>
<a name="l00616"></a>00616 <span class="comment">        }</span>
<a name="l00617"></a>00617 <span class="comment">        std::cout &lt;&lt; std::endl &lt;&lt; std::endl;</span>
<a name="l00618"></a>00618 <span class="comment">        */</span>
<a name="l00619"></a>00619 
<a name="l00620"></a>00620         <span class="keywordflow">return</span> result;
<a name="l00621"></a>00621     }
<a name="l00622"></a>00622 
<a name="l00623"></a>00623     <span class="keywordflow">if</span> (msg != NULL) {
<a name="l00624"></a>00624         <span class="keywordflow">if</span> (!msg-&gt;hasObject(<span class="stringliteral">&quot;findNodeExt&quot;</span>)) {
<a name="l00625"></a>00625             findNodeExt = <span class="keyword">new</span> <a class="code" href="classBrooseFindNodeExtMessage.html" title="Class generated from overlay/broose/BrooseMessage.msg by opp_msgc.">BrooseFindNodeExtMessage</a>(<span class="stringliteral">&quot;findNodeExt&quot;</span>);
<a name="l00626"></a>00626 
<a name="l00627"></a>00627             <a class="code" href="classOverlayKey.html" title="A common overlay key class.">OverlayKey</a> routeKey = thisNode.getKey();
<a name="l00628"></a>00628             <span class="comment">// estimate distance</span>
<a name="l00629"></a>00629             <span class="keywordtype">int</span> dist = max(rBucket[0]-&gt;longestPrefix(),
<a name="l00630"></a>00630                            rBucket[1]-&gt;longestPrefix()) + 1 + userDist;
<a name="l00631"></a>00631 
<a name="l00632"></a>00632             <span class="keywordflow">if</span> ((dist % shiftingBits) != 0)
<a name="l00633"></a>00633                 dist += (shiftingBits - (dist % shiftingBits));
<a name="l00634"></a>00634 
<a name="l00635"></a>00635             <span class="keywordflow">if</span> (dist &gt; keyLength) {
<a name="l00636"></a>00636                 <span class="keywordflow">if</span> ((keyLength % shiftingBits) == 0) {
<a name="l00637"></a>00637                     dist = keyLength;
<a name="l00638"></a>00638                 } <span class="keywordflow">else</span> {
<a name="l00639"></a>00639                     dist = (keyLength - keyLength % shiftingBits);
<a name="l00640"></a>00640                 }
<a name="l00641"></a>00641             }
<a name="l00642"></a>00642 
<a name="l00643"></a>00643             <span class="keywordflow">if</span> ((chooseLookup++) % 2 == 0) {
<a name="l00644"></a>00644                 <span class="comment">// init left shifting lookup</span>
<a name="l00645"></a>00645                 findNodeExt-&gt;<a class="code" href="classBrooseFindNodeExtMessage.html#ac7b7626c4fe39706eed608b7473f72cc">setRightShifting</a>(<span class="keyword">false</span>);
<a name="l00646"></a>00646 
<a name="l00647"></a>00647                 <span class="keywordtype">int</span> prefix = 0;
<a name="l00648"></a>00648                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; dist; i++) {
<a name="l00649"></a>00649                     prefix += thisNode.getKey().getBit(thisNode.getKey().getLength() - i - 1) &lt;&lt; (dist - i - 1);
<a name="l00650"></a>00650                 }
<a name="l00651"></a>00651 
<a name="l00652"></a>00652                 <a class="code" href="classOverlayKey.html" title="A common overlay key class.">OverlayKey</a> pre(prefix);
<a name="l00653"></a>00653                 routeKey = key &gt;&gt; dist;
<a name="l00654"></a>00654                 routeKey += (pre &lt;&lt; key.<a class="code" href="classOverlayKey.html#af855a4dfc0e5dc0d2afc6b87fa1d7426" title="Returns the length in number of bits.">getLength</a>() - dist);
<a name="l00655"></a>00655 
<a name="l00656"></a>00656                 dist = -dist;
<a name="l00657"></a>00657             } <span class="keywordflow">else</span> {
<a name="l00658"></a>00658                 <span class="comment">// init right shifting lookup</span>
<a name="l00659"></a>00659                 findNodeExt-&gt;<a class="code" href="classBrooseFindNodeExtMessage.html#ac7b7626c4fe39706eed608b7473f72cc">setRightShifting</a>(<span class="keyword">true</span>);
<a name="l00660"></a>00660             }
<a name="l00661"></a>00661 
<a name="l00662"></a>00662             <span class="comment">//add contact for next Hop</span>
<a name="l00663"></a>00663             findNodeExt-&gt;<a class="code" href="classBrooseFindNodeExtMessage.html#a1045ab713622587d65f1f5b700f8983a">setLastNode</a>(thisNode);
<a name="l00664"></a>00664             findNodeExt-&gt;<a class="code" href="classBrooseFindNodeExtMessage.html#aae996c7e18f5f61f4e631b2a63a7a33b">setRouteKey</a>(routeKey);
<a name="l00665"></a>00665             findNodeExt-&gt;<a class="code" href="classBrooseFindNodeExtMessage.html#a32255169d451507c9a851813469d880b">setStep</a>(dist);
<a name="l00666"></a>00666             findNodeExt-&gt;setBitLength(<a class="code" href="BrooseMessage__m_8h.html#a16ba8d8ad06fbd2154037234fa035de7">BROOSEFINDNODEEXTMESSAGE_L</a>);
<a name="l00667"></a>00667 
<a name="l00668"></a>00668             msg-&gt;addObject( findNodeExt );
<a name="l00669"></a>00669         }
<a name="l00670"></a>00670 
<a name="l00671"></a>00671         findNodeExt = (<a class="code" href="classBrooseFindNodeExtMessage.html" title="Class generated from overlay/broose/BrooseMessage.msg by opp_msgc.">BrooseFindNodeExtMessage</a>*) msg-&gt;getObject(<span class="stringliteral">&quot;findNodeExt&quot;</span>);
<a name="l00672"></a>00672     }
<a name="l00673"></a>00673 
<a name="l00674"></a>00674     <span class="comment">// update buckets with last hop</span>
<a name="l00675"></a>00675     addNode(findNodeExt-&gt;<a class="code" href="classBrooseFindNodeExtMessage.html#a4645c8c25ebba1bdf48fd9f2919720ff">getLastNode</a>());
<a name="l00676"></a>00676     setLastSeen(findNodeExt-&gt;<a class="code" href="classBrooseFindNodeExtMessage.html#a4645c8c25ebba1bdf48fd9f2919720ff">getLastNode</a>());
<a name="l00677"></a>00677 
<a name="l00678"></a>00678     <span class="comment">// replace last hop contact information with</span>
<a name="l00679"></a>00679     <span class="comment">// this hop contact information</span>
<a name="l00680"></a>00680     findNodeExt-&gt;<a class="code" href="classBrooseFindNodeExtMessage.html#a1045ab713622587d65f1f5b700f8983a">setLastNode</a>(thisNode);
<a name="l00681"></a>00681 
<a name="l00682"></a>00682     <span class="comment">// brother lookup</span>
<a name="l00683"></a>00683     <span class="keywordflow">if</span> (findNodeExt-&gt;<a class="code" href="classBrooseFindNodeExtMessage.html#a3be6649aae39d09d4ee64f52b6d3cf2d">getStep</a>() == 0) {
<a name="l00684"></a>00684         <span class="comment">// return the closest nodes sorted by XOR distance to key</span>
<a name="l00685"></a>00685         <a class="code" href="classKeyDistanceComparator.html">KeyDistanceComparator&lt;KeyXorMetric&gt;</a>* comp =
<a name="l00686"></a>00686             <span class="keyword">new</span> <a class="code" href="classKeyDistanceComparator.html">KeyDistanceComparator&lt;KeyXorMetric&gt;</a>(key);
<a name="l00687"></a>00687         result-&gt;<a class="code" href="classBaseKeySortedVector.html#ac509494faf9fa46ca1d11964a21c8247">setComparator</a>(comp);
<a name="l00688"></a>00688 
<a name="l00689"></a>00689         bBucket-&gt;fillVector(result);
<a name="l00690"></a>00690         result-&gt;<a class="code" href="classBaseKeySortedVector.html#afbcdfbd9680a475cceb48ccc841140cd" title="adds an element of type T in increasing order to the NodeVector and returns the position of the added...">add</a>(thisNode);
<a name="l00691"></a>00691 
<a name="l00692"></a>00692         <span class="keyword">delete</span> comp;
<a name="l00693"></a>00693         <span class="keywordflow">return</span> result;
<a name="l00694"></a>00694     }
<a name="l00695"></a>00695 
<a name="l00696"></a>00696     <span class="keywordflow">if</span> (findNodeExt-&gt;<a class="code" href="classBrooseFindNodeExtMessage.html#ae7e0659698a926c65992d073a73004bb">getRightShifting</a>() == <span class="keyword">false</span>) {
<a name="l00697"></a>00697         <span class="comment">// Left Shifting Lookup</span>
<a name="l00698"></a>00698 
<a name="l00699"></a>00699         <span class="comment">// can&#39;t handle left shifting lookup in BSET-State</span>
<a name="l00700"></a>00700         <span class="keywordflow">if</span> (state == BSET)
<a name="l00701"></a>00701             <span class="keywordflow">return</span> result;
<a name="l00702"></a>00702 
<a name="l00703"></a>00703         <span class="comment">// calculate routing key</span>
<a name="l00704"></a>00704         findNodeExt-&gt;<a class="code" href="classBrooseFindNodeExtMessage.html#aae996c7e18f5f61f4e631b2a63a7a33b">setRouteKey</a>((findNodeExt-&gt;<a class="code" href="classBrooseFindNodeExtMessage.html#a09524aea04bc42a759d3c97786521094">getRouteKey</a>()) &lt;&lt; shiftingBits);
<a name="l00705"></a>00705         findNodeExt-&gt;<a class="code" href="classBrooseFindNodeExtMessage.html#a32255169d451507c9a851813469d880b">setStep</a>(findNodeExt-&gt;<a class="code" href="classBrooseFindNodeExtMessage.html#a3be6649aae39d09d4ee64f52b6d3cf2d">getStep</a>() + shiftingBits);
<a name="l00706"></a>00706 
<a name="l00707"></a>00707         <a class="code" href="classKeyDistanceComparator.html">KeyDistanceComparator&lt;KeyXorMetric&gt;</a>* comp = NULL;
<a name="l00708"></a>00708         comp = <span class="keyword">new</span> <a class="code" href="classKeyDistanceComparator.html">KeyDistanceComparator&lt;KeyXorMetric&gt;</a>(
<a name="l00709"></a>00709                 findNodeExt-&gt;<a class="code" href="classBrooseFindNodeExtMessage.html#a09524aea04bc42a759d3c97786521094">getRouteKey</a>());
<a name="l00710"></a>00710 
<a name="l00711"></a>00711         result-&gt;<a class="code" href="classBaseKeySortedVector.html#ac509494faf9fa46ca1d11964a21c8247">setComparator</a>(comp);
<a name="l00712"></a>00712         lBucket-&gt;fillVector(result);
<a name="l00713"></a>00713         result-&gt;<a class="code" href="classBaseKeySortedVector.html#afbcdfbd9680a475cceb48ccc841140cd" title="adds an element of type T in increasing order to the NodeVector and returns the position of the added...">add</a>(thisNode);
<a name="l00714"></a>00714         <span class="keyword">delete</span> comp;
<a name="l00715"></a>00715         <span class="comment">/*</span>
<a name="l00716"></a>00716 <span class="comment">        std::cout &lt;&lt; &quot;key: &quot; &lt;&lt; key.toString(2).substr(0, 8)</span>
<a name="l00717"></a>00717 <span class="comment">                  &lt;&lt; &quot; dist: &quot; &lt;&lt; findNodeExt-&gt;getStep()</span>
<a name="l00718"></a>00718 <span class="comment">                  &lt;&lt; &quot; rtkey: &quot; &lt;&lt; findNodeExt-&gt;getRouteKey().toString(2).substr(0, 8)</span>
<a name="l00719"></a>00719 <span class="comment">                  &lt;&lt; &quot; ThisNode: &quot; &lt;&lt; thisNode.getKey().toString(2).substr(0, 8);</span>
<a name="l00720"></a>00720 <span class="comment">        if (result-&gt;size() &gt; 0) {</span>
<a name="l00721"></a>00721 <span class="comment">            std::cout &lt;&lt; &quot; next hop: &quot; &lt;&lt; (*result)[0].getKey().toString(2).substr(0, 8);</span>
<a name="l00722"></a>00722 <span class="comment">        } else {</span>
<a name="l00723"></a>00723 <span class="comment">            std::cout &lt;&lt; &quot; no next hop!&quot;;</span>
<a name="l00724"></a>00724 <span class="comment">        }</span>
<a name="l00725"></a>00725 <span class="comment">        std::cout &lt;&lt; std::endl &lt;&lt; std::endl;</span>
<a name="l00726"></a>00726 <span class="comment">        */</span>
<a name="l00727"></a>00727 
<a name="l00728"></a>00728     } <span class="keywordflow">else</span> {
<a name="l00729"></a>00729         <span class="comment">// Right Shifting Lookup</span>
<a name="l00730"></a>00730 
<a name="l00731"></a>00731 
<a name="l00732"></a>00732         <span class="comment">// calculate routing key</span>
<a name="l00733"></a>00733         <span class="keywordtype">int</span> prefix = 0;
<a name="l00734"></a>00734         <span class="keywordtype">int</span> dist = findNodeExt-&gt;<a class="code" href="classBrooseFindNodeExtMessage.html#a3be6649aae39d09d4ee64f52b6d3cf2d">getStep</a>();
<a name="l00735"></a>00735         <a class="code" href="classOverlayKey.html" title="A common overlay key class.">OverlayKey</a> routeKey = findNodeExt-&gt;<a class="code" href="classBrooseFindNodeExtMessage.html#a09524aea04bc42a759d3c97786521094">getRouteKey</a>() &gt;&gt; shiftingBits;
<a name="l00736"></a>00736         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; shiftingBits; i++)
<a name="l00737"></a>00737             prefix += ((<span class="keywordtype">int</span>)key.<a class="code" href="classOverlayKey.html#abf5c47662357fb4f01de9a7a93523308">getBit</a>(key.<a class="code" href="classOverlayKey.html#af855a4dfc0e5dc0d2afc6b87fa1d7426" title="Returns the length in number of bits.">getLength</a>() - dist + i) &lt;&lt; i);
<a name="l00738"></a>00738         <a class="code" href="classOverlayKey.html" title="A common overlay key class.">OverlayKey</a> pre(prefix);
<a name="l00739"></a>00739         routeKey += (pre &lt;&lt; (routeKey.<a class="code" href="classOverlayKey.html#af855a4dfc0e5dc0d2afc6b87fa1d7426" title="Returns the length in number of bits.">getLength</a>()-shiftingBits));
<a name="l00740"></a>00740 
<a name="l00741"></a>00741         findNodeExt-&gt;<a class="code" href="classBrooseFindNodeExtMessage.html#aae996c7e18f5f61f4e631b2a63a7a33b">setRouteKey</a>(routeKey);
<a name="l00742"></a>00742         findNodeExt-&gt;<a class="code" href="classBrooseFindNodeExtMessage.html#a32255169d451507c9a851813469d880b">setStep</a>(dist - shiftingBits);
<a name="l00743"></a>00743 
<a name="l00744"></a>00744         <a class="code" href="classKeyDistanceComparator.html">KeyDistanceComparator&lt;KeyXorMetric&gt;</a>* comp = NULL;
<a name="l00745"></a>00745         comp = <span class="keyword">new</span> <a class="code" href="classKeyDistanceComparator.html">KeyDistanceComparator&lt;KeyXorMetric&gt;</a>(routeKey);
<a name="l00746"></a>00746 
<a name="l00747"></a>00747         result-&gt;<a class="code" href="classBaseKeySortedVector.html#ac509494faf9fa46ca1d11964a21c8247">setComparator</a>(comp);
<a name="l00748"></a>00748         rBucket[prefix]-&gt;fillVector(result);
<a name="l00749"></a>00749         result-&gt;<a class="code" href="classBaseKeySortedVector.html#afbcdfbd9680a475cceb48ccc841140cd" title="adds an element of type T in increasing order to the NodeVector and returns the position of the added...">add</a>(thisNode);
<a name="l00750"></a>00750         <span class="keyword">delete</span> comp;
<a name="l00751"></a>00751         <span class="comment">/*</span>
<a name="l00752"></a>00752 <span class="comment">        std::cout &lt;&lt; &quot;key: &quot; &lt;&lt; key.toString(2).substr(0, 8)</span>
<a name="l00753"></a>00753 <span class="comment">                  &lt;&lt; &quot; dist: &quot; &lt;&lt; findNodeExt-&gt;getStep()</span>
<a name="l00754"></a>00754 <span class="comment">                  &lt;&lt; &quot; rtkey: &quot; &lt;&lt; findNodeExt-&gt;getRouteKey().toString(2).substr(0, 8)</span>
<a name="l00755"></a>00755 <span class="comment">                  &lt;&lt; &quot; ThisNode: &quot; &lt;&lt; thisNode.getKey().toString(2).substr(0, 8);</span>
<a name="l00756"></a>00756 <span class="comment">        if (result-&gt;size() &gt; 0) {</span>
<a name="l00757"></a>00757 <span class="comment">            std::cout &lt;&lt; &quot; next hop: &quot; &lt;&lt; (*result)[0].getKey().toString(2).substr(0, 8);</span>
<a name="l00758"></a>00758 <span class="comment">        } else {</span>
<a name="l00759"></a>00759 <span class="comment">            std::cout &lt;&lt; &quot; no next hop!&quot;;</span>
<a name="l00760"></a>00760 <span class="comment">        }</span>
<a name="l00761"></a>00761 <span class="comment">        std::cout &lt;&lt; std::endl &lt;&lt; std::endl;</span>
<a name="l00762"></a>00762 <span class="comment">        */</span>
<a name="l00763"></a>00763     }
<a name="l00764"></a>00764 
<a name="l00765"></a>00765     <span class="keywordflow">if</span> ((*result)[0] == thisNode) {
<a name="l00766"></a>00766         <span class="keyword">delete</span> result;
<a name="l00767"></a>00767         <span class="keywordflow">return</span> (findNode(key, numRedundantNodes, numSiblings, msg));
<a name="l00768"></a>00768     } <span class="keywordflow">else</span>
<a name="l00769"></a>00769         <span class="keywordflow">return</span> result;
<a name="l00770"></a>00770 }
<a name="l00771"></a>00771 
<a name="l00772"></a><a class="code" href="classBroose.html#a612a233a588034ad82589aab7769e196">00772</a> <span class="keywordtype">void</span> <a class="code" href="classBroose.html#a612a233a588034ad82589aab7769e196" title="collects statistical data in derived class">Broose::finishOverlay</a>()
<a name="l00773"></a>00773 {
<a name="l00774"></a>00774     <span class="comment">// store statistics</span>
<a name="l00775"></a>00775     simtime_t time = globalStatistics-&gt;calcMeasuredLifetime(creationTime);
<a name="l00776"></a>00776     <span class="keywordflow">if</span> (time &lt; <a class="code" href="classGlobalStatistics.html#a169810c78519b271f7e32fdc7c9fc641" title="minimum useful measured lifetime in seconds">GlobalStatistics::MIN_MEASURED</a>) <span class="keywordflow">return</span>;
<a name="l00777"></a>00777 
<a name="l00778"></a>00778     globalStatistics-&gt;addStdDev(<span class="stringliteral">&quot;Broose: Number of non-routable packets/s&quot;</span>, numFailedPackets / time);
<a name="l00779"></a>00779     globalStatistics-&gt;addStdDev(<span class="stringliteral">&quot;Broose: Sent BUCKET Messages/s&quot;</span>, bucketCount / time);
<a name="l00780"></a>00780     globalStatistics-&gt;addStdDev(<span class="stringliteral">&quot;Broose: Sent BUCKET Byte/s&quot;</span>, bucketBytesSent / time);
<a name="l00781"></a>00781     globalStatistics-&gt;addStdDev(<span class="stringliteral">&quot;Broose: Bucket retries at join&quot;</span>, bucketRetries);
<a name="l00782"></a>00782 
<a name="l00783"></a>00783 }
<a name="l00784"></a>00784 
<a name="l00785"></a><a class="code" href="classBroose.html#aa1c5b32d5a8043dedb9e541d7d6a106a">00785</a> <span class="keywordtype">void</span> <a class="code" href="classBroose.html#aa1c5b32d5a8043dedb9e541d7d6a106a" title="Collect overlay specific sent messages statistics.">Broose::recordOverlaySentStats</a>(<a class="code" href="classBaseOverlayMessage.html" title="Class generated from common/CommonMessages.msg by opp_msgc.">BaseOverlayMessage</a>* msg)
<a name="l00786"></a>00786 {
<a name="l00787"></a>00787     <a class="code" href="classBaseOverlayMessage.html" title="Class generated from common/CommonMessages.msg by opp_msgc.">BaseOverlayMessage</a>* innerMsg = msg;
<a name="l00788"></a>00788     <span class="keywordflow">while</span> (innerMsg-&gt;<a class="code" href="classBaseOverlayMessage.html#a406e342c0841abe2d82b9bb5c1e2aabd">getType</a>() != <a class="code" href="CommonMessages__m_8h.html#a6af1a552a7a6bce33c291758c369b17eab0641a3f5bcb1e08ee72afe9583ff5e6">APPDATA</a> &amp;&amp;
<a name="l00789"></a>00789            innerMsg-&gt;getEncapsulatedPacket() != NULL) {
<a name="l00790"></a>00790         innerMsg =
<a name="l00791"></a>00791             <span class="keyword">static_cast&lt;</span><a class="code" href="classBaseOverlayMessage.html" title="Class generated from common/CommonMessages.msg by opp_msgc.">BaseOverlayMessage</a>*<span class="keyword">&gt;</span>(innerMsg-&gt;getEncapsulatedPacket());
<a name="l00792"></a>00792     }
<a name="l00793"></a>00793 
<a name="l00794"></a>00794     <span class="keywordflow">switch</span> (innerMsg-&gt;<a class="code" href="classBaseOverlayMessage.html#a406e342c0841abe2d82b9bb5c1e2aabd">getType</a>()) {
<a name="l00795"></a>00795     <span class="keywordflow">case</span> <a class="code" href="CommonMessages__m_8h.html#a6af1a552a7a6bce33c291758c369b17ea7f7e32ed10aea1dd73b80e96c70e8abf">RPC</a>:
<a name="l00796"></a>00796         <span class="keywordflow">if</span> ((dynamic_cast&lt;BucketCall*&gt;(innerMsg) != NULL) ||
<a name="l00797"></a>00797                 (<span class="keyword">dynamic_cast&lt;</span><a class="code" href="classBucketResponse.html" title="Class generated from overlay/broose/BrooseMessage.msg by opp_msgc.">BucketResponse</a>*<span class="keyword">&gt;</span>(innerMsg) != NULL)) {
<a name="l00798"></a>00798             <a class="code" href="GlobalStatistics_8h.html#af29140ebe8e0a93406a58441f7c5fec8" title="Macro used for recording statistics considering measureNetwIn parameter.">RECORD_STATS</a>(bucketCount++; bucketBytesSent +=
<a name="l00799"></a>00799                              msg-&gt;getByteLength());
<a name="l00800"></a>00800         }
<a name="l00801"></a>00801         <span class="keywordflow">break</span>;
<a name="l00802"></a>00802     }
<a name="l00803"></a>00803 }
<a name="l00804"></a>00804 
<a name="l00805"></a><a class="code" href="classBroose.html#a68de6c368892f19883e1ecd3db10ae5c">00805</a> <span class="keywordtype">void</span> <a class="code" href="classBroose.html#a68de6c368892f19883e1ecd3db10ae5c" title="debug function which output the content of the node&#39;s buckets">Broose::displayBucketState</a>()
<a name="l00806"></a>00806 {
<a name="l00807"></a>00807     EV &lt;&lt; <span class="stringliteral">&quot;[Broose::displayBucketState() @ &quot;</span> &lt;&lt; thisNode.getIp()
<a name="l00808"></a>00808        &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; thisNode.getKey().toString(16) &lt;&lt; <span class="stringliteral">&quot;)]&quot;</span> &lt;&lt; endl;
<a name="l00809"></a>00809 
<a name="l00810"></a>00810     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; powShiftingBits; i++) {
<a name="l00811"></a>00811         EV &lt;&lt; <span class="stringliteral">&quot;    Content of rBucket[&quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;]: &quot;</span>;
<a name="l00812"></a>00812         rBucket[i]-&gt;output();
<a name="l00813"></a>00813     }
<a name="l00814"></a>00814 
<a name="l00815"></a>00815     EV &lt;&lt; <span class="stringliteral">&quot;    Content of lBucket: &quot;</span>;
<a name="l00816"></a>00816     lBucket-&gt;output();
<a name="l00817"></a>00817     EV &lt;&lt; <span class="stringliteral">&quot;    Content of bBucket: &quot;</span>;
<a name="l00818"></a>00818     bBucket-&gt;output();
<a name="l00819"></a>00819     EV &lt;&lt; endl;
<a name="l00820"></a>00820 }
<a name="l00821"></a>00821 
<a name="l00822"></a>00822 
<a name="l00823"></a><a class="code" href="classBroose.html#a40ebbf7442175faf9f71527d297f2834">00823</a> <span class="keywordtype">bool</span> <a class="code" href="classBroose.html#a40ebbf7442175faf9f71527d297f2834" title="Query if a node is among the siblings for a given key.">Broose::isSiblingFor</a>(<span class="keyword">const</span> <a class="code" href="classNodeHandle.html" title="This class implements a node handle.">NodeHandle</a>&amp; node,
<a name="l00824"></a>00824                           <span class="keyword">const</span> <a class="code" href="classOverlayKey.html" title="A common overlay key class.">OverlayKey</a>&amp; key,
<a name="l00825"></a>00825                           <span class="keywordtype">int</span> numSiblings,
<a name="l00826"></a>00826                           <span class="keywordtype">bool</span>* err)
<a name="l00827"></a>00827 {
<a name="l00828"></a>00828 <span class="comment">// TODO: node != thisNode doesn&#39;t work yet</span>
<a name="l00829"></a>00829     <span class="keywordflow">if</span> (key.<a class="code" href="classOverlayKey.html#abe357a4d1babcf7d30598a61cbc0f5c2" title="Returns true, if the key is unspecified.">isUnspecified</a>())
<a name="l00830"></a>00830         <a class="code" href="yang_8cc.html#adb989392f8aada21b0f7ec2f7a41dc00">error</a>(<span class="stringliteral">&quot;Broose::isSiblingFor(): key is unspecified!&quot;</span>);
<a name="l00831"></a>00831 
<a name="l00832"></a>00832     <span class="keywordflow">if</span> (node != thisNode)
<a name="l00833"></a>00833         <a class="code" href="yang_8cc.html#adb989392f8aada21b0f7ec2f7a41dc00">error</a>(<span class="stringliteral">&quot;Broose::isSiblingsFor(): &quot;</span>
<a name="l00834"></a>00834               <span class="stringliteral">&quot;node != thisNode is not implemented!&quot;</span>);
<a name="l00835"></a>00835 
<a name="l00836"></a>00836     <span class="keywordflow">if</span> (numSiblings &gt; getMaxNumSiblings()) {
<a name="l00837"></a>00837         opp_error(<span class="stringliteral">&quot;Broose::isSiblingFor(): numSiblings too big!&quot;</span>);
<a name="l00838"></a>00838     }
<a name="l00839"></a>00839     <span class="comment">// set default number of siblings to consider</span>
<a name="l00840"></a>00840     <span class="keywordflow">if</span> (numSiblings == -1) numSiblings = getMaxNumSiblings();
<a name="l00841"></a>00841 
<a name="l00842"></a>00842     <span class="keywordflow">if</span> (numSiblings == 0) {
<a name="l00843"></a>00843         *err = <span class="keyword">false</span>;
<a name="l00844"></a>00844         <span class="keywordflow">return</span> (node.<a class="code" href="classNodeHandle.html#aef531103cdf07c8353267f4d30a80112" title="returns key of this NodeHandle">getKey</a>() == key);
<a name="l00845"></a>00845     }
<a name="l00846"></a>00846 
<a name="l00847"></a>00847     <span class="keywordflow">if</span> (state != READY) {
<a name="l00848"></a>00848         *err = <span class="keyword">true</span>;
<a name="l00849"></a>00849         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00850"></a>00850     }
<a name="l00851"></a>00851 
<a name="l00852"></a>00852     <span class="comment">// TODO: handle numSibling parameter</span>
<a name="l00853"></a>00853     <span class="keywordflow">return</span> bBucket-&gt;keyInRange(key);
<a name="l00854"></a>00854 }
<a name="l00855"></a>00855 
<a name="l00856"></a><a class="code" href="classBroose.html#a96653c170474659145bbdeae4c8a6ca3">00856</a> <span class="keywordtype">void</span> <a class="code" href="classBroose.html#a96653c170474659145bbdeae4c8a6ca3" title="updates information shown in tk-environment">Broose::updateTooltip</a>()
<a name="l00857"></a>00857 {
<a name="l00858"></a>00858     <span class="keywordflow">if</span> (ev.isGUI()) {
<a name="l00859"></a>00859         std::stringstream ttString;
<a name="l00860"></a>00860 
<a name="l00861"></a>00861         <span class="comment">// show our ip and key in tooltip</span>
<a name="l00862"></a>00862         ttString &lt;&lt; thisNode.getIp() &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; thisNode.getKey();
<a name="l00863"></a>00863 
<a name="l00864"></a>00864         getParentModule()-&gt;getParentModule()-&gt;getDisplayString().
<a name="l00865"></a>00865                                   setTagArg(<span class="stringliteral">&quot;tt&quot;</span>, 0, ttString.str().c_str());
<a name="l00866"></a>00866         getParentModule()-&gt;getDisplayString().
<a name="l00867"></a>00867                                   setTagArg(<span class="stringliteral">&quot;tt&quot;</span>, 0, ttString.str().c_str());
<a name="l00868"></a>00868         getDisplayString().setTagArg(<span class="stringliteral">&quot;tt&quot;</span>, 0, ttString.str().c_str());
<a name="l00869"></a>00869 
<a name="l00870"></a>00870     }
<a name="l00871"></a>00871 }
<a name="l00872"></a>00872 
<a name="l00873"></a><a class="code" href="classBroose.html#a9ff73fadcd26b7b793020517d5d248c0">00873</a> <span class="keywordtype">bool</span> <a class="code" href="classBroose.html#a9ff73fadcd26b7b793020517d5d248c0" title="Processes Remote-Procedure-Call invocation messages.">Broose::handleRpcCall</a>(<a class="code" href="classBaseCallMessage.html" title="Class generated from common/CommonMessages.msg by opp_msgc.">BaseCallMessage</a>* msg)
<a name="l00874"></a>00874 {
<a name="l00875"></a>00875     <span class="keywordflow">if</span> (state == BSET || state == READY) {
<a name="l00876"></a>00876         <span class="comment">// delegate messages</span>
<a name="l00877"></a>00877         <a class="code" href="RpcMacros_8h.html#aa75b135e279b574267e1a7dc4ab79da4" title="Marks the beginning of a Remote-Procedure-Call Switch block.">RPC_SWITCH_START</a>(msg)
<a name="l00878"></a>00878         <a class="code" href="RpcMacros_8h.html#ad81d44e9bc59d2fb2cfcacc4d5ecda35" title="Declares a RPC method delegation.">RPC_DELEGATE</a>(Bucket, handleBucketRequestRpc);
<a name="l00879"></a>00879         <a class="code" href="RpcMacros_8h.html#ae07fad586ce7b9e82ad12848767a32e5">RPC_ON_CALL</a>(Ping) {
<a name="l00880"></a>00880             <span class="comment">// add pinging node to all buckets and update lastSeen of node</span>
<a name="l00881"></a>00881             routingAdd(msg-&gt;<a class="code" href="classBaseRpcMessage.html#ada3e122125cfb5acc7350277ca69c45a">getSrcNode</a>(), <span class="keyword">true</span>);
<a name="l00882"></a>00882             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00883"></a>00883             <span class="keywordflow">break</span>;
<a name="l00884"></a>00884         }
<a name="l00885"></a>00885         <a class="code" href="RpcMacros_8h.html#ae07fad586ce7b9e82ad12848767a32e5">RPC_ON_CALL</a>(FindNode) {
<a name="l00886"></a>00886             <span class="comment">// add pinging node to all buckets and update lastSeen of node</span>
<a name="l00887"></a>00887             routingAdd(msg-&gt;<a class="code" href="classBaseRpcMessage.html#ada3e122125cfb5acc7350277ca69c45a">getSrcNode</a>(), <span class="keyword">true</span>);
<a name="l00888"></a>00888             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00889"></a>00889             <span class="keywordflow">break</span>;
<a name="l00890"></a>00890         }
<a name="l00891"></a>00891         <a class="code" href="RpcMacros_8h.html#a29a8a3f21e67ecb25f58608a54df5191" title="Marks the end of a Remote-Procedure-Call Switch block.">RPC_SWITCH_END</a>()
<a name="l00892"></a>00892         <span class="keywordflow">return</span> <a class="code" href="RpcMacros_8h.html#aa5e964b7c7129c0943237a786e455e9a">RPC_HANDLED</a>;
<a name="l00893"></a>00893     } <span class="keywordflow">else</span> {
<a name="l00894"></a>00894         <a class="code" href="RpcMacros_8h.html#aa75b135e279b574267e1a7dc4ab79da4" title="Marks the beginning of a Remote-Procedure-Call Switch block.">RPC_SWITCH_START</a>(msg)
<a name="l00895"></a>00895         <span class="comment">// don&#39;t answer PING and FIND_NODE calls, if the node can&#39;t route yet</span>
<a name="l00896"></a>00896         <a class="code" href="RpcMacros_8h.html#ae07fad586ce7b9e82ad12848767a32e5">RPC_ON_CALL</a>(Ping) {
<a name="l00897"></a>00897             <span class="keyword">delete</span> msg;
<a name="l00898"></a>00898             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00899"></a>00899             <span class="keywordflow">break</span>;
<a name="l00900"></a>00900         }
<a name="l00901"></a>00901         <a class="code" href="RpcMacros_8h.html#ae07fad586ce7b9e82ad12848767a32e5">RPC_ON_CALL</a>(FindNode) {
<a name="l00902"></a>00902             <span class="keyword">delete</span> msg;
<a name="l00903"></a>00903             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00904"></a>00904             <span class="keywordflow">break</span>;
<a name="l00905"></a>00905         }
<a name="l00906"></a>00906         <a class="code" href="RpcMacros_8h.html#a29a8a3f21e67ecb25f58608a54df5191" title="Marks the end of a Remote-Procedure-Call Switch block.">RPC_SWITCH_END</a>()
<a name="l00907"></a>00907         <span class="keywordflow">return</span> <a class="code" href="RpcMacros_8h.html#aa5e964b7c7129c0943237a786e455e9a">RPC_HANDLED</a>;
<a name="l00908"></a>00908     }
<a name="l00909"></a>00909 }
<a name="l00910"></a>00910 
<a name="l00911"></a><a class="code" href="classBroose.html#a374f84f156f25252dfe3fca84e29ccae">00911</a> <span class="keywordtype">void</span> <a class="code" href="classBroose.html#a374f84f156f25252dfe3fca84e29ccae" title="This method is called if an RPC response has been received.">Broose::handleRpcResponse</a>(<a class="code" href="classBaseResponseMessage.html" title="Class generated from common/CommonMessages.msg by opp_msgc.">BaseResponseMessage</a>* msg,
<a name="l00912"></a>00912                                <span class="keyword">const</span> <a class="code" href="classRpcState.html">RpcState</a>&amp; rpcState,
<a name="l00913"></a>00913                                simtime_t rtt)
<a name="l00914"></a>00914 {
<a name="l00915"></a>00915     <span class="comment">// add sender to all buckets and update lastSeen of node</span>
<a name="l00916"></a>00916     routingAdd(msg-&gt;<a class="code" href="classBaseRpcMessage.html#ada3e122125cfb5acc7350277ca69c45a">getSrcNode</a>(), <span class="keyword">true</span>, rtt);
<a name="l00917"></a>00917 
<a name="l00918"></a>00918     <a class="code" href="RpcMacros_8h.html#aa75b135e279b574267e1a7dc4ab79da4" title="Marks the beginning of a Remote-Procedure-Call Switch block.">RPC_SWITCH_START</a>(msg)
<a name="l00919"></a>00919     <a class="code" href="RpcMacros_8h.html#a0394d2dc4f9f1e15d7e99c9f43da10c7">RPC_ON_RESPONSE</a>( Bucket ) {
<a name="l00920"></a>00920         handleBucketResponseRpc(_BucketResponse, rpcState);
<a name="l00921"></a>00921         EV &lt;&lt; <span class="stringliteral">&quot;[Broose::handleRpcResponse() @ &quot;</span> &lt;&lt; thisNode.getIp()
<a name="l00922"></a>00922            &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; thisNode.getKey().toString(16) &lt;&lt; <span class="stringliteral">&quot;)]\n&quot;</span>
<a name="l00923"></a>00923            &lt;&lt; <span class="stringliteral">&quot;    Bucket RPC Response received: id=&quot;</span> &lt;&lt; rpcState.<a class="code" href="classRpcState.html#aef057cfd57307ee5893014084208a28e">getId</a>() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>
<a name="l00924"></a>00924            &lt;&lt; <span class="stringliteral">&quot;    msg=&quot;</span> &lt;&lt; *_BucketResponse &lt;&lt; <span class="stringliteral">&quot; rtt=&quot;</span> &lt;&lt; rtt
<a name="l00925"></a>00925            &lt;&lt; endl;
<a name="l00926"></a>00926         <span class="keywordflow">break</span>;
<a name="l00927"></a>00927     }
<a name="l00928"></a>00928     <a class="code" href="RpcMacros_8h.html#a0394d2dc4f9f1e15d7e99c9f43da10c7">RPC_ON_RESPONSE</a>(FindNode)
<a name="l00929"></a>00929     {
<a name="l00930"></a>00930         <span class="comment">// add inactive nodes</span>
<a name="l00931"></a>00931         <span class="keywordflow">for</span> (uint32_t i=0; i&lt;_FindNodeResponse-&gt;getClosestNodesArraySize(); i++)
<a name="l00932"></a>00932             routingAdd(_FindNodeResponse-&gt;getClosestNodes(i), <span class="keyword">false</span>);
<a name="l00933"></a>00933         <span class="keywordflow">break</span>;
<a name="l00934"></a>00934     }
<a name="l00935"></a>00935     <a class="code" href="RpcMacros_8h.html#a29a8a3f21e67ecb25f58608a54df5191" title="Marks the end of a Remote-Procedure-Call Switch block.">RPC_SWITCH_END</a>( )
<a name="l00936"></a>00936 }
<a name="l00937"></a>00937 
<a name="l00938"></a><a class="code" href="classBroose.html#a1f57a7b9ea934f2577f0336ce3530998">00938</a> <span class="keywordtype">void</span> <a class="code" href="classBroose.html#a1f57a7b9ea934f2577f0336ce3530998" title="This method is called if an RPC timeout has been reached.">Broose::handleRpcTimeout</a>(<span class="keyword">const</span> <a class="code" href="classRpcState.html">RpcState</a>&amp; rpcState)
<a name="l00939"></a>00939 {
<a name="l00940"></a>00940     <a class="code" href="RpcMacros_8h.html#aa75b135e279b574267e1a7dc4ab79da4" title="Marks the beginning of a Remote-Procedure-Call Switch block.">RPC_SWITCH_START</a>(rpcState.<a class="code" href="classRpcState.html#a09b77220e4a2e2a95c364a1b69653ac5">getCallMsg</a>())
<a name="l00941"></a>00941     <a class="code" href="RpcMacros_8h.html#ae07fad586ce7b9e82ad12848767a32e5">RPC_ON_CALL</a>(FindNode) {
<a name="l00942"></a>00942         handleFindNodeTimeout(_FindNodeCall, rpcState.<a class="code" href="classRpcState.html#af72427e81f440292cea7de1f3a545a56">getDest</a>(), rpcState.<a class="code" href="classRpcState.html#a81be85c40f01ff6bc3f05869f959235d">getDestKey</a>());
<a name="l00943"></a>00943         EV &lt;&lt; <span class="stringliteral">&quot;[Broose::handleRpcTimeout() @ &quot;</span> &lt;&lt; thisNode.getIp()
<a name="l00944"></a>00944         &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; thisNode.getKey().toString(16) &lt;&lt; <span class="stringliteral">&quot;)]\n&quot;</span>
<a name="l00945"></a>00945         &lt;&lt; <span class="stringliteral">&quot;    Find Node RPC Call timed out: id=&quot;</span> &lt;&lt; rpcState.<a class="code" href="classRpcState.html#aef057cfd57307ee5893014084208a28e">getId</a>() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>
<a name="l00946"></a>00946         &lt;&lt; <span class="stringliteral">&quot;    msg=&quot;</span> &lt;&lt; *_FindNodeCall
<a name="l00947"></a>00947         &lt;&lt; endl;
<a name="l00948"></a>00948         <span class="keywordflow">break</span>;
<a name="l00949"></a>00949     }
<a name="l00950"></a>00950     <a class="code" href="RpcMacros_8h.html#ae07fad586ce7b9e82ad12848767a32e5">RPC_ON_CALL</a>(Bucket) {
<a name="l00951"></a>00951         handleBucketTimeout(_BucketCall);
<a name="l00952"></a>00952         EV &lt;&lt; <span class="stringliteral">&quot;[Broose::handleRpcTimeout() @ &quot;</span> &lt;&lt; thisNode.getIp()
<a name="l00953"></a>00953         &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; thisNode.getKey().toString(16) &lt;&lt; <span class="stringliteral">&quot;)]\n&quot;</span>
<a name="l00954"></a>00954         &lt;&lt; <span class="stringliteral">&quot;    Bucket RPC Call timed out: id=&quot;</span> &lt;&lt; rpcState.<a class="code" href="classRpcState.html#aef057cfd57307ee5893014084208a28e">getId</a>() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>
<a name="l00955"></a>00955         &lt;&lt; <span class="stringliteral">&quot;    msg=&quot;</span> &lt;&lt; *_BucketCall
<a name="l00956"></a>00956         &lt;&lt; endl;
<a name="l00957"></a>00957         <span class="keywordflow">break</span>;
<a name="l00958"></a>00958     }
<a name="l00959"></a>00959     <a class="code" href="RpcMacros_8h.html#a29a8a3f21e67ecb25f58608a54df5191" title="Marks the end of a Remote-Procedure-Call Switch block.">RPC_SWITCH_END</a>()
<a name="l00960"></a>00960 }
<a name="l00961"></a>00961 
<a name="l00962"></a><a class="code" href="classBroose.html#a64365d561848d0f9be471ac2c6588d36">00962</a> <span class="keywordtype">void</span> <a class="code" href="classBroose.html#a64365d561848d0f9be471ac2c6588d36" title="handles a received Bucket request">Broose::handleBucketRequestRpc</a>(<a class="code" href="classBucketCall.html" title="Class generated from overlay/broose/BrooseMessage.msg by opp_msgc.">BucketCall</a>* msg)
<a name="l00963"></a>00963 {
<a name="l00964"></a>00964     <span class="keywordflow">if</span> (msg-&gt;<a class="code" href="classBucketCall.html#a83d606b3bf9fdc48c709b10242a5c9ae">getBucketType</a>() == <a class="code" href="BrooseMessage__m_8h.html#a0d72090ca3225dfb0af1767bf6390a40adb45120aafd37a973140edee24708065">LEFT</a>) {
<a name="l00965"></a>00965         <span class="comment">// TODO: dependent on the churn scenarios this may give better</span>
<a name="l00966"></a>00966         <span class="comment">//       or worse results</span>
<a name="l00967"></a>00967         <span class="keywordflow">if</span> (stab1 &amp;&amp; (state == BSET)) {
<a name="l00968"></a>00968             <span class="comment">// can&#39;t handle LBucketRequest in BSET-State</span>
<a name="l00969"></a>00969             <span class="keyword">delete</span> msg;
<a name="l00970"></a>00970             <span class="keywordflow">return</span>;
<a name="l00971"></a>00971         }
<a name="l00972"></a>00972 
<a name="l00973"></a>00973         <span class="comment">// return L-Bucket</span>
<a name="l00974"></a>00974         <span class="keywordtype">int</span> size = lBucket-&gt;getSize();
<a name="l00975"></a>00975         <a class="code" href="classBucketResponse.html" title="Class generated from overlay/broose/BrooseMessage.msg by opp_msgc.">BucketResponse</a>* bResponse = <span class="keyword">new</span> <a class="code" href="classBucketResponse.html" title="Class generated from overlay/broose/BrooseMessage.msg by opp_msgc.">BucketResponse</a>(<span class="stringliteral">&quot;LBucketResponse&quot;</span>);
<a name="l00976"></a>00976         bResponse-&gt;<a class="code" href="classBucketResponse.html#a9a885b9b8d73756a0a8a84f8f96ef692">setNodesArraySize</a>(size);
<a name="l00977"></a>00977 
<a name="l00978"></a>00978         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; size; i++) {
<a name="l00979"></a>00979             bResponse-&gt;<a class="code" href="classBucketResponse.html#a7526129142469cbf7a82b57b83bf1fc0">setNodes</a>(i, lBucket-&gt;get(i));
<a name="l00980"></a>00980         }
<a name="l00981"></a>00981 
<a name="l00982"></a>00982         bResponse-&gt;setBitLength(<a class="code" href="BrooseMessage__m_8h.html#a5be8fc7cfdcfdb3f48cad80a6f25a3cc">BUCKETRESPONSE_L</a>(bResponse));
<a name="l00983"></a>00983 
<a name="l00984"></a>00984         <span class="comment">// only add, if the originator is already in the BSET state</span>
<a name="l00985"></a>00985         <span class="comment">// in which the node already is able to do right shifting lookups</span>
<a name="l00986"></a>00986         <span class="comment">// TODO: this leads to lower lookup success rates in some scenarios</span>
<a name="l00987"></a>00987         <span class="comment">//       but helps to prevent deadlock situations with high churn rates</span>
<a name="l00988"></a>00988         <span class="keywordflow">if</span> (stab2 || (msg-&gt;<a class="code" href="classBucketCall.html#af28e5a564ef2cc1d07e9031401457412">getProState</a>() == <a class="code" href="BrooseMessage__m_8h.html#a1e4df1e60bb9501df7c024063484d127a59443e9ea684a77445f11ef9ebccebbd">PBSET</a>)) {
<a name="l00989"></a>00989             routingAdd(msg-&gt;<a class="code" href="classBaseRpcMessage.html#ada3e122125cfb5acc7350277ca69c45a">getSrcNode</a>(), <span class="keyword">true</span>);
<a name="l00990"></a>00990         }
<a name="l00991"></a>00991 
<a name="l00992"></a>00992         sendRpcResponse(msg, bResponse);
<a name="l00993"></a>00993     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (msg-&gt;<a class="code" href="classBucketCall.html#a83d606b3bf9fdc48c709b10242a5c9ae">getBucketType</a>() == <a class="code" href="BrooseMessage__m_8h.html#a0d72090ca3225dfb0af1767bf6390a40a0448a6480348702c480296969de6dca0">BROTHER</a>) {
<a name="l00994"></a>00994         <span class="comment">// return B-Bucket</span>
<a name="l00995"></a>00995         <span class="keywordtype">int</span> size = bBucket-&gt;getSize();
<a name="l00996"></a>00996         <a class="code" href="classBucketResponse.html" title="Class generated from overlay/broose/BrooseMessage.msg by opp_msgc.">BucketResponse</a>* bResponse = <span class="keyword">new</span> <a class="code" href="classBucketResponse.html" title="Class generated from overlay/broose/BrooseMessage.msg by opp_msgc.">BucketResponse</a>(<span class="stringliteral">&quot;BBucketResponse&quot;</span>);
<a name="l00997"></a>00997         bResponse-&gt;<a class="code" href="classBucketResponse.html#a9a885b9b8d73756a0a8a84f8f96ef692">setNodesArraySize</a>(size);
<a name="l00998"></a>00998 
<a name="l00999"></a>00999         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; size; i++) {
<a name="l01000"></a>01000             bResponse-&gt;<a class="code" href="classBucketResponse.html#a7526129142469cbf7a82b57b83bf1fc0">setNodes</a>(i, bBucket-&gt;get(i));
<a name="l01001"></a>01001         }
<a name="l01002"></a>01002         bResponse-&gt;setBitLength(<a class="code" href="BrooseMessage__m_8h.html#a5be8fc7cfdcfdb3f48cad80a6f25a3cc">BUCKETRESPONSE_L</a>(bResponse));
<a name="l01003"></a>01003 
<a name="l01004"></a>01004         sendRpcResponse(msg, bResponse);
<a name="l01005"></a>01005     } <span class="keywordflow">else</span>
<a name="l01006"></a>01006         <a class="code" href="yang_8cc.html#adb989392f8aada21b0f7ec2f7a41dc00">error</a>(<span class="stringliteral">&quot;Broose::handleBucketRequestRpc() - Wrong Bucket Type!&quot;</span>);
<a name="l01007"></a>01007 }
<a name="l01008"></a>01008 
<a name="l01009"></a><a class="code" href="classBroose.html#a2479baebf247d26c2cb9171104932b8e">01009</a> <span class="keywordtype">void</span> <a class="code" href="classBroose.html#a2479baebf247d26c2cb9171104932b8e" title="handles a received Bucket response">Broose::handleBucketResponseRpc</a>(<a class="code" href="classBucketResponse.html" title="Class generated from overlay/broose/BrooseMessage.msg by opp_msgc.">BucketResponse</a>* msg,
<a name="l01010"></a>01010                                      <span class="keyword">const</span> <a class="code" href="classRpcState.html">RpcState</a>&amp; rpcState)
<a name="l01011"></a>01011 {
<a name="l01012"></a>01012     <a class="code" href="classBucketCall.html" title="Class generated from overlay/broose/BrooseMessage.msg by opp_msgc.">BucketCall</a>* call = check_and_cast&lt;<a class="code" href="classBucketCall.html" title="Class generated from overlay/broose/BrooseMessage.msg by opp_msgc.">BucketCall</a>*&gt;(rpcState.<a class="code" href="classRpcState.html#a09b77220e4a2e2a95c364a1b69653ac5">getCallMsg</a>());
<a name="l01013"></a>01013 
<a name="l01014"></a>01014     <span class="keywordflow">for</span> (uint i = 0; i &lt; msg-&gt;<a class="code" href="classBucketResponse.html#ad88cd01819cf77f82a6987fa369e09bb">getNodesArraySize</a>(); i++) {
<a name="l01015"></a>01015         routingAdd(msg-&gt;<a class="code" href="classBucketResponse.html#a35736a02a4810f57725e861449e7bb5b">getNodes</a>(i), <span class="keyword">false</span>);
<a name="l01016"></a>01016     }
<a name="l01017"></a>01017 
<a name="l01018"></a>01018     <span class="keywordflow">if</span> (call-&gt;<a class="code" href="classBucketCall.html#a83d606b3bf9fdc48c709b10242a5c9ae">getBucketType</a>() == <a class="code" href="BrooseMessage__m_8h.html#a0d72090ca3225dfb0af1767bf6390a40adb45120aafd37a973140edee24708065">LEFT</a>) {
<a name="l01019"></a>01019         <span class="keywordflow">switch</span> (state) {
<a name="l01020"></a>01020         <span class="keywordflow">case</span> RSET:
<a name="l01021"></a>01021             <span class="keywordflow">if</span> (call-&gt;<a class="code" href="classBucketCall.html#af28e5a564ef2cc1d07e9031401457412">getProState</a>() == <a class="code" href="BrooseMessage__m_8h.html#a1e4df1e60bb9501df7c024063484d127aa90bbfe38513a4fab312de105624e88e">PRSET</a>) {
<a name="l01022"></a>01022                 receivedBBucketLookup++;
<a name="l01023"></a>01023 
<a name="l01024"></a>01024                 <span class="keywordflow">if</span> (receivedBBucketLookup == numberBBucketLookup)
<a name="l01025"></a>01025                     changeState(BSET);
<a name="l01026"></a>01026             }
<a name="l01027"></a>01027             <span class="keywordflow">break</span>;
<a name="l01028"></a>01028         <span class="keywordflow">case</span> BSET:
<a name="l01029"></a>01029             <span class="keywordflow">if</span> (call-&gt;<a class="code" href="classBucketCall.html#af28e5a564ef2cc1d07e9031401457412">getProState</a>() == <a class="code" href="BrooseMessage__m_8h.html#a1e4df1e60bb9501df7c024063484d127a59443e9ea684a77445f11ef9ebccebbd">PBSET</a>) {
<a name="l01030"></a>01030                 receivedLBucketLookup++;
<a name="l01031"></a>01031 
<a name="l01032"></a>01032                 <span class="keywordflow">if</span> (receivedLBucketLookup == numberLBucketLookup)
<a name="l01033"></a>01033                     changeState(READY);
<a name="l01034"></a>01034             }
<a name="l01035"></a>01035             <span class="keywordflow">break</span>;
<a name="l01036"></a>01036         <span class="keywordflow">default</span>:
<a name="l01037"></a>01037             <span class="keywordflow">break</span>;
<a name="l01038"></a>01038         }
<a name="l01039"></a>01039     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (call-&gt;<a class="code" href="classBucketCall.html#a83d606b3bf9fdc48c709b10242a5c9ae">getBucketType</a>() == <a class="code" href="BrooseMessage__m_8h.html#a0d72090ca3225dfb0af1767bf6390a40a0448a6480348702c480296969de6dca0">BROTHER</a>) {
<a name="l01040"></a>01040         <span class="keywordflow">switch</span>(state) {
<a name="l01041"></a>01041         <span class="keywordflow">case</span> INIT:
<a name="l01042"></a>01042             <span class="keywordflow">if</span> (call-&gt;<a class="code" href="classBucketCall.html#af28e5a564ef2cc1d07e9031401457412">getProState</a>() == <a class="code" href="BrooseMessage__m_8h.html#a1e4df1e60bb9501df7c024063484d127a544019da4a7a9284830c20e6c4f5a5a8">PINIT</a>) {
<a name="l01043"></a>01043                 receivedJoinResponse++;
<a name="l01044"></a>01044                 <span class="keywordflow">if</span> (receivedJoinResponse == powShiftingBits)
<a name="l01045"></a>01045                     changeState(RSET);
<a name="l01046"></a>01046             }
<a name="l01047"></a>01047         <span class="keywordflow">default</span>:
<a name="l01048"></a>01048             <span class="keywordflow">break</span>;
<a name="l01049"></a>01049         }
<a name="l01050"></a>01050     } <span class="keywordflow">else</span>
<a name="l01051"></a>01051         <a class="code" href="yang_8cc.html#adb989392f8aada21b0f7ec2f7a41dc00">error</a>(<span class="stringliteral">&quot;Broose::handleBucketRequestRpc() - unknown error.&quot;</span>);
<a name="l01052"></a>01052 }
<a name="l01053"></a>01053 
<a name="l01054"></a>01054 
<a name="l01055"></a><a class="code" href="classBroose.html#ac2bee9148a5c6f7858f1ce900fd8205e">01055</a> <span class="keywordtype">void</span> <a class="code" href="classBroose.html#ac2bee9148a5c6f7858f1ce900fd8205e" title="handles a received Bucket timeout">Broose::handleBucketTimeout</a>(<a class="code" href="classBucketCall.html" title="Class generated from overlay/broose/BrooseMessage.msg by opp_msgc.">BucketCall</a>* msg)
<a name="l01056"></a>01056 {
<a name="l01057"></a>01057     <span class="keywordflow">if</span> (state == READY)
<a name="l01058"></a>01058         <span class="keywordflow">return</span>;
<a name="l01059"></a>01059     <span class="keywordflow">else</span> {
<a name="l01060"></a>01060         bucketRetries++;
<a name="l01061"></a>01061         changeState(INIT);
<a name="l01062"></a>01062     }
<a name="l01063"></a>01063 }
<a name="l01064"></a>01064 
<a name="l01065"></a><a class="code" href="classBroose.html#a0e74d664db69ad2cefde9d3443a36cc6">01065</a> <span class="keywordtype">void</span> <a class="code" href="classBroose.html#a0e74d664db69ad2cefde9d3443a36cc6">Broose::pingResponse</a>(<a class="code" href="classPingResponse.html" title="Class generated from common/CommonMessages.msg by opp_msgc.">PingResponse</a>* pingResponse, cPolymorphic* context,
<a name="l01066"></a>01066                           <span class="keywordtype">int</span> rpcId, simtime_t rtt) {
<a name="l01067"></a>01067     <span class="comment">// if node respond reset failedResponses and add lastSeen to node</span>
<a name="l01068"></a>01068     routingAdd(pingResponse-&gt;<a class="code" href="classBaseRpcMessage.html#ada3e122125cfb5acc7350277ca69c45a">getSrcNode</a>(), <span class="keyword">true</span>, rtt);
<a name="l01069"></a>01069 }
<a name="l01070"></a>01070 
<a name="l01071"></a><a class="code" href="classBroose.html#a813367dd5a82aad256a0cff55192e8eb">01071</a> <span class="keywordtype">void</span> <a class="code" href="classBroose.html#a813367dd5a82aad256a0cff55192e8eb">Broose::routingTimeout</a>(<span class="keyword">const</span> <a class="code" href="classBrooseHandle.html">BrooseHandle</a>&amp; handle)
<a name="l01072"></a>01072 {
<a name="l01073"></a>01073     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; bucketVector.size(); i++) {
<a name="l01074"></a>01074         <span class="keywordflow">if</span> (bucketVector[i]-&gt;getFailedResponses(handle) == numberRetries)
<a name="l01075"></a>01075             bucketVector[i]-&gt;<span class="keyword">remove</span>(handle);
<a name="l01076"></a>01076         <span class="keywordflow">else</span>
<a name="l01077"></a>01077             bucketVector[i]-&gt;increaseFailedResponses(handle);
<a name="l01078"></a>01078     }
<a name="l01079"></a>01079     <span class="comment">// TODO: if we loose the last node (despite ourself) from the</span>
<a name="l01080"></a>01080     <span class="comment">//       B bucket, we should call join() to rejoin the network</span>
<a name="l01081"></a>01081 }
<a name="l01082"></a>01082 
<a name="l01083"></a><a class="code" href="classBroose.html#ac10bba057753a16f4bac89ee8063f5da">01083</a> <span class="keywordtype">void</span> <a class="code" href="classBroose.html#ac10bba057753a16f4bac89ee8063f5da" title="This method is called if an Find Node Call timeout has been reached.">Broose::handleFindNodeTimeout</a>(<a class="code" href="classFindNodeCall.html" title="Class generated from common/CommonMessages.msg by opp_msgc.">FindNodeCall</a>* findNode,
<a name="l01084"></a>01084                                    <span class="keyword">const</span> <a class="code" href="classTransportAddress.html" title="This class implements a common transport address.">TransportAddress</a>&amp; dest,
<a name="l01085"></a>01085                                    <span class="keyword">const</span> <a class="code" href="classOverlayKey.html" title="A common overlay key class.">OverlayKey</a>&amp; destKey)
<a name="l01086"></a>01086 {
<a name="l01087"></a>01087     routingTimeout(dynamic_cast&lt;const NodeHandle&amp;&gt;(dest));
<a name="l01088"></a>01088 }
<a name="l01089"></a>01089 
<a name="l01090"></a><a class="code" href="classBroose.html#aa089c2853d648b0009fcf501f8ec8c7f">01090</a> <span class="keywordtype">void</span> <a class="code" href="classBroose.html#aa089c2853d648b0009fcf501f8ec8c7f">Broose::pingTimeout</a>(<a class="code" href="classPingCall.html" title="Class generated from common/CommonMessages.msg by opp_msgc.">PingCall</a>* pingCall,
<a name="l01091"></a>01091                         <span class="keyword">const</span> <a class="code" href="classTransportAddress.html" title="This class implements a common transport address.">TransportAddress</a>&amp; dest,
<a name="l01092"></a>01092                         cPolymorphic* context, <span class="keywordtype">int</span> rpcId)
<a name="l01093"></a>01093 {
<a name="l01094"></a>01094     routingTimeout(dynamic_cast&lt;const NodeHandle&amp;&gt;(dest));
<a name="l01095"></a>01095 }
<a name="l01096"></a>01096 
<a name="l01097"></a><a class="code" href="classBroose.html#a265144e492745b2832eb6758cbf6385d">01097</a> <span class="keywordtype">bool</span> <a class="code" href="classBroose.html#a265144e492745b2832eb6758cbf6385d" title="Adds a node to the routing table.">Broose::routingAdd</a>(<span class="keyword">const</span> <a class="code" href="classNodeHandle.html" title="This class implements a node handle.">NodeHandle</a>&amp; node, <span class="keywordtype">bool</span> isAlive,
<a name="l01098"></a>01098                         simtime_t rtt)
<a name="l01099"></a>01099 {
<a name="l01100"></a>01100     <span class="keywordtype">bool</span> added = <span class="keyword">false</span>;
<a name="l01101"></a>01101 
<a name="l01102"></a>01102     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; bucketVector.size(); i++) {
<a name="l01103"></a>01103         added |= bucketVector[i]-&gt;add(node, isAlive, rtt);
<a name="l01104"></a>01104     }
<a name="l01105"></a>01105 
<a name="l01106"></a>01106     <span class="keywordflow">return</span> added;
<a name="l01107"></a>01107 }
<a name="l01108"></a>01108 
<a name="l01109"></a><a class="code" href="classBroose.html#afd491170a7241cc14745d18aa2cd904b">01109</a> <span class="keywordtype">void</span> <a class="code" href="classBroose.html#afd491170a7241cc14745d18aa2cd904b" title="updates the timestamp of a node in all buckets">Broose::setLastSeen</a>(<span class="keyword">const</span> <a class="code" href="classNodeHandle.html" title="This class implements a node handle.">NodeHandle</a>&amp; node)
<a name="l01110"></a>01110 {
<a name="l01111"></a>01111     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; bucketVector.size(); i++) {
<a name="l01112"></a>01112         bucketVector[i]-&gt;setLastSeen(node, simTime());
<a name="l01113"></a>01113     }
<a name="l01114"></a>01114 }
<a name="l01115"></a>01115 
<a name="l01116"></a><a class="code" href="classBroose.html#adfc7024ff64b930082b0635a95f4d9e4">01116</a> <span class="keywordtype">void</span> <a class="code" href="classBroose.html#adfc7024ff64b930082b0635a95f4d9e4" title="adds a node to all buckets">Broose::addNode</a>(<span class="keyword">const</span> <a class="code" href="classNodeHandle.html" title="This class implements a node handle.">NodeHandle</a>&amp; node)
<a name="l01117"></a>01117 {
<a name="l01118"></a>01118     <span class="comment">// add node to all buckets</span>
<a name="l01119"></a>01119     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; bucketVector.size(); i++) {
<a name="l01120"></a>01120         bucketVector[i]-&gt;add(node);
<a name="l01121"></a>01121     }
<a name="l01122"></a>01122 }
<a name="l01123"></a>01123 
<a name="l01124"></a><a class="code" href="classBroose.html#a1832a98eeba497ade89b8081d4030ca8">01124</a> <span class="keywordtype">void</span> <a class="code" href="classBroose.html#a1832a98eeba497ade89b8081d4030ca8" title="resets the counter of failed responses">Broose::resetFailedResponses</a>(<span class="keyword">const</span> <a class="code" href="classNodeHandle.html" title="This class implements a node handle.">NodeHandle</a>&amp; node)
<a name="l01125"></a>01125 {
<a name="l01126"></a>01126     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; bucketVector.size(); i++) {
<a name="l01127"></a>01127         bucketVector[i]-&gt;resetFailedResponses(node);
<a name="l01128"></a>01128     }
<a name="l01129"></a>01129 }
<a name="l01130"></a>01130 
<a name="l01131"></a><a class="code" href="classBroose.html#a639a843adbe84e396a016a29c165133e">01131</a> <span class="keywordtype">void</span> <a class="code" href="classBroose.html#a639a843adbe84e396a016a29c165133e" title="sets the rtt to a node in all buckets">Broose::setRTT</a>(<span class="keyword">const</span> <a class="code" href="classNodeHandle.html" title="This class implements a node handle.">NodeHandle</a>&amp; node, simtime_t rtt)
<a name="l01132"></a>01132 {
<a name="l01133"></a>01133     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; bucketVector.size(); i++) {
<a name="l01134"></a>01134         bucketVector[i]-&gt;setRTT(node, rtt);
<a name="l01135"></a>01135     }
<a name="l01136"></a>01136 }
<a name="l01137"></a>01137 
<a name="l01138"></a>01138 
</pre></div></div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="Broose_8cc.html">Broose.cc</a>      </li>

    <li class="footer">Generated on Thu Mar 6 2014 14:06:26 for OverSim by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.5.1 </li>
   </ul>
 </div>


</body>
</html>
