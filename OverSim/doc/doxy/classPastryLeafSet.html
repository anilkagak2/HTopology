<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OverSim: PastryLeafSet Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">OverSim
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classPastryLeafSet.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<div class="title">PastryLeafSet Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="PastryLeafSet" --><!-- doxytag: inherits="PastryStateObject" -->
<p><a class="el" href="classPastryLeafSet.html" title="PastryLeafSet module.">PastryLeafSet</a> module.  
 <a href="classPastryLeafSet.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="PastryLeafSet_8h_source.html">PastryLeafSet.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for PastryLeafSet:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classPastryLeafSet.png" usemap="#PastryLeafSet_map" alt=""/>
  <map id="PastryLeafSet_map" name="PastryLeafSet_map">
<area href="classPastryStateObject.html" title="PastryStateObject Module." alt="PastryStateObject" shape="rect" coords="0,0,113,24"/>
</map>
 </div></div>

<p><a href="classPastryLeafSet-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#aa2c78d769e86e656409342e553c9af0a">initializeSet</a> (uint32_t <a class="el" href="classPastryLeafSet.html#a2b79dd7347229e4661b0b9d34f6909fc">numberOfLeaves</a>, uint32_t <a class="el" href="classPastryStateObject.html#a755bc90b0fb6bd61c42207d17855b743">bitsPerDigit</a>, simtime_t <a class="el" href="classPastryLeafSet.html#a314a62c6e53224ba6de785f5754fcc41">repairTimeout</a>, const <a class="el" href="classNodeHandle.html">NodeHandle</a> &amp;<a class="el" href="classPastryStateObject.html#a946cabf3c3e981122e05bb37bf1c95dc">owner</a>, <a class="el" href="classBasePastry.html">BasePastry</a> *<a class="el" href="classPastryLeafSet.html#a81308a19594555ad39b7a35a26bf0e4f">overlay</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the leaf set.  <a href="#aa2c78d769e86e656409342e553c9af0a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classNodeHandle.html">NodeHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#a8d3bbe87fe682fc513a83df7a0d69f57">getDestinationNode</a> (const <a class="el" href="classOverlayKey.html">OverlayKey</a> &amp;destination)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the final node according to the <a class="el" href="classPastry.html" title="Pastry overlay module.">Pastry</a> routing scheme.  <a href="#a8d3bbe87fe682fc513a83df7a0d69f57"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classNodeHandle.html">NodeHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#ae42c594976b0f7dbc1a24269b3cc6c89">findCloserNode</a> (const <a class="el" href="classOverlayKey.html">OverlayKey</a> &amp;destination, bool optimize=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">try to find a node numerically closer to a given key with the same shared prefix as the current node in the leaf set.  <a href="#ae42c594976b0f7dbc1a24269b3cc6c89"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#a54cf1b5716243dc9ea4f840e3076c720">findCloserNodes</a> (const <a class="el" href="classOverlayKey.html">OverlayKey</a> &amp;destination, <a class="el" href="NodeVector_8h.html#a442f90b66b22aa9fca51f83c5ce1b02b">NodeVector</a> *nodes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classTransportAddress.html">TransportAddress</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#ad691bdd611ba773d5b7a0a90af491498">failedNode</a> (const <a class="el" href="classTransportAddress.html">TransportAddress</a> &amp;failed)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">tells the leafset that a node has failed  <a href="#ad691bdd611ba773d5b7a0a90af491498"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classTransportAddress.html">TransportAddress</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#aee63679544eb8ea21dbbf4d5dc7ef330">repair</a> (const <a class="el" href="classPastryStateMessage.html">PastryStateMessage</a> *msg, const <a class="el" href="structPastryStateMsgProximity.html">PastryStateMsgProximity</a> *prox)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">attempt to repair the leafset using a received REPAIR message  <a href="#aee63679544eb8ea21dbbf4d5dc7ef330"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#aa525adf4fc0334d812fbb70a50b78ca5">isClosestNode</a> (const <a class="el" href="classOverlayKey.html">OverlayKey</a> &amp;destination) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">checks if we are the closest node to key destination in the overlay  <a href="#aa525adf4fc0334d812fbb70a50b78ca5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#a86d0046df97f4d54384d2a0b3936c53e">dumpToStateMessage</a> (<a class="el" href="classPastryStateMessage.html">PastryStateMessage</a> *msg) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">dump content of the set to a <a class="el" href="classPastryStateMessage.html">PastryStateMessage</a>  <a href="#a86d0046df97f4d54384d2a0b3936c53e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classTransportAddress.html">TransportAddress</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#a76dca71b4a758f9aec046e1626b5a42e">getRandomNode</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a random node from the leafset  <a href="#a76dca71b4a758f9aec046e1626b5a42e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#a1e19ba86f8c54fdab06a8aed85a8c95f">mergeNode</a> (const <a class="el" href="classNodeHandle.html">NodeHandle</a> &amp;node, simtime_t prox)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">merge a node into LeafSet  <a href="#a1e19ba86f8c54fdab06a8aed85a8c95f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#a477c57b8227f5ec46a3d635b4590985a">mergeState</a> (const <a class="el" href="classPastryStateMessage.html">PastryStateMessage</a> *msg, const <a class="el" href="structPastryStateMsgProximity.html">PastryStateMsgProximity</a> *prox)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">update own state based on a received <a class="el" href="classPastryStateMessage.html">PastryStateMessage</a>  <a href="#a477c57b8227f5ec46a3d635b4590985a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNodeHandle.html">NodeHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#aa6b310e05c4fd88e015092740665e98f">getPredecessor</a> (void) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">return predecessor node for visualizing  <a href="#aa6b310e05c4fd88e015092740665e98f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNodeHandle.html">NodeHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#ab613105c42c31ecf5b4353a213036b63">getSuccessor</a> (void) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">return successor node for visualizing  <a href="#ab613105c42c31ecf5b4353a213036b63"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#ae13d5a42c50606e3cc0fbcd830429322">isValid</a> (void) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">check if LeafSet knows at least one node to the left and to the right  <a href="#ae13d5a42c50606e3cc0fbcd830429322"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#a529939c1a02749c1b18300404172c6ad">dumpToVector</a> (std::vector&lt; <a class="el" href="classTransportAddress.html">TransportAddress</a> &gt; &amp;affected) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">appends all leaf set entries to a given vector of TransportAddresses, needed to find all Nodes to be notified after joining.  <a href="#a529939c1a02749c1b18300404172c6ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="NodeVector_8h.html#a442f90b66b22aa9fca51f83c5ce1b02b">NodeVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#a8e35d7891d1a32e48fce420555ff2b4d">createSiblingVector</a> (const <a class="el" href="classOverlayKey.html">OverlayKey</a> &amp;key, int numSiblings) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPastryNewLeafsMessage.html">PastryNewLeafsMessage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#a3d51346450731df0d955386d19f45f72">getNewLeafsMessage</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">generates a newLeafs-message if LeafSet changed since last call to this method.  <a href="#a3d51346450731df0d955386d19f45f72"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOverlayKey.html">OverlayKey</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#ab1df380d8c6a16d7ce1cc889bc70abea">estimateMeanDistance</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#a606dbf99943147de93fef16e9bc4bb1f">earlyInit</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">initialize watches etc.  <a href="#a606dbf99943147de93fef16e9bc4bb1f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNodeHandle.html">NodeHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#a5b83a6b8a5ef6ad328b88710ea1164b8">getBiggestNode</a> (void) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">return the node with the biggest key in the LeafSet or <a class="el" href="classNodeHandle.html#a79bf2c5e29c969cbd0b2581cb188d8a6" title="the unspecified NodeHandle">NodeHandle::UNSPECIFIED_NODE</a> if LeafSet is empty  <a href="#a5b83a6b8a5ef6ad328b88710ea1164b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOverlayKey.html">OverlayKey</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#a9b1713cff5c488d9eb918107dd735514">getBiggestKey</a> (void) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">return the biggest key in the LeafSet or <a class="el" href="classOverlayKey.html#ac0d4135dff2985e3582fdbed2a37eb75" title="OverlayKey without defined key.">OverlayKey::UNSPECIFIED_KEY</a> if LeafSet is empty  <a href="#a9b1713cff5c488d9eb918107dd735514"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNodeHandle.html">NodeHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#a95c6d44e09bd76f79a11f097bf05e727">getSmallestNode</a> (void) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">return the node with the smallest key in the LeafSet or <a class="el" href="classNodeHandle.html#a79bf2c5e29c969cbd0b2581cb188d8a6" title="the unspecified NodeHandle">NodeHandle::UNSPECIFIED_NODE</a> if LeafSet is empty  <a href="#a95c6d44e09bd76f79a11f097bf05e727"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOverlayKey.html">OverlayKey</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#a7eae5839ee4ef18bf37984cbc99ce11e">getSmallestKey</a> (void) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">return the smallest key in the LeafSet or <a class="el" href="classOverlayKey.html#ac0d4135dff2985e3582fdbed2a37eb75" title="OverlayKey without defined key.">OverlayKey::UNSPECIFIED_KEY</a> if LeafSet is empty  <a href="#a7eae5839ee4ef18bf37984cbc99ce11e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#aafdca32c4ad0049c6b260ae61cc5a8f5">isLeft</a> (const <a class="el" href="classOverlayKey.html">OverlayKey</a> &amp;key) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">test if a given key should be placed on the left or on the right side of the leaf set  <a href="#aafdca32c4ad0049c6b260ae61cc5a8f5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#ac563e858547e96db005896f8d822d84b">insertLeaf</a> (std::vector&lt; <a class="el" href="classNodeHandle.html">NodeHandle</a> &gt;::iterator &amp;it, const <a class="el" href="classNodeHandle.html">NodeHandle</a> &amp;node)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">insert a leaf at a given position  <a href="#ac563e858547e96db005896f8d822d84b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#aec4b33e2ef0b6bcf7e9803102f5bd174">balanceLeafSet</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#a2b79dd7347229e4661b0b9d34f6909fc">numberOfLeaves</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">simtime_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#a314a62c6e53224ba6de785f5754fcc41">repairTimeout</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBasePastry.html">BasePastry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#a81308a19594555ad39b7a35a26bf0e4f">overlay</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to the main pastry module  <a href="#a81308a19594555ad39b7a35a26bf0e4f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classNodeHandle.html">NodeHandle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classNodeHandle.html">NodeHandle</a> &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#a1b2af0d1e896f6879a5977536499e123">smaller</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classNodeHandle.html">NodeHandle</a> &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#ad7935e96df4a1e07256e1f456f8e57a0">bigger</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="el" href="classTransportAddress.html">TransportAddress</a>, <br class="typebreak"/>
<a class="el" href="structPLSRepairData.html">PLSRepairData</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#ae5272dfe11057414c1651eb4d3eca5ee">awaitingRepair</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#a433ea4e50c2d5f458d5c91c16f6fc8da">newLeafs</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#a603a986ef0e87c7ad4e0f8e23d46adf7">isFull</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPastryLeafSet.html#abb1d399d03a2768881b272ed93f786a4">wasFull</a></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classPastryLeafSet.html" title="PastryLeafSet module.">PastryLeafSet</a> module. </p>
<p>This module contains the LeafSet of the <a class="el" href="classPastry.html" title="Pastry overlay module.">Pastry</a> implementation.</p>
<dl class="author"><dt><b>Author:</b></dt><dd>Felix Palmen, Bernhard Heep </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classPastry.html" title="Pastry overlay module.">Pastry</a> </dd></dl>

<p>Definition at line <a class="el" href="PastryLeafSet_8h_source.html#l00060">60</a> of file <a class="el" href="PastryLeafSet_8h_source.html">PastryLeafSet.h</a>.</p>
</div><hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aec4b33e2ef0b6bcf7e9803102f5bd174"></a><!-- doxytag: member="PastryLeafSet::balanceLeafSet" ref="aec4b33e2ef0b6bcf7e9803102f5bd174" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PastryLeafSet::balanceLeafSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="PastryLeafSet_8cc_source.html#l00407">407</a> of file <a class="el" href="PastryLeafSet_8cc_source.html">PastryLeafSet.cc</a>.</p>

<p>Referenced by <a class="el" href="PastryLeafSet_8cc_source.html#l00521">failedNode()</a>, and <a class="el" href="PastryLeafSet_8cc_source.html#l00323">insertLeaf()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> (<a class="code" href="classPastryLeafSet.html#a603a986ef0e87c7ad4e0f8e23d46adf7">isFull</a> ||
        (!<a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.front().isUnspecified() &amp;&amp;
         !(<a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.end() - 2)-&gt;isUnspecified()) ||
        (!<a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.back().isUnspecified() &amp;&amp;
         !(<a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.begin() + 1)-&gt;isUnspecified()))
        <span class="keywordflow">return</span> <span class="keyword">false</span>;

    std::vector&lt;NodeHandle&gt;::iterator it_left, it_right;

    <span class="keywordflow">for</span> (it_left = <a class="code" href="classPastryLeafSet.html#a1b2af0d1e896f6879a5977536499e123">smaller</a>, it_right = <a class="code" href="classPastryLeafSet.html#ad7935e96df4a1e07256e1f456f8e57a0">bigger</a>;
         it_right != <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.end(); --it_left, ++it_right) {
        <span class="keywordflow">if</span> (it_left-&gt;isUnspecified()) {
            <span class="keywordflow">if</span> (it_right-&gt;isUnspecified() ||
                (it_right + 1) == <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.end() ||
                (it_right + 1)-&gt;isUnspecified()) <span class="keywordflow">return</span> <span class="keyword">false</span>;
            *it_left = *(it_right + 1);
            *(it_right + 1) = <a class="code" href="classNodeHandle.html#a79bf2c5e29c969cbd0b2581cb188d8a6" title="the unspecified NodeHandle">NodeHandle::UNSPECIFIED_NODE</a>;
            <span class="keywordflow">return</span> <span class="keyword">true</span>;
        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (it_right-&gt;isUnspecified()) {

            <span class="keywordflow">if</span> (it_left == <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.begin() ||
                (it_left - 1)-&gt;isUnspecified()) <span class="keywordflow">return</span> <span class="keyword">false</span>;
            *it_right = *(it_left - 1);
            *(it_left - 1) = <a class="code" href="classNodeHandle.html#a79bf2c5e29c969cbd0b2581cb188d8a6" title="the unspecified NodeHandle">NodeHandle::UNSPECIFIED_NODE</a>;
            <span class="keywordflow">return</span> <span class="keyword">true</span>;
        }
    }
    <span class="keywordflow">throw</span> cRuntimeError(<span class="stringliteral">&quot;This should not happen!&quot;</span>);
    <span class="keywordflow">return</span> <span class="keyword">false</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a8e35d7891d1a32e48fce420555ff2b4d"></a><!-- doxytag: member="PastryLeafSet::createSiblingVector" ref="a8e35d7891d1a32e48fce420555ff2b4d" args="(const OverlayKey &amp;key, int numSiblings) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="NodeVector_8h.html#a442f90b66b22aa9fca51f83c5ce1b02b">NodeVector</a> * PastryLeafSet::createSiblingVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOverlayKey.html">OverlayKey</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numSiblings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="PastryLeafSet_8cc_source.html#l00212">212</a> of file <a class="el" href="PastryLeafSet_8cc_source.html">PastryLeafSet.cc</a>.</p>

<p>Referenced by <a class="el" href="BasePastry_8cc_source.html#l00906">BasePastry::findNode()</a>, and <a class="el" href="BasePastry_8cc_source.html#l00742">BasePastry::isSiblingFor()</a>.</p>
<div class="fragment"><pre class="fragment">{
    std::vector&lt;NodeHandle&gt;::const_iterator it;

    <span class="comment">// create temporary comparator</span>
    <a class="code" href="classKeyDistanceComparator.html" title="OverlayKey distance comparator.">KeyDistanceComparator&lt;KeyRingMetric&gt;</a>* comp =
        <span class="keyword">new</span> <a class="code" href="classKeyDistanceComparator.html" title="OverlayKey distance comparator.">KeyDistanceComparator&lt;KeyRingMetric&gt;</a>( key );

    <span class="comment">// create result vector</span>
    <a class="code" href="classBaseKeySortedVector.html" title="A STL-vector that supports inserts sorted by an OverlayKey found somewhere in the type...">NodeVector</a>* result = <span class="keyword">new</span> <a class="code" href="NodeVector_8h.html#a442f90b66b22aa9fca51f83c5ce1b02b">NodeVector</a>( numSiblings, comp );

    result-&gt;add(<a class="code" href="classPastryStateObject.html#a946cabf3c3e981122e05bb37bf1c95dc" title="stores the NodeHandle of the owner of this PastryStateObject.">owner</a>);

    <span class="keywordflow">for</span> (it = <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.begin(); it != <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.end(); it++) {
        <span class="keywordflow">if</span> (!it-&gt;isUnspecified()) {
            result-&gt;add(*it);
        }
    }

    <span class="keyword">delete</span> comp;

    <span class="keywordflow">if</span> (!<a class="code" href="classPastryLeafSet.html#ae13d5a42c50606e3cc0fbcd830429322" title="check if LeafSet knows at least one node to the left and to the right">isValid</a>()) {
        <span class="keywordflow">return</span> result;
    }

    <span class="comment">// if the leafset is not full, we could have a very small network</span>
    <span class="comment">// =&gt; return true (FIXME hack)</span>
    <span class="keywordflow">if</span> (<a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.front().isUnspecified() || <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.back().isUnspecified()) {
        <span class="keywordflow">return</span> result;
    }

    <span class="keywordflow">if</span> ((result-&gt;contains(<a class="code" href="classPastryLeafSet.html#a9b1713cff5c488d9eb918107dd735514" title="return the biggest key in the LeafSet or OverlayKey::UNSPECIFIED_KEY if LeafSet is empty...">getBiggestKey</a>())) ||
        (result-&gt;contains(<a class="code" href="classPastryLeafSet.html#a7eae5839ee4ef18bf37984cbc99ce11e" title="return the smallest key in the LeafSet or OverlayKey::UNSPECIFIED_KEY if LeafSet is empty...">getSmallestKey</a>()))) {
        <span class="keyword">delete</span> result;
        <span class="keywordflow">return</span> NULL;
    }

    <span class="keywordflow">return</span> result;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a86d0046df97f4d54384d2a0b3936c53e"></a><!-- doxytag: member="PastryLeafSet::dumpToStateMessage" ref="a86d0046df97f4d54384d2a0b3936c53e" args="(PastryStateMessage *msg) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PastryLeafSet::dumpToStateMessage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPastryStateMessage.html">PastryStateMessage</a> *&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>dump content of the set to a <a class="el" href="classPastryStateMessage.html">PastryStateMessage</a> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>the <a class="el" href="classPastryStateMessage.html">PastryStateMessage</a> to be filled with entries </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classPastryStateObject.html#a6df4273e063990435c7766cae4f1b83a">PastryStateObject</a>.</p>

<p>Definition at line <a class="el" href="PastryLeafSet_8cc_source.html#l00171">171</a> of file <a class="el" href="PastryLeafSet_8cc_source.html">PastryLeafSet.cc</a>.</p>

<p>Referenced by <a class="el" href="BasePastry_8cc_source.html#l00664">BasePastry::createStateMessage()</a>.</p>
<div class="fragment"><pre class="fragment">{
    uint32_t i = 0;
    uint32_t size = 0;
    std::vector&lt;NodeHandle&gt;::const_iterator it;

    msg-&gt;<a class="code" href="classPastryStateMessage.html#ac3f254bf54612f480dde0eef3a1204bf">setLeafSetArraySize</a>(<a class="code" href="classPastryLeafSet.html#a2b79dd7347229e4661b0b9d34f6909fc">numberOfLeaves</a>);
    <span class="keywordflow">for</span> (it = <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.begin(); it != <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.end(); it++) {
        <span class="keywordflow">if</span> (!it-&gt;isUnspecified()) {
            ++size;
            msg-&gt;<a class="code" href="classPastryStateMessage.html#a8d3948f9d7acca20fd5ca257ca7b45be">setLeafSet</a>(i++, *it);
        }
    }
    msg-&gt;<a class="code" href="classPastryStateMessage.html#ac3f254bf54612f480dde0eef3a1204bf">setLeafSetArraySize</a>(size);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a529939c1a02749c1b18300404172c6ad"></a><!-- doxytag: member="PastryLeafSet::dumpToVector" ref="a529939c1a02749c1b18300404172c6ad" args="(std::vector&lt; TransportAddress &gt; &amp;affected) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PastryLeafSet::dumpToVector </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTransportAddress.html">TransportAddress</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>affected</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>appends all leaf set entries to a given vector of TransportAddresses, needed to find all Nodes to be notified after joining. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">affected</td><td>the vector to fill with leaf set entries </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classPastryStateObject.html#ac677c6c0df6213694165eb3ee912c85e">PastryStateObject</a>.</p>

<p>Definition at line <a class="el" href="PastryLeafSet_8cc_source.html#l00441">441</a> of file <a class="el" href="PastryLeafSet_8cc_source.html">PastryLeafSet.cc</a>.</p>

<p>Referenced by <a class="el" href="Pastry_8cc_source.html#l00161">Pastry::changeState()</a>, and <a class="el" href="BasePastry_8cc_source.html#l01068">BasePastry::getLeafSet()</a>.</p>
<div class="fragment"><pre class="fragment">{
    std::vector&lt;NodeHandle&gt;::const_iterator it;

    <span class="keywordflow">for</span> (it = <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.begin(); it != <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.end(); it++)
        <span class="keywordflow">if</span> (!it-&gt;isUnspecified())
            affected.push_back(*it);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a606dbf99943147de93fef16e9bc4bb1f"></a><!-- doxytag: member="PastryLeafSet::earlyInit" ref="a606dbf99943147de93fef16e9bc4bb1f" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PastryLeafSet::earlyInit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [private, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>initialize watches etc. </p>

<p>Implements <a class="el" href="classPastryStateObject.html#a711a095dc7d08c3ee45c4f8bdaf27fce">PastryStateObject</a>.</p>

<p>Definition at line <a class="el" href="PastryLeafSet_8cc_source.html#l00055">55</a> of file <a class="el" href="PastryLeafSet_8cc_source.html">PastryLeafSet.cc</a>.</p>
<div class="fragment"><pre class="fragment">{
    WATCH_VECTOR(<a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>);
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab1df380d8c6a16d7ce1cc889bc70abea"></a><!-- doxytag: member="PastryLeafSet::estimateMeanDistance" ref="ab1df380d8c6a16d7ce1cc889bc70abea" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOverlayKey.html">OverlayKey</a> PastryLeafSet::estimateMeanDistance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="PastryLeafSet_8cc_source.html#l00645">645</a> of file <a class="el" href="PastryLeafSet_8cc_source.html">PastryLeafSet.cc</a>.</p>

<p>Referenced by <a class="el" href="BasePastry_8cc_source.html#l01103">BasePastry::estimateMeanDistance()</a>.</p>
<div class="fragment"><pre class="fragment">{
    std::vector&lt;OverlayKey&gt; temp;
    <span class="keywordflow">for</span> (uint8_t i = 0; i &lt; <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.size() / 2; ++i) {
        <span class="keywordflow">if</span> (!<a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>[i].isUnspecified()) {
            temp.push_back(<a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>[i].getKey());
        }
    }
    temp.push_back(<a class="code" href="classPastryStateObject.html#a946cabf3c3e981122e05bb37bf1c95dc" title="stores the NodeHandle of the owner of this PastryStateObject.">owner</a>.<a class="code" href="classNodeHandle.html#aef531103cdf07c8353267f4d30a80112" title="returns key of this NodeHandle">getKey</a>());
    <span class="keywordflow">for</span> (uint8_t i = <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.size() / 2; i &lt; <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.size(); ++i) {
        <span class="keywordflow">if</span> (!<a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>[i].isUnspecified()) {
            temp.push_back(<a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>[i].getKey());
        }
    }

    uint8_t num = 2;
    uint8_t l = 1;
    <span class="keywordflow">while</span> (num &lt; temp.size()) {
        num *= 2;
        ++l;
    }
    num /= 2;
    --l;


    <a class="code" href="classOverlayKey.html" title="A common overlay key class.">OverlayKey</a> mean = <a class="code" href="classOverlayKey.html#a7fb11c90a3ce70d71025ffbbe195bf80" title="OverlayKey with key initialized as 0.">OverlayKey::ZERO</a>;
    <span class="keywordflow">for</span> (uint8_t i = 0; i &lt; num; ++i) {
        <span class="comment">//distances.push_back(KeyRingMetric().distance(temp[i], temp[i+1]));</span>
        mean += (<a class="code" href="classKeyRingMetric.html" title="OverlayKey Ring Metric.">KeyRingMetric</a>().<a class="code" href="classKeyRingMetric.html#a85547c6014f59c334c6d64d227049094" title="calculates the distance from x to y on a bidirectional ring">distance</a>(temp[i], temp[i+1]) &gt;&gt; l);
    }

    <span class="keywordflow">return</span> mean;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad691bdd611ba773d5b7a0a90af491498"></a><!-- doxytag: member="PastryLeafSet::failedNode" ref="ad691bdd611ba773d5b7a0a90af491498" args="(const TransportAddress &amp;failed)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTransportAddress.html">TransportAddress</a> &amp; PastryLeafSet::failedNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTransportAddress.html">TransportAddress</a> &amp;&#160;</td>
          <td class="paramname"><em>failed</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>tells the leafset that a node has failed </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">failed</td><td>the failed node </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a node to ask for REPAIR or <a class="el" href="classTransportAddress.html#ac1709545db722cbbce1367034142d31f" title="TransportAddress without specified ip and port.">TransportAddress::UNSPECIFIED_NODE</a> </dd></dl>

<p>Implements <a class="el" href="classPastryStateObject.html#aac3ee89c4129465def00861424f232e3">PastryStateObject</a>.</p>

<p>Definition at line <a class="el" href="PastryLeafSet_8cc_source.html#l00521">521</a> of file <a class="el" href="PastryLeafSet_8cc_source.html">PastryLeafSet.cc</a>.</p>

<p>Referenced by <a class="el" href="Bamboo_8cc_source.html#l00299">Bamboo::handleFailedNode()</a>, and <a class="el" href="Pastry_8cc_source.html#l00886">Pastry::handleFailedNode()</a>.</p>
<div class="fragment"><pre class="fragment">{
    std::vector&lt;NodeHandle&gt;::iterator i;
    <span class="keyword">const</span> <a class="code" href="classTransportAddress.html" title="This class implements a common transport address.">TransportAddress</a>* ask;
    <span class="keywordtype">bool</span> left = <span class="keyword">true</span>;

    <span class="comment">// search failed node in leafset:</span>
    <span class="keywordflow">for</span> (i = <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.begin(); i != <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.end(); i++) {
        <span class="keywordflow">if</span> (i == <a class="code" href="classPastryLeafSet.html#ad7935e96df4a1e07256e1f456f8e57a0">bigger</a>) left = <span class="keyword">false</span>;
        <span class="keywordflow">if</span> ((! i-&gt;isUnspecified()) &amp;&amp; (i-&gt;getIp() == failed.<a class="code" href="classTransportAddress.html#a00e613d98d3412e2b92897c25aa0eb4c" title="returns ip address">getIp</a>())) <span class="keywordflow">break</span>;
    }

    <span class="comment">// failed node not in leafset:</span>
    <span class="keywordflow">if</span> (i == <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.end()) <span class="keywordflow">return</span> <a class="code" href="classTransportAddress.html#ac1709545db722cbbce1367034142d31f" title="TransportAddress without specified ip and port.">TransportAddress::UNSPECIFIED_NODE</a>;

    <a class="code" href="classPastryLeafSet.html#a81308a19594555ad39b7a35a26bf0e4f" title="pointer to the main pastry module">overlay</a>-&gt;<a class="code" href="classBaseOverlay.html#a1422696a8eb138dde850390152ff88c7" title="Informs application about state changes of nodes or newly joined nodes.">callUpdate</a>(*i, <span class="keyword">false</span>);

    <span class="comment">// remove failed node:</span>
    <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.erase(i);
    <a class="code" href="classPastryLeafSet.html#a433ea4e50c2d5f458d5c91c16f6fc8da">newLeafs</a> = <span class="keyword">true</span>;

    <a class="code" href="classPastryLeafSet.html#abb1d399d03a2768881b272ed93f786a4">wasFull</a> = <a class="code" href="classPastryLeafSet.html#a603a986ef0e87c7ad4e0f8e23d46adf7">isFull</a>;
    <a class="code" href="classPastryLeafSet.html#a603a986ef0e87c7ad4e0f8e23d46adf7">isFull</a> = <span class="keyword">false</span>;

    <span class="comment">// insert UNSPECIFIED_NODE at front or back and return correct node</span>
    <span class="comment">// to ask for repair:</span>
    <span class="keywordflow">if</span> (left) {
        <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.insert(<a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.begin(), <a class="code" href="classNodeHandle.html#a79bf2c5e29c969cbd0b2581cb188d8a6" title="the unspecified NodeHandle">NodeHandle::UNSPECIFIED_NODE</a>);
        <a class="code" href="classPastryLeafSet.html#ad7935e96df4a1e07256e1f456f8e57a0">bigger</a> = <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.begin() + (<a class="code" href="classPastryLeafSet.html#a2b79dd7347229e4661b0b9d34f6909fc">numberOfLeaves</a> &gt;&gt; 1);
        <a class="code" href="classPastryLeafSet.html#a1b2af0d1e896f6879a5977536499e123">smaller</a> = <a class="code" href="classPastryLeafSet.html#ad7935e96df4a1e07256e1f456f8e57a0">bigger</a> - 1;
        ask = <span class="keyword">static_cast&lt;</span><span class="keyword">const </span><a class="code" href="classTransportAddress.html" title="This class implements a common transport address.">TransportAddress</a>*<span class="keyword">&gt;</span>(&amp;(<a class="code" href="classPastryLeafSet.html#a95c6d44e09bd76f79a11f097bf05e727" title="return the node with the smallest key in the LeafSet or NodeHandle::UNSPECIFIED_NODE if LeafSet is em...">getSmallestNode</a>()));
    } <span class="keywordflow">else</span> {
        <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.push_back(<a class="code" href="classNodeHandle.html#a79bf2c5e29c969cbd0b2581cb188d8a6" title="the unspecified NodeHandle">NodeHandle::UNSPECIFIED_NODE</a>);
        <a class="code" href="classPastryLeafSet.html#ad7935e96df4a1e07256e1f456f8e57a0">bigger</a> = <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.begin() + (<a class="code" href="classPastryLeafSet.html#a2b79dd7347229e4661b0b9d34f6909fc">numberOfLeaves</a> &gt;&gt; 1);
        <a class="code" href="classPastryLeafSet.html#a1b2af0d1e896f6879a5977536499e123">smaller</a> = <a class="code" href="classPastryLeafSet.html#ad7935e96df4a1e07256e1f456f8e57a0">bigger</a> - 1;
        ask = <span class="keyword">static_cast&lt;</span><span class="keyword">const </span><a class="code" href="classTransportAddress.html" title="This class implements a common transport address.">TransportAddress</a>*<span class="keyword">&gt;</span>(&amp;(<a class="code" href="classPastryLeafSet.html#a5b83a6b8a5ef6ad328b88710ea1164b8" title="return the node with the biggest key in the LeafSet or NodeHandle::UNSPECIFIED_NODE if LeafSet is emp...">getBiggestNode</a>()));
    }

    assert(ask-&gt;<a class="code" href="classTransportAddress.html#a026e777c423ff2a0280edd2fa5472e74" title="indicates if TransportAddress is specified">isUnspecified</a>() || *ask != <a class="code" href="classPastryLeafSet.html#a81308a19594555ad39b7a35a26bf0e4f" title="pointer to the main pastry module">overlay</a>-&gt;<a class="code" href="classBaseRpc.html#ac3f420630d5618e81709c078b06fd9da" title="Returns the NodeHandle of this node.">getThisNode</a>());

    <a class="code" href="classPastryLeafSet.html#aec4b33e2ef0b6bcf7e9803102f5bd174">balanceLeafSet</a>();
    <a class="code" href="PastryLeafSet_8cc.html#a2b96f0bd3a00d62f9b701dde3155f44a">LEAF_TEST</a>();

    assert(ask-&gt;<a class="code" href="classTransportAddress.html#a026e777c423ff2a0280edd2fa5472e74" title="indicates if TransportAddress is specified">isUnspecified</a>() || *ask != <a class="code" href="classPastryLeafSet.html#a81308a19594555ad39b7a35a26bf0e4f" title="pointer to the main pastry module">overlay</a>-&gt;<a class="code" href="classBaseRpc.html#ac3f420630d5618e81709c078b06fd9da" title="Returns the NodeHandle of this node.">getThisNode</a>());

    <span class="keywordflow">if</span> (! ask-&gt;<a class="code" href="classTransportAddress.html#a026e777c423ff2a0280edd2fa5472e74" title="indicates if TransportAddress is specified">isUnspecified</a>())
        <a class="code" href="classPastryLeafSet.html#ae5272dfe11057414c1651eb4d3eca5ee">awaitingRepair</a>[*ask] = <a class="code" href="structPLSRepairData.html" title="struct for tracking repair requests">PLSRepairData</a>(simTime(), left);

    <span class="keywordflow">return</span> *ask;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae42c594976b0f7dbc1a24269b3cc6c89"></a><!-- doxytag: member="PastryLeafSet::findCloserNode" ref="ae42c594976b0f7dbc1a24269b3cc6c89" args="(const OverlayKey &amp;destination, bool optimize=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNodeHandle.html">NodeHandle</a> &amp; PastryLeafSet::findCloserNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOverlayKey.html">OverlayKey</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>optimize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>try to find a node numerically closer to a given key with the same shared prefix as the current node in the leaf set. </p>
<p>this method is to be called, when a regular next hop couldn't be found or wasn't reachable.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>the destination key </td></tr>
    <tr><td class="paramname">optimize</td><td>if set, check all nodes and return the best/closest one </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a closer <a class="el" href="classNodeHandle.html" title="This class implements a node handle.">NodeHandle</a> or <a class="el" href="classNodeHandle.html#a79bf2c5e29c969cbd0b2581cb188d8a6" title="the unspecified NodeHandle">NodeHandle::UNSPECIFIED_NODE</a> if none was found </dd></dl>

<p>Implements <a class="el" href="classPastryStateObject.html#a5bc159769dfdcd95ceaaf6055798b743">PastryStateObject</a>.</p>

<p>Definition at line <a class="el" href="PastryLeafSet_8cc_source.html#l00492">492</a> of file <a class="el" href="PastryLeafSet_8cc_source.html">PastryLeafSet.cc</a>.</p>

<p>Referenced by <a class="el" href="BasePastry_8cc_source.html#l00906">BasePastry::findNode()</a>.</p>
<div class="fragment"><pre class="fragment">{
    std::vector&lt;NodeHandle&gt;::const_iterator i;
    <span class="keyword">const</span> <a class="code" href="classNodeHandle.html" title="This class implements a node handle.">NodeHandle</a>* ret = &amp;<a class="code" href="classNodeHandle.html#a79bf2c5e29c969cbd0b2581cb188d8a6" title="the unspecified NodeHandle">NodeHandle::UNSPECIFIED_NODE</a>;

    <span class="comment">// this will only be called after getDestinationNode() returned</span>
    <span class="comment">// NodeHandle::UNSPECIFIED_NODE, so a closer Node can only be the biggest</span>
    <span class="comment">// or the smallest node in the LeafSet.</span>

    <span class="keyword">const</span> <a class="code" href="classNodeHandle.html" title="This class implements a node handle.">NodeHandle</a>&amp; smallest = <a class="code" href="classPastryLeafSet.html#a95c6d44e09bd76f79a11f097bf05e727" title="return the node with the smallest key in the LeafSet or NodeHandle::UNSPECIFIED_NODE if LeafSet is em...">getSmallestNode</a>();
    <span class="keyword">const</span> <a class="code" href="classNodeHandle.html" title="This class implements a node handle.">NodeHandle</a>&amp; biggest = <a class="code" href="classPastryLeafSet.html#a5b83a6b8a5ef6ad328b88710ea1164b8" title="return the node with the biggest key in the LeafSet or NodeHandle::UNSPECIFIED_NODE if LeafSet is emp...">getBiggestNode</a>();

    <span class="keywordflow">if</span> ((!smallest.<a class="code" href="classNodeHandle.html#ab5136375a4548ced7c2014a73c8743c9" title="indicates if this NodeHandle is specified">isUnspecified</a>()) &amp;&amp;
            (<a class="code" href="classPastryStateObject.html#a13a6c5fdcbe191dc45619aeaa29f1993" title="test a given NodeHandle if it is closer to a given destination, but only if the shared prefix length ...">specialCloserCondition</a>(smallest, destination, *ret))) {
        <span class="keywordflow">if</span> (optimize) ret = &amp;smallest;
        <span class="keywordflow">else</span> <span class="keywordflow">return</span> smallest;
    }

    <span class="keywordflow">if</span> ((!biggest.<a class="code" href="classNodeHandle.html#ab5136375a4548ced7c2014a73c8743c9" title="indicates if this NodeHandle is specified">isUnspecified</a>()) &amp;&amp;
            (<a class="code" href="classPastryStateObject.html#a13a6c5fdcbe191dc45619aeaa29f1993" title="test a given NodeHandle if it is closer to a given destination, but only if the shared prefix length ...">specialCloserCondition</a>(biggest, destination, *ret))) {
        <span class="keywordflow">if</span> (optimize) ret = &amp;biggest;
        <span class="keywordflow">else</span> <span class="keywordflow">return</span> biggest;
    }

    <span class="keywordflow">return</span> *ret;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a54cf1b5716243dc9ea4f840e3076c720"></a><!-- doxytag: member="PastryLeafSet::findCloserNodes" ref="a54cf1b5716243dc9ea4f840e3076c720" args="(const OverlayKey &amp;destination, NodeVector *nodes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PastryLeafSet::findCloserNodes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOverlayKey.html">OverlayKey</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="NodeVector_8h.html#a442f90b66b22aa9fca51f83c5ce1b02b">NodeVector</a> *&#160;</td>
          <td class="paramname"><em>nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classPastryStateObject.html#a5255b15a989fb6f61403760383618375">PastryStateObject</a>.</p>

<p>Definition at line <a class="el" href="PastryLeafSet_8cc_source.html#l00481">481</a> of file <a class="el" href="PastryLeafSet_8cc_source.html">PastryLeafSet.cc</a>.</p>

<p>Referenced by <a class="el" href="BasePastry_8cc_source.html#l00906">BasePastry::findNode()</a>.</p>
<div class="fragment"><pre class="fragment">{
    std::vector&lt;NodeHandle&gt;::const_iterator it;

    <span class="keywordflow">for</span> (it = <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.begin(); it != <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.end(); it++)
        <span class="keywordflow">if</span> (!it-&gt;isUnspecified())
            nodes-&gt;<a class="code" href="classBaseKeySortedVector.html#afbcdfbd9680a475cceb48ccc841140cd" title="adds an element of type T in increasing order to the NodeVector and returns the position of the added...">add</a>(*it);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a9b1713cff5c488d9eb918107dd735514"></a><!-- doxytag: member="PastryLeafSet::getBiggestKey" ref="a9b1713cff5c488d9eb918107dd735514" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOverlayKey.html">OverlayKey</a> &amp; PastryLeafSet::getBiggestKey </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>return the biggest key in the LeafSet or <a class="el" href="classOverlayKey.html#ac0d4135dff2985e3582fdbed2a37eb75" title="OverlayKey without defined key.">OverlayKey::UNSPECIFIED_KEY</a> if LeafSet is empty </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>biggest key in the set </dd></dl>

<p>Definition at line <a class="el" href="PastryLeafSet_8cc_source.html#l00475">475</a> of file <a class="el" href="PastryLeafSet_8cc_source.html">PastryLeafSet.cc</a>.</p>

<p>Referenced by <a class="el" href="PastryLeafSet_8cc_source.html#l00212">createSiblingVector()</a>, and <a class="el" href="PastryLeafSet_8cc_source.html#l00113">getDestinationNode()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">return</span> <a class="code" href="classPastryLeafSet.html#a5b83a6b8a5ef6ad328b88710ea1164b8" title="return the node with the biggest key in the LeafSet or NodeHandle::UNSPECIFIED_NODE if LeafSet is emp...">getBiggestNode</a>().<a class="code" href="classNodeHandle.html#aef531103cdf07c8353267f4d30a80112" title="returns key of this NodeHandle">getKey</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="a5b83a6b8a5ef6ad328b88710ea1164b8"></a><!-- doxytag: member="PastryLeafSet::getBiggestNode" ref="a5b83a6b8a5ef6ad328b88710ea1164b8" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNodeHandle.html">NodeHandle</a> &amp; PastryLeafSet::getBiggestNode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>return the node with the biggest key in the LeafSet or <a class="el" href="classNodeHandle.html#a79bf2c5e29c969cbd0b2581cb188d8a6" title="the unspecified NodeHandle">NodeHandle::UNSPECIFIED_NODE</a> if LeafSet is empty </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>biggest node in the set </dd></dl>

<p>Definition at line <a class="el" href="PastryLeafSet_8cc_source.html#l00466">466</a> of file <a class="el" href="PastryLeafSet_8cc_source.html">PastryLeafSet.cc</a>.</p>

<p>Referenced by <a class="el" href="PastryLeafSet_8cc_source.html#l00521">failedNode()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00492">findCloserNode()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00475">getBiggestKey()</a>, and <a class="el" href="PastryLeafSet_8cc_source.html#l00573">repair()</a>.</p>
<div class="fragment"><pre class="fragment">{
    std::vector&lt;NodeHandle&gt;::const_iterator i = <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.end()-1;
    <span class="keywordflow">while</span> ((i-&gt;isUnspecified()) &amp;&amp; (i != <a class="code" href="classPastryLeafSet.html#ad7935e96df4a1e07256e1f456f8e57a0">bigger</a>)) i--;
    assert(i-&gt;isUnspecified() || *i != <a class="code" href="classPastryLeafSet.html#a81308a19594555ad39b7a35a26bf0e4f" title="pointer to the main pastry module">overlay</a>-&gt;<a class="code" href="classBaseRpc.html#ac3f420630d5618e81709c078b06fd9da" title="Returns the NodeHandle of this node.">getThisNode</a>());
    <span class="keywordflow">return</span> *i;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a8d3bbe87fe682fc513a83df7a0d69f57"></a><!-- doxytag: member="PastryLeafSet::getDestinationNode" ref="a8d3bbe87fe682fc513a83df7a0d69f57" args="(const OverlayKey &amp;destination)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNodeHandle.html">NodeHandle</a> &amp; PastryLeafSet::getDestinationNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOverlayKey.html">OverlayKey</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>gets the final node according to the <a class="el" href="classPastry.html" title="Pastry overlay module.">Pastry</a> routing scheme. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>the destination key </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the <a class="el" href="classNodeHandle.html" title="This class implements a node handle.">NodeHandle</a> of the final node or <a class="el" href="classNodeHandle.html#a79bf2c5e29c969cbd0b2581cb188d8a6" title="the unspecified NodeHandle">NodeHandle::UNSPECIFIED_NODE</a> if given destination key is outside the leaf set </dd></dl>

<p>Reimplemented from <a class="el" href="classPastryStateObject.html#a6837869040021974c136f43630a563b2">PastryStateObject</a>.</p>

<p>Definition at line <a class="el" href="PastryLeafSet_8cc_source.html#l00113">113</a> of file <a class="el" href="PastryLeafSet_8cc_source.html">PastryLeafSet.cc</a>.</p>

<p>Referenced by <a class="el" href="BasePastry_8cc_source.html#l00906">BasePastry::findNode()</a>.</p>
<div class="fragment"><pre class="fragment">{
    std::vector&lt;NodeHandle&gt;::const_iterator i;
    <span class="keyword">const</span> <a class="code" href="classOverlayKey.html" title="A common overlay key class.">OverlayKey</a>* smallest;
    <span class="keyword">const</span> <a class="code" href="classOverlayKey.html" title="A common overlay key class.">OverlayKey</a>* biggest;
    <span class="keyword">const</span> <a class="code" href="classNodeHandle.html" title="This class implements a node handle.">NodeHandle</a>* ret = &amp;<a class="code" href="classNodeHandle.html#a79bf2c5e29c969cbd0b2581cb188d8a6" title="the unspecified NodeHandle">NodeHandle::UNSPECIFIED_NODE</a>;

    <span class="comment">// check whether destination is inside leafSet:</span>

    smallest = &amp;(<a class="code" href="classPastryLeafSet.html#a7eae5839ee4ef18bf37984cbc99ce11e" title="return the smallest key in the LeafSet or OverlayKey::UNSPECIFIED_KEY if LeafSet is empty...">getSmallestKey</a>());
    biggest = &amp;(<a class="code" href="classPastryLeafSet.html#a9b1713cff5c488d9eb918107dd735514" title="return the biggest key in the LeafSet or OverlayKey::UNSPECIFIED_KEY if LeafSet is empty...">getBiggestKey</a>());
    <span class="keywordflow">if</span> (smallest-&gt;<a class="code" href="classOverlayKey.html#abe357a4d1babcf7d30598a61cbc0f5c2" title="Returns true, if the key is unspecified.">isUnspecified</a>()) smallest = &amp;(<a class="code" href="classPastryStateObject.html#a946cabf3c3e981122e05bb37bf1c95dc" title="stores the NodeHandle of the owner of this PastryStateObject.">owner</a>.<a class="code" href="classNodeHandle.html#aef531103cdf07c8353267f4d30a80112" title="returns key of this NodeHandle">getKey</a>());
    <span class="keywordflow">if</span> (biggest-&gt;<a class="code" href="classOverlayKey.html#abe357a4d1babcf7d30598a61cbc0f5c2" title="Returns true, if the key is unspecified.">isUnspecified</a>()) biggest = &amp;(<a class="code" href="classPastryStateObject.html#a946cabf3c3e981122e05bb37bf1c95dc" title="stores the NodeHandle of the owner of this PastryStateObject.">owner</a>.<a class="code" href="classNodeHandle.html#aef531103cdf07c8353267f4d30a80112" title="returns key of this NodeHandle">getKey</a>());

    <span class="keywordflow">if</span> (!destination.<a class="code" href="classOverlayKey.html#af35313562131a78724e31297889be822" title="Returns true, if this key is element of the interval [keyA, keyB] on the ring.">isBetweenLR</a>(*smallest, *biggest)) <span class="keywordflow">return</span> *ret;

    <span class="comment">// find the closest node:</span>

    <span class="keywordflow">for</span> (i = <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.begin(); i != <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.end(); i++) {
        <span class="keywordflow">if</span> (i-&gt;isUnspecified()) <span class="keywordflow">continue</span>;

        <span class="comment">// note for next line:</span>
        <span class="comment">// * dereferences iterator, &amp; gets address of element.</span>
        <span class="keywordflow">if</span> (<a class="code" href="classPastryStateObject.html#ace8eed35caedb59412a49132c4538917" title="test a given NodeHandle if it is closer to a given destination">isCloser</a>(*i, destination, *ret)) ret = &amp;(*i);
    }

    <span class="keywordflow">return</span> *ret;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a3d51346450731df0d955386d19f45f72"></a><!-- doxytag: member="PastryLeafSet::getNewLeafsMessage" ref="a3d51346450731df0d955386d19f45f72" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPastryNewLeafsMessage.html">PastryNewLeafsMessage</a> * PastryLeafSet::getNewLeafsMessage </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>generates a newLeafs-message if LeafSet changed since last call to this method. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to newLeafs-message or NULL </dd></dl>

<p>Definition at line <a class="el" href="PastryLeafSet_8cc_source.html#l00625">625</a> of file <a class="el" href="PastryLeafSet_8cc_source.html">PastryLeafSet.cc</a>.</p>

<p>Referenced by <a class="el" href="BasePastry_8cc_source.html#l00258">BasePastry::newLeafs()</a>.</p>
<div class="fragment"><pre class="fragment">{
    std::vector&lt;NodeHandle&gt;::const_iterator it;
    <a class="code" href="classPastryNewLeafsMessage.html" title="Class generated from overlay/pastry/PastryMessage.msg by opp_msgc.">PastryNewLeafsMessage</a>* msg;
    uint32_t i = 0;

    <span class="keywordflow">if</span> (! <a class="code" href="classPastryLeafSet.html#a433ea4e50c2d5f458d5c91c16f6fc8da">newLeafs</a>) <span class="keywordflow">return</span> NULL;
    <a class="code" href="classPastryLeafSet.html#a433ea4e50c2d5f458d5c91c16f6fc8da">newLeafs</a> = <span class="keyword">false</span>;

    msg = <span class="keyword">new</span> <a class="code" href="classPastryNewLeafsMessage.html" title="Class generated from overlay/pastry/PastryMessage.msg by opp_msgc.">PastryNewLeafsMessage</a>(<span class="stringliteral">&quot;PastryNewLeafs&quot;</span>);

    msg-&gt;<a class="code" href="classPastryNewLeafsMessage.html#ac7fb420b7b5be4e2b6d16a2ac58678c0">setLeafsArraySize</a>(<a class="code" href="classPastryLeafSet.html#a2b79dd7347229e4661b0b9d34f6909fc">numberOfLeaves</a>);
    <span class="keywordflow">for</span> (it = <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.begin(); it != <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.end(); it++)
        msg-&gt;<a class="code" href="classPastryNewLeafsMessage.html#aa55343ba7ecfc200aa57134d899ed4be">setLeafs</a>(i++, *it);

    msg-&gt;setBitLength(<a class="code" href="PastryMessage__m_8h.html#a811621e4068a33905b600d418168fae8">PASTRYNEWLEAFS_L</a>(msg));
    <span class="keywordflow">return</span> msg;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa6b310e05c4fd88e015092740665e98f"></a><!-- doxytag: member="PastryLeafSet::getPredecessor" ref="aa6b310e05c4fd88e015092740665e98f" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNodeHandle.html">NodeHandle</a> &amp; PastryLeafSet::getPredecessor </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>return predecessor node for visualizing </p>

<p>Definition at line <a class="el" href="PastryLeafSet_8cc_source.html#l00101">101</a> of file <a class="el" href="PastryLeafSet_8cc_source.html">PastryLeafSet.cc</a>.</p>

<p>Referenced by <a class="el" href="BasePastry_8cc_source.html#l00785">BasePastry::updateTooltip()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">return</span> *<a class="code" href="classPastryLeafSet.html#a1b2af0d1e896f6879a5977536499e123">smaller</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a76dca71b4a758f9aec046e1626b5a42e"></a><!-- doxytag: member="PastryLeafSet::getRandomNode" ref="a76dca71b4a758f9aec046e1626b5a42e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTransportAddress.html">TransportAddress</a> &amp; PastryLeafSet::getRandomNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns a random node from the leafset </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a random node or <a class="el" href="classTransportAddress.html#ac1709545db722cbbce1367034142d31f" title="TransportAddress without specified ip and port.">TransportAddress::UNSPECIFIED_NODE</a> </dd></dl>

<p>Definition at line <a class="el" href="PastryLeafSet_8cc_source.html#l00188">188</a> of file <a class="el" href="PastryLeafSet_8cc_source.html">PastryLeafSet.cc</a>.</p>

<p>Referenced by <a class="el" href="Bamboo_8cc_source.html#l00202">Bamboo::doLeafsetMaintenance()</a>.</p>
<div class="fragment"><pre class="fragment">{
    uint32_t rnd;
    <span class="keywordtype">int</span> i;

    rnd = intuniform(0, <a class="code" href="classPastryLeafSet.html#a2b79dd7347229e4661b0b9d34f6909fc">numberOfLeaves</a> - 1, 0);
    i = rnd;

    <span class="keywordflow">while</span> (i &lt; (<span class="keywordtype">int</span>)<a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.size()) {
        <span class="keywordflow">if</span> (!<a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>[i].isUnspecified()) <span class="keywordflow">return</span> <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>[i];
        <span class="keywordflow">else</span> i++;
    }
    i = rnd;
    <span class="keywordflow">while</span> (i &gt;= 0) {
        <span class="keywordflow">if</span> (!<a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>[i].isUnspecified()) <span class="keywordflow">return</span> <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>[i];
        <span class="keywordflow">else</span> i--;
    }
    EV &lt;&lt; <span class="stringliteral">&quot;Leafset::getRandomNode() returns UNSPECIFIED_NODE&quot;</span>
          <span class="stringliteral">&quot;Leafset empty??&quot;</span> &lt;&lt; endl;

    <span class="keywordflow">return</span> <a class="code" href="classTransportAddress.html#ac1709545db722cbbce1367034142d31f" title="TransportAddress without specified ip and port.">TransportAddress::UNSPECIFIED_NODE</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a7eae5839ee4ef18bf37984cbc99ce11e"></a><!-- doxytag: member="PastryLeafSet::getSmallestKey" ref="a7eae5839ee4ef18bf37984cbc99ce11e" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOverlayKey.html">OverlayKey</a> &amp; PastryLeafSet::getSmallestKey </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>return the smallest key in the LeafSet or <a class="el" href="classOverlayKey.html#ac0d4135dff2985e3582fdbed2a37eb75" title="OverlayKey without defined key.">OverlayKey::UNSPECIFIED_KEY</a> if LeafSet is empty </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>smallest key in the set </dd></dl>

<p>Definition at line <a class="el" href="PastryLeafSet_8cc_source.html#l00460">460</a> of file <a class="el" href="PastryLeafSet_8cc_source.html">PastryLeafSet.cc</a>.</p>

<p>Referenced by <a class="el" href="PastryLeafSet_8cc_source.html#l00212">createSiblingVector()</a>, and <a class="el" href="PastryLeafSet_8cc_source.html#l00113">getDestinationNode()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">return</span> <a class="code" href="classPastryLeafSet.html#a95c6d44e09bd76f79a11f097bf05e727" title="return the node with the smallest key in the LeafSet or NodeHandle::UNSPECIFIED_NODE if LeafSet is em...">getSmallestNode</a>().<a class="code" href="classNodeHandle.html#aef531103cdf07c8353267f4d30a80112" title="returns key of this NodeHandle">getKey</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="a95c6d44e09bd76f79a11f097bf05e727"></a><!-- doxytag: member="PastryLeafSet::getSmallestNode" ref="a95c6d44e09bd76f79a11f097bf05e727" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNodeHandle.html">NodeHandle</a> &amp; PastryLeafSet::getSmallestNode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>return the node with the smallest key in the LeafSet or <a class="el" href="classNodeHandle.html#a79bf2c5e29c969cbd0b2581cb188d8a6" title="the unspecified NodeHandle">NodeHandle::UNSPECIFIED_NODE</a> if LeafSet is empty </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>smallest node in the set </dd></dl>

<p>Definition at line <a class="el" href="PastryLeafSet_8cc_source.html#l00451">451</a> of file <a class="el" href="PastryLeafSet_8cc_source.html">PastryLeafSet.cc</a>.</p>

<p>Referenced by <a class="el" href="PastryLeafSet_8cc_source.html#l00521">failedNode()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00492">findCloserNode()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00460">getSmallestKey()</a>, and <a class="el" href="PastryLeafSet_8cc_source.html#l00573">repair()</a>.</p>
<div class="fragment"><pre class="fragment">{
    std::vector&lt;NodeHandle&gt;::const_iterator i = <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.begin();
    <span class="keywordflow">while</span> ((i-&gt;isUnspecified()) &amp;&amp; (i != <a class="code" href="classPastryLeafSet.html#a1b2af0d1e896f6879a5977536499e123">smaller</a>)) i++;
    assert(i-&gt;isUnspecified() || *i != <a class="code" href="classPastryLeafSet.html#a81308a19594555ad39b7a35a26bf0e4f" title="pointer to the main pastry module">overlay</a>-&gt;<a class="code" href="classBaseRpc.html#ac3f420630d5618e81709c078b06fd9da" title="Returns the NodeHandle of this node.">getThisNode</a>());
    <span class="keywordflow">return</span> *i;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab613105c42c31ecf5b4353a213036b63"></a><!-- doxytag: member="PastryLeafSet::getSuccessor" ref="ab613105c42c31ecf5b4353a213036b63" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNodeHandle.html">NodeHandle</a> &amp; PastryLeafSet::getSuccessor </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>return successor node for visualizing </p>

<p>Definition at line <a class="el" href="PastryLeafSet_8cc_source.html#l00095">95</a> of file <a class="el" href="PastryLeafSet_8cc_source.html">PastryLeafSet.cc</a>.</p>

<p>Referenced by <a class="el" href="BasePastry_8cc_source.html#l00785">BasePastry::updateTooltip()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">return</span> *<a class="code" href="classPastryLeafSet.html#ad7935e96df4a1e07256e1f456f8e57a0">bigger</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa2c78d769e86e656409342e553c9af0a"></a><!-- doxytag: member="PastryLeafSet::initializeSet" ref="aa2c78d769e86e656409342e553c9af0a" args="(uint32_t numberOfLeaves, uint32_t bitsPerDigit, simtime_t repairTimeout, const NodeHandle &amp;owner, BasePastry *overlay)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PastryLeafSet::initializeSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numberOfLeaves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bitsPerDigit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">simtime_t&#160;</td>
          <td class="paramname"><em>repairTimeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classNodeHandle.html">NodeHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>owner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBasePastry.html">BasePastry</a> *&#160;</td>
          <td class="paramname"><em>overlay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initializes the leaf set. </p>
<p>This should be called on startup</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">numberOfLeaves</td><td><a class="el" href="classPastry.html" title="Pastry overlay module.">Pastry</a> configuration parameter </td></tr>
    <tr><td class="paramname">bitsPerDigit</td><td>number of bits per digits </td></tr>
    <tr><td class="paramname">repairTimeout</td><td><a class="el" href="classPastry.html" title="Pastry overlay module.">Pastry</a> configuration parameter </td></tr>
    <tr><td class="paramname">owner</td><td>the node this table belongs to </td></tr>
    <tr><td class="paramname">overlay</td><td>pointer to the pastry main module </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="PastryLeafSet_8cc_source.html#l00061">61</a> of file <a class="el" href="PastryLeafSet_8cc_source.html">PastryLeafSet.cc</a>.</p>

<p>Referenced by <a class="el" href="BasePastry_8cc_source.html#l00187">BasePastry::baseChangeState()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> (<a class="code" href="classPastryLeafSet.html#a2b79dd7347229e4661b0b9d34f6909fc">numberOfLeaves</a> % 2) <span class="keywordflow">throw</span> <span class="stringliteral">&quot;numberOfLeaves must be even.&quot;</span>;

    this-&gt;owner = <a class="code" href="classPastryStateObject.html#a946cabf3c3e981122e05bb37bf1c95dc" title="stores the NodeHandle of the owner of this PastryStateObject.">owner</a>;
    this-&gt;<a class="code" href="classPastryLeafSet.html#a2b79dd7347229e4661b0b9d34f6909fc">numberOfLeaves</a> = <a class="code" href="classPastryLeafSet.html#a2b79dd7347229e4661b0b9d34f6909fc">numberOfLeaves</a>;
    this-&gt;<a class="code" href="classPastryLeafSet.html#a314a62c6e53224ba6de785f5754fcc41">repairTimeout</a> = <a class="code" href="classPastryLeafSet.html#a314a62c6e53224ba6de785f5754fcc41">repairTimeout</a>;
    this-&gt;<a class="code" href="classPastryStateObject.html#a755bc90b0fb6bd61c42207d17855b743">bitsPerDigit</a> = <a class="code" href="classPastryStateObject.html#a755bc90b0fb6bd61c42207d17855b743">bitsPerDigit</a>;
    this-&gt;overlay = <a class="code" href="classPastryLeafSet.html#a81308a19594555ad39b7a35a26bf0e4f" title="pointer to the main pastry module">overlay</a>;

    <span class="keywordflow">if</span> (!<a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.empty()) <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.clear();

    <span class="comment">// fill Set with unspecified node handles</span>
    <span class="keywordflow">for</span> (uint32_t i = <a class="code" href="classPastryLeafSet.html#a2b79dd7347229e4661b0b9d34f6909fc">numberOfLeaves</a>; i&gt;0; i--)
        <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.push_back(<a class="code" href="classNodeHandle.html#a79bf2c5e29c969cbd0b2581cb188d8a6" title="the unspecified NodeHandle">NodeHandle::UNSPECIFIED_NODE</a>);

    <span class="comment">// initialize iterators to mark the beginning of bigger/smaller keys</span>
    <span class="comment">// in the set</span>
    <a class="code" href="classPastryLeafSet.html#ad7935e96df4a1e07256e1f456f8e57a0">bigger</a> = <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.begin() + (<a class="code" href="classPastryLeafSet.html#a2b79dd7347229e4661b0b9d34f6909fc">numberOfLeaves</a> &gt;&gt; 1);
    <a class="code" href="classPastryLeafSet.html#a1b2af0d1e896f6879a5977536499e123">smaller</a> = <a class="code" href="classPastryLeafSet.html#ad7935e96df4a1e07256e1f456f8e57a0">bigger</a> - 1;

    <span class="comment">// reset repair marker:</span>
    <span class="keywordflow">if</span> (!<a class="code" href="classPastryLeafSet.html#ae5272dfe11057414c1651eb4d3eca5ee">awaitingRepair</a>.empty()) <a class="code" href="classPastryLeafSet.html#ae5272dfe11057414c1651eb4d3eca5ee">awaitingRepair</a>.clear();

    <a class="code" href="classPastryLeafSet.html#a433ea4e50c2d5f458d5c91c16f6fc8da">newLeafs</a> = <span class="keyword">false</span>;
    <a class="code" href="classPastryLeafSet.html#a603a986ef0e87c7ad4e0f8e23d46adf7">isFull</a> = <span class="keyword">false</span>;
    <a class="code" href="classPastryLeafSet.html#abb1d399d03a2768881b272ed93f786a4">wasFull</a> = <span class="keyword">false</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac563e858547e96db005896f8d822d84b"></a><!-- doxytag: member="PastryLeafSet::insertLeaf" ref="ac563e858547e96db005896f8d822d84b" args="(std::vector&lt; NodeHandle &gt;::iterator &amp;it, const NodeHandle &amp;node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PastryLeafSet::insertLeaf </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classNodeHandle.html">NodeHandle</a> &gt;::iterator &amp;&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classNodeHandle.html">NodeHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>insert a leaf at a given position </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>iterator where to insert the new leaf </td></tr>
    <tr><td class="paramname">node</td><td><a class="el" href="classNodeHandle.html" title="This class implements a node handle.">NodeHandle</a> of new leaf </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="PastryLeafSet_8cc_source.html#l00323">323</a> of file <a class="el" href="PastryLeafSet_8cc_source.html">PastryLeafSet.cc</a>.</p>

<p>Referenced by <a class="el" href="PastryLeafSet_8cc_source.html#l00254">mergeNode()</a>.</p>
<div class="fragment"><pre class="fragment">{
    assert(node != <a class="code" href="classPastryLeafSet.html#a81308a19594555ad39b7a35a26bf0e4f" title="pointer to the main pastry module">overlay</a>-&gt;<a class="code" href="classBaseRpc.html#ac3f420630d5618e81709c078b06fd9da" title="Returns the NodeHandle of this node.">getThisNode</a>());

    <a class="code" href="PastryLeafSet_8cc.html#a2b96f0bd3a00d62f9b701dde3155f44a">LEAF_TEST</a>();
    <span class="keywordtype">bool</span> issmaller = (it &lt;= <a class="code" href="classPastryLeafSet.html#a1b2af0d1e896f6879a5977536499e123">smaller</a>);
    <span class="keywordflow">if</span> (issmaller) {
        <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.insert(++it, node);

        <span class="keywordflow">if</span> (!<a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.front().isUnspecified())  {
            assert(<a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.front() != node);

            <span class="keywordflow">if</span> (<a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.back().isUnspecified()) {
                <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.back() = <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.front();
                EV &lt;&lt; <span class="stringliteral">&quot;[PastryLeafSet::insertLeaf() @ &quot;</span> &lt;&lt; <a class="code" href="classPastryLeafSet.html#a81308a19594555ad39b7a35a26bf0e4f" title="pointer to the main pastry module">overlay</a>-&gt;<a class="code" href="classBaseRpc.html#ac3f420630d5618e81709c078b06fd9da" title="Returns the NodeHandle of this node.">getThisNode</a>().<a class="code" href="classTransportAddress.html#a00e613d98d3412e2b92897c25aa0eb4c" title="returns ip address">getIp</a>()
                   &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; <a class="code" href="classPastryLeafSet.html#a81308a19594555ad39b7a35a26bf0e4f" title="pointer to the main pastry module">overlay</a>-&gt;<a class="code" href="classBaseRpc.html#ac3f420630d5618e81709c078b06fd9da" title="Returns the NodeHandle of this node.">getThisNode</a>().<a class="code" href="classNodeHandle.html#aef531103cdf07c8353267f4d30a80112" title="returns key of this NodeHandle">getKey</a>().<a class="code" href="classOverlayKey.html#aabeb4fd284a630a82e982ba34ece4fd9" title="Returns a string representation of this key.">toString</a>(16) &lt;&lt; <span class="stringliteral">&quot;)]\n&quot;</span>
                   &lt;&lt; <span class="stringliteral">&quot;    &quot;</span> &lt;&lt; <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.front().getIp() &lt;&lt; <span class="stringliteral">&quot; switched sides&quot;</span>
                   &lt;&lt; endl;
            } <span class="keywordflow">else</span> {
                EV &lt;&lt; <span class="stringliteral">&quot;[PastryLeafSet::insertLeaf() @ &quot;</span> &lt;&lt; <a class="code" href="classPastryLeafSet.html#a81308a19594555ad39b7a35a26bf0e4f" title="pointer to the main pastry module">overlay</a>-&gt;<a class="code" href="classBaseRpc.html#ac3f420630d5618e81709c078b06fd9da" title="Returns the NodeHandle of this node.">getThisNode</a>().<a class="code" href="classTransportAddress.html#a00e613d98d3412e2b92897c25aa0eb4c" title="returns ip address">getIp</a>()
                   &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; <a class="code" href="classPastryLeafSet.html#a81308a19594555ad39b7a35a26bf0e4f" title="pointer to the main pastry module">overlay</a>-&gt;<a class="code" href="classBaseRpc.html#ac3f420630d5618e81709c078b06fd9da" title="Returns the NodeHandle of this node.">getThisNode</a>().<a class="code" href="classNodeHandle.html#aef531103cdf07c8353267f4d30a80112" title="returns key of this NodeHandle">getKey</a>().<a class="code" href="classOverlayKey.html#aabeb4fd284a630a82e982ba34ece4fd9" title="Returns a string representation of this key.">toString</a>(16) &lt;&lt; <span class="stringliteral">&quot;)]\n&quot;</span>
                   &lt;&lt; <span class="stringliteral">&quot;    &quot;</span> &lt;&lt; <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.front().getIp() &lt;&lt; <span class="stringliteral">&quot; replaced with &quot;</span> &lt;&lt; node.<a class="code" href="classTransportAddress.html#a00e613d98d3412e2b92897c25aa0eb4c" title="returns ip address">getIp</a>()
                   &lt;&lt; endl;
            }
        } <span class="keywordflow">else</span> {
            EV &lt;&lt; <span class="stringliteral">&quot;[PastryLeafSet::insertLeaf() @ &quot;</span> &lt;&lt; <a class="code" href="classPastryLeafSet.html#a81308a19594555ad39b7a35a26bf0e4f" title="pointer to the main pastry module">overlay</a>-&gt;<a class="code" href="classBaseRpc.html#ac3f420630d5618e81709c078b06fd9da" title="Returns the NodeHandle of this node.">getThisNode</a>().<a class="code" href="classTransportAddress.html#a00e613d98d3412e2b92897c25aa0eb4c" title="returns ip address">getIp</a>()
               &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; <a class="code" href="classPastryLeafSet.html#a81308a19594555ad39b7a35a26bf0e4f" title="pointer to the main pastry module">overlay</a>-&gt;<a class="code" href="classBaseRpc.html#ac3f420630d5618e81709c078b06fd9da" title="Returns the NodeHandle of this node.">getThisNode</a>().<a class="code" href="classNodeHandle.html#aef531103cdf07c8353267f4d30a80112" title="returns key of this NodeHandle">getKey</a>().<a class="code" href="classOverlayKey.html#aabeb4fd284a630a82e982ba34ece4fd9" title="Returns a string representation of this key.">toString</a>(16) &lt;&lt; <span class="stringliteral">&quot;)]\n&quot;</span>
               &lt;&lt; <span class="stringliteral">&quot;    &quot;</span> &lt;&lt; node.<a class="code" href="classTransportAddress.html#a00e613d98d3412e2b92897c25aa0eb4c" title="returns ip address">getIp</a>() &lt;&lt; <span class="stringliteral">&quot; added&quot;</span>
               &lt;&lt; endl;
        }

        <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.erase(<a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.begin());


    } <span class="keywordflow">else</span> {
        <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.insert(it, node);

        <span class="keywordflow">if</span> (!<a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.back().isUnspecified())  {
            assert(<a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.back() != node);

            <span class="keywordflow">if</span> (<a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.front().isUnspecified()) {
                <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.front() = <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.back();

                EV &lt;&lt; <span class="stringliteral">&quot;[PastryLeafSet::insertLeaf() @ &quot;</span> &lt;&lt; <a class="code" href="classPastryLeafSet.html#a81308a19594555ad39b7a35a26bf0e4f" title="pointer to the main pastry module">overlay</a>-&gt;<a class="code" href="classBaseRpc.html#ac3f420630d5618e81709c078b06fd9da" title="Returns the NodeHandle of this node.">getThisNode</a>().<a class="code" href="classTransportAddress.html#a00e613d98d3412e2b92897c25aa0eb4c" title="returns ip address">getIp</a>()
                   &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; <a class="code" href="classPastryLeafSet.html#a81308a19594555ad39b7a35a26bf0e4f" title="pointer to the main pastry module">overlay</a>-&gt;<a class="code" href="classBaseRpc.html#ac3f420630d5618e81709c078b06fd9da" title="Returns the NodeHandle of this node.">getThisNode</a>().<a class="code" href="classNodeHandle.html#aef531103cdf07c8353267f4d30a80112" title="returns key of this NodeHandle">getKey</a>().<a class="code" href="classOverlayKey.html#aabeb4fd284a630a82e982ba34ece4fd9" title="Returns a string representation of this key.">toString</a>(16) &lt;&lt; <span class="stringliteral">&quot;)]\n&quot;</span>
                   &lt;&lt; <span class="stringliteral">&quot;    &quot;</span> &lt;&lt; <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.back().getIp() &lt;&lt; <span class="stringliteral">&quot; switched sides&quot;</span>
                   &lt;&lt; endl;
            } <span class="keywordflow">else</span> {

                EV &lt;&lt; <span class="stringliteral">&quot; [PastryLeafSet::insertLeaf() @ &quot;</span> &lt;&lt; <a class="code" href="classPastryLeafSet.html#a81308a19594555ad39b7a35a26bf0e4f" title="pointer to the main pastry module">overlay</a>-&gt;<a class="code" href="classBaseRpc.html#ac3f420630d5618e81709c078b06fd9da" title="Returns the NodeHandle of this node.">getThisNode</a>().<a class="code" href="classTransportAddress.html#a00e613d98d3412e2b92897c25aa0eb4c" title="returns ip address">getIp</a>()
                   &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; <a class="code" href="classPastryLeafSet.html#a81308a19594555ad39b7a35a26bf0e4f" title="pointer to the main pastry module">overlay</a>-&gt;<a class="code" href="classBaseRpc.html#ac3f420630d5618e81709c078b06fd9da" title="Returns the NodeHandle of this node.">getThisNode</a>().<a class="code" href="classNodeHandle.html#aef531103cdf07c8353267f4d30a80112" title="returns key of this NodeHandle">getKey</a>().<a class="code" href="classOverlayKey.html#aabeb4fd284a630a82e982ba34ece4fd9" title="Returns a string representation of this key.">toString</a>(16) &lt;&lt; <span class="stringliteral">&quot;)]\n&quot;</span>
                   &lt;&lt; <span class="stringliteral">&quot;    &quot;</span> &lt;&lt; <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.back().getIp() &lt;&lt; <span class="stringliteral">&quot; replaced with &quot;</span> &lt;&lt; node.<a class="code" href="classTransportAddress.html#a00e613d98d3412e2b92897c25aa0eb4c" title="returns ip address">getIp</a>()
                   &lt;&lt; endl;
            }
        } <span class="keywordflow">else</span> {
            EV &lt;&lt; <span class="stringliteral">&quot;[PastryLeafSet::insertLeaf() @ &quot;</span> &lt;&lt; <a class="code" href="classPastryLeafSet.html#a81308a19594555ad39b7a35a26bf0e4f" title="pointer to the main pastry module">overlay</a>-&gt;<a class="code" href="classBaseRpc.html#ac3f420630d5618e81709c078b06fd9da" title="Returns the NodeHandle of this node.">getThisNode</a>().<a class="code" href="classTransportAddress.html#a00e613d98d3412e2b92897c25aa0eb4c" title="returns ip address">getIp</a>()
               &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; <a class="code" href="classPastryLeafSet.html#a81308a19594555ad39b7a35a26bf0e4f" title="pointer to the main pastry module">overlay</a>-&gt;<a class="code" href="classBaseRpc.html#ac3f420630d5618e81709c078b06fd9da" title="Returns the NodeHandle of this node.">getThisNode</a>().<a class="code" href="classNodeHandle.html#aef531103cdf07c8353267f4d30a80112" title="returns key of this NodeHandle">getKey</a>().<a class="code" href="classOverlayKey.html#aabeb4fd284a630a82e982ba34ece4fd9" title="Returns a string representation of this key.">toString</a>(16) &lt;&lt; <span class="stringliteral">&quot;)]\n&quot;</span>
               &lt;&lt; <span class="stringliteral">&quot;    &quot;</span> &lt;&lt; node.<a class="code" href="classTransportAddress.html#a00e613d98d3412e2b92897c25aa0eb4c" title="returns ip address">getIp</a>() &lt;&lt; <span class="stringliteral">&quot; added&quot;</span>
               &lt;&lt; endl;
        }

        <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.pop_back();
    }

    <span class="keywordflow">if</span> (!<a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.front().isUnspecified() &amp;&amp;
        !<a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.back().isUnspecified()) {
        <a class="code" href="classPastryLeafSet.html#a603a986ef0e87c7ad4e0f8e23d46adf7">isFull</a> = <span class="keyword">true</span>;
    } <span class="keywordflow">else</span> {
        <a class="code" href="classPastryLeafSet.html#a603a986ef0e87c7ad4e0f8e23d46adf7">isFull</a> = <span class="keyword">false</span>;
    }

    <a class="code" href="classPastryLeafSet.html#a433ea4e50c2d5f458d5c91c16f6fc8da">newLeafs</a> = <span class="keyword">true</span>;
    <a class="code" href="classPastryLeafSet.html#ad7935e96df4a1e07256e1f456f8e57a0">bigger</a> = <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.begin() + (<a class="code" href="classPastryLeafSet.html#a2b79dd7347229e4661b0b9d34f6909fc">numberOfLeaves</a> &gt;&gt; 1);
    <a class="code" href="classPastryLeafSet.html#a1b2af0d1e896f6879a5977536499e123">smaller</a> = <a class="code" href="classPastryLeafSet.html#ad7935e96df4a1e07256e1f456f8e57a0">bigger</a> - 1;

    <span class="comment">// ensure balance in leafset</span>
    <span class="keywordflow">if</span> (!<a class="code" href="classPastryLeafSet.html#a603a986ef0e87c7ad4e0f8e23d46adf7">isFull</a>) {
        <a class="code" href="classPastryLeafSet.html#aec4b33e2ef0b6bcf7e9803102f5bd174">balanceLeafSet</a>();
    }
    <a class="code" href="PastryLeafSet_8cc.html#a2b96f0bd3a00d62f9b701dde3155f44a">LEAF_TEST</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa525adf4fc0334d812fbb70a50b78ca5"></a><!-- doxytag: member="PastryLeafSet::isClosestNode" ref="aa525adf4fc0334d812fbb70a50b78ca5" args="(const OverlayKey &amp;destination) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PastryLeafSet::isClosestNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOverlayKey.html">OverlayKey</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>checks if we are the closest node to key destination in the overlay </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>the key to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if we are closest to given key </dd></dl>

<p>Definition at line <a class="el" href="PastryLeafSet_8cc_source.html#l00143">143</a> of file <a class="el" href="PastryLeafSet_8cc_source.html">PastryLeafSet.cc</a>.</p>

<p>Referenced by <a class="el" href="BasePastry_8cc_source.html#l00906">BasePastry::findNode()</a>, and <a class="el" href="BasePastry_8cc_source.html#l00742">BasePastry::isSiblingFor()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// check for simple cases first</span>
    <span class="keywordflow">if</span> (<a class="code" href="classPastryStateObject.html#a946cabf3c3e981122e05bb37bf1c95dc" title="stores the NodeHandle of the owner of this PastryStateObject.">owner</a>.<a class="code" href="classNodeHandle.html#aef531103cdf07c8353267f4d30a80112" title="returns key of this NodeHandle">getKey</a>() == destination) {
        <span class="keywordflow">return</span> <span class="keyword">true</span>;
    }

    <span class="keywordflow">if</span> (<a class="code" href="classPastryLeafSet.html#ad7935e96df4a1e07256e1f456f8e57a0">bigger</a>-&gt;isUnspecified() &amp;&amp; <a class="code" href="classPastryLeafSet.html#a1b2af0d1e896f6879a5977536499e123">smaller</a>-&gt;isUnspecified()) {
        <span class="keywordflow">return</span> <span class="keyword">true</span>;
    }

    <span class="comment">// check if the next bigger or smaller node in the set is closer</span>
    <span class="comment">// than own node</span>
    <span class="keywordtype">bool</span> biggerIsCloser = <span class="keyword">false</span>;
    <span class="keywordtype">bool</span> smallerIsCloser = <span class="keyword">false</span>;

    <span class="keywordflow">if</span> (! <a class="code" href="classPastryLeafSet.html#ad7935e96df4a1e07256e1f456f8e57a0">bigger</a>-&gt;isUnspecified()) {
        biggerIsCloser = <a class="code" href="classPastryStateObject.html#ace8eed35caedb59412a49132c4538917" title="test a given NodeHandle if it is closer to a given destination">isCloser</a>(*<a class="code" href="classPastryLeafSet.html#ad7935e96df4a1e07256e1f456f8e57a0">bigger</a>, destination);
    }
    <span class="keywordflow">if</span> (! <a class="code" href="classPastryLeafSet.html#a1b2af0d1e896f6879a5977536499e123">smaller</a>-&gt;isUnspecified()) {
        smallerIsCloser = <a class="code" href="classPastryStateObject.html#ace8eed35caedb59412a49132c4538917" title="test a given NodeHandle if it is closer to a given destination">isCloser</a>(*<a class="code" href="classPastryLeafSet.html#a1b2af0d1e896f6879a5977536499e123">smaller</a>, destination);
    }

    <span class="comment">// return true if both are not closer</span>
    <span class="keywordflow">return</span> ((!biggerIsCloser) &amp;&amp; (!smallerIsCloser));
}
</pre></div>
</div>
</div>
<a class="anchor" id="aafdca32c4ad0049c6b260ae61cc5a8f5"></a><!-- doxytag: member="PastryLeafSet::isLeft" ref="aafdca32c4ad0049c6b260ae61cc5a8f5" args="(const OverlayKey &amp;key) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PastryLeafSet::isLeft </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOverlayKey.html">OverlayKey</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>test if a given key should be placed on the left or on the right side of the leaf set </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if key belongs to the left </dd></dl>

</div>
</div>
<a class="anchor" id="ae13d5a42c50606e3cc0fbcd830429322"></a><!-- doxytag: member="PastryLeafSet::isValid" ref="ae13d5a42c50606e3cc0fbcd830429322" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PastryLeafSet::isValid </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>check if LeafSet knows at least one node to the left and to the right </p>

<p>Definition at line <a class="el" href="PastryLeafSet_8cc_source.html#l00107">107</a> of file <a class="el" href="PastryLeafSet_8cc_source.html">PastryLeafSet.cc</a>.</p>

<p>Referenced by <a class="el" href="PastryLeafSet_8cc_source.html#l00212">createSiblingVector()</a>, <a class="el" href="Pastry_8cc_source.html#l00804">Pastry::doSecondStage()</a>, <a class="el" href="Bamboo_8cc_source.html#l00299">Bamboo::handleFailedNode()</a>, and <a class="el" href="Pastry_8cc_source.html#l00886">Pastry::handleFailedNode()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">return</span> (!(<a class="code" href="classPastryLeafSet.html#a1b2af0d1e896f6879a5977536499e123">smaller</a>-&gt;isUnspecified() || <a class="code" href="classPastryLeafSet.html#ad7935e96df4a1e07256e1f456f8e57a0">bigger</a>-&gt;isUnspecified()));
}
</pre></div>
</div>
</div>
<a class="anchor" id="a1e19ba86f8c54fdab06a8aed85a8c95f"></a><!-- doxytag: member="PastryLeafSet::mergeNode" ref="a1e19ba86f8c54fdab06a8aed85a8c95f" args="(const NodeHandle &amp;node, simtime_t prox)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PastryLeafSet::mergeNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNodeHandle.html">NodeHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">simtime_t&#160;</td>
          <td class="paramname"><em>prox</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>merge a node into LeafSet </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to merge </td></tr>
    <tr><td class="paramname">prox</td><td>the proximity value of the node </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if node was merged </dd></dl>

<p>Implements <a class="el" href="classPastryStateObject.html#aa5029ce2c80ae1a744ea92efc02dc8a7">PastryStateObject</a>.</p>

<p>Definition at line <a class="el" href="PastryLeafSet_8cc_source.html#l00254">254</a> of file <a class="el" href="PastryLeafSet_8cc_source.html">PastryLeafSet.cc</a>.</p>
<div class="fragment"><pre class="fragment">{
    assert(node != <a class="code" href="classPastryLeafSet.html#a81308a19594555ad39b7a35a26bf0e4f" title="pointer to the main pastry module">overlay</a>-&gt;<a class="code" href="classBaseRpc.html#ac3f420630d5618e81709c078b06fd9da" title="Returns the NodeHandle of this node.">getThisNode</a>());

    std::vector&lt;NodeHandle&gt;::iterator it, it_left, it_right;
    <span class="keyword">const</span> <a class="code" href="classOverlayKey.html" title="A common overlay key class.">OverlayKey</a>* last_left = &amp;(<a class="code" href="classPastryStateObject.html#a946cabf3c3e981122e05bb37bf1c95dc" title="stores the NodeHandle of the owner of this PastryStateObject.">owner</a>.<a class="code" href="classNodeHandle.html#aef531103cdf07c8353267f4d30a80112" title="returns key of this NodeHandle">getKey</a>());
    <span class="keyword">const</span> <a class="code" href="classOverlayKey.html" title="A common overlay key class.">OverlayKey</a>* last_right = &amp;(<a class="code" href="classPastryStateObject.html#a946cabf3c3e981122e05bb37bf1c95dc" title="stores the NodeHandle of the owner of this PastryStateObject.">owner</a>.<a class="code" href="classNodeHandle.html#aef531103cdf07c8353267f4d30a80112" title="returns key of this NodeHandle">getKey</a>());

    it_left = <a class="code" href="classPastryLeafSet.html#a1b2af0d1e896f6879a5977536499e123">smaller</a>;
    it_right = <a class="code" href="classPastryLeafSet.html#ad7935e96df4a1e07256e1f456f8e57a0">bigger</a>;

    <span class="comment">// avoid duplicates</span>
    <span class="keywordflow">for</span> (it = <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.begin(); it != <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.end(); ++it) {
        <span class="keywordflow">if</span> (it-&gt;isUnspecified()) {
            <a class="code" href="classPastryLeafSet.html#a603a986ef0e87c7ad4e0f8e23d46adf7">isFull</a> = <span class="keyword">false</span>;
            <span class="keywordflow">continue</span>;
        }
        <span class="keywordflow">if</span> (it-&gt;getKey() == node.<a class="code" href="classNodeHandle.html#aef531103cdf07c8353267f4d30a80112" title="returns key of this NodeHandle">getKey</a>()) <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }

    <span class="comment">// look for correct position in left and right half of leafset</span>
    <span class="keywordflow">while</span> (<span class="keyword">true</span>) {
        <span class="keywordflow">if</span>(!<a class="code" href="classPastryLeafSet.html#a603a986ef0e87c7ad4e0f8e23d46adf7">isFull</a>) {
            <span class="comment">// both sides free</span>
            <span class="keywordflow">if</span>(it_left-&gt;getKey().isUnspecified() &amp;&amp;
               it_right-&gt;getKey().isUnspecified()) {
                <a class="code" href="classPastryLeafSet.html#ac563e858547e96db005896f8d822d84b" title="insert a leaf at a given position">insertLeaf</a>(it_left, node);
                <span class="keywordflow">return</span> <span class="keyword">true</span>;
            }
            <span class="keywordflow">if</span> (it_left-&gt;getKey().isUnspecified() &amp;&amp;
                !node.<a class="code" href="classNodeHandle.html#aef531103cdf07c8353267f4d30a80112" title="returns key of this NodeHandle">getKey</a>().<a class="code" href="classOverlayKey.html#a4fa622c1f48d20712fe558b17f1187a5" title="Returns true, if this key is element of the interval (keyA, keyB) on the ring.">isBetween</a>(*last_right, it_right-&gt;getKey())) {
                <span class="comment">// end of smaller entries found</span>
                <a class="code" href="classPastryLeafSet.html#ac563e858547e96db005896f8d822d84b" title="insert a leaf at a given position">insertLeaf</a>(it_left, node);
                <span class="keywordflow">return</span> <span class="keyword">true</span>;
            }
            <span class="keywordflow">if</span> (it_right-&gt;getKey().isUnspecified() &amp;&amp;
                !node.<a class="code" href="classNodeHandle.html#aef531103cdf07c8353267f4d30a80112" title="returns key of this NodeHandle">getKey</a>().<a class="code" href="classOverlayKey.html#a4fa622c1f48d20712fe558b17f1187a5" title="Returns true, if this key is element of the interval (keyA, keyB) on the ring.">isBetween</a>(it_left-&gt;getKey(), *last_left)) {
                <span class="comment">// end of bigger entries found</span>
                <a class="code" href="classPastryLeafSet.html#ac563e858547e96db005896f8d822d84b" title="insert a leaf at a given position">insertLeaf</a>(it_right, node);
                <span class="keywordflow">return</span> <span class="keyword">true</span>;
            }
        }
        <span class="comment">// left side</span>
        <span class="keywordflow">if</span> (node.<a class="code" href="classNodeHandle.html#aef531103cdf07c8353267f4d30a80112" title="returns key of this NodeHandle">getKey</a>().<a class="code" href="classOverlayKey.html#a4fa622c1f48d20712fe558b17f1187a5" title="Returns true, if this key is element of the interval (keyA, keyB) on the ring.">isBetween</a>(it_left-&gt;getKey(), *last_left)) {
            <span class="comment">// found correct position for inserting the new entry between</span>
            <span class="comment">// existing ones</span>
            <a class="code" href="classPastryLeafSet.html#ac563e858547e96db005896f8d822d84b" title="insert a leaf at a given position">insertLeaf</a>(it_left, node);
            <span class="keywordflow">return</span> <span class="keyword">true</span>;
        }
        <span class="comment">// right side</span>
        <span class="keywordflow">if</span> (node.<a class="code" href="classNodeHandle.html#aef531103cdf07c8353267f4d30a80112" title="returns key of this NodeHandle">getKey</a>().<a class="code" href="classOverlayKey.html#a4fa622c1f48d20712fe558b17f1187a5" title="Returns true, if this key is element of the interval (keyA, keyB) on the ring.">isBetween</a>(*last_right, it_right-&gt;getKey())) {
            <span class="comment">// found correct position for inserting the new entry between</span>
            <span class="comment">// existing ones</span>
            <a class="code" href="classPastryLeafSet.html#ac563e858547e96db005896f8d822d84b" title="insert a leaf at a given position">insertLeaf</a>(it_right, node);
            <span class="keywordflow">return</span> <span class="keyword">true</span>;
        }

        last_right = &amp;(it_right-&gt;getKey());
        ++it_right;

        <span class="keywordflow">if</span> (it_right == <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>.end()) <span class="keywordflow">break</span>;

        last_left = &amp;(it_left-&gt;getKey());
        --it_left;
    }
    <span class="keywordflow">return</span> <span class="keyword">false</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a477c57b8227f5ec46a3d635b4590985a"></a><!-- doxytag: member="PastryLeafSet::mergeState" ref="a477c57b8227f5ec46a3d635b4590985a" args="(const PastryStateMessage *msg, const PastryStateMsgProximity *prox)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PastryLeafSet::mergeState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPastryStateMessage.html">PastryStateMessage</a> *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPastryStateMsgProximity.html">PastryStateMsgProximity</a> *&#160;</td>
          <td class="paramname"><em>prox</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>update own state based on a received <a class="el" href="classPastryStateMessage.html">PastryStateMessage</a> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>the <a class="el" href="classPastryStateMessage.html">PastryStateMessage</a> to use as source for update </td></tr>
    <tr><td class="paramname">prox</td><td>record of proximity values matching the state message </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if leafSet was actually changed </dd></dl>

<p>Reimplemented from <a class="el" href="classPastryStateObject.html#a36f82233ec05837bf3761057f2437c86">PastryStateObject</a>.</p>

<p>Definition at line <a class="el" href="PastryLeafSet_8cc_source.html#l00680">680</a> of file <a class="el" href="PastryLeafSet_8cc_source.html">PastryLeafSet.cc</a>.</p>

<p>Referenced by <a class="el" href="Pastry_8cc_source.html#l01193">Pastry::handleStateMessage()</a>, <a class="el" href="Bamboo_8cc_source.html#l00377">Bamboo::handleStateMessage()</a>, <a class="el" href="Pastry_8cc_source.html#l01101">Pastry::mergeState()</a>, and <a class="el" href="PastryLeafSet_8cc_source.html#l00573">repair()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// LS to temp vector</span>
    std::vector&lt;NodeHandle&gt; temp = <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>; <span class="comment">//getNodeHandleVector();</span>

    <span class="keywordtype">bool</span> result = <a class="code" href="classPastryLeafSet.html#a477c57b8227f5ec46a3d635b4590985a" title="update own state based on a received PastryStateMessage">PastryStateObject::mergeState</a>(msg, prox);

    <span class="comment">// nothing changed -&gt; return without sending updates</span>
    <span class="keywordflow">if</span> (!result) <span class="keywordflow">return</span> <span class="keyword">false</span>;

    <span class="comment">// compare modified vector with temp</span>
    <span class="keyword">const</span> std::vector&lt;NodeHandle&gt;&amp; current = <a class="code" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">leaves</a>; <span class="comment">//getNodeHandleVector();</span>

    <span class="comment">// send updates (first &quot;left&quot;, then &quot;joined&quot;)</span>
    <span class="keywordflow">for</span> (std::vector&lt;NodeHandle&gt;::const_iterator it = temp.begin();
         it != temp.end(); ++it) {
        <span class="keywordflow">if</span> (it-&gt;isUnspecified()) <span class="keywordflow">continue</span>;
        std::vector&lt;NodeHandle&gt;::const_iterator it2;
        <span class="keywordflow">for</span> (it2 = current.begin(); it2 != current.end(); ++it2) {
            <span class="keywordflow">if</span> (it2-&gt;isUnspecified()) <span class="keywordflow">continue</span>;
            <span class="keywordflow">if</span> (*it2 == *it) <span class="keywordflow">break</span>;
        }
        <span class="keywordflow">if</span> (it2 == current.end()) {
            <a class="code" href="classPastryLeafSet.html#a81308a19594555ad39b7a35a26bf0e4f" title="pointer to the main pastry module">overlay</a>-&gt;<a class="code" href="classBaseOverlay.html#a1422696a8eb138dde850390152ff88c7" title="Informs application about state changes of nodes or newly joined nodes.">callUpdate</a>(*it, <span class="keyword">false</span>);
        }
    }
    <span class="keywordflow">for</span> (std::vector&lt;NodeHandle&gt;::const_iterator it = current.begin();
         it != current.end(); ++it) {
        <span class="keywordflow">if</span> (it-&gt;isUnspecified()) <span class="keywordflow">continue</span>;
        std::vector&lt;NodeHandle&gt;::const_iterator it2;
        <span class="keywordflow">for</span> (it2 = temp.begin(); it2 != temp.end(); ++it2) {
            <span class="keywordflow">if</span> (it2-&gt;isUnspecified()) <span class="keywordflow">continue</span>;
            <span class="keywordflow">if</span> (*it2 == *it) <span class="keywordflow">break</span>;
        }
        <span class="keywordflow">if</span> (it2 == temp.end()) {
            <a class="code" href="classPastryLeafSet.html#a81308a19594555ad39b7a35a26bf0e4f" title="pointer to the main pastry module">overlay</a>-&gt;<a class="code" href="classBaseOverlay.html#a1422696a8eb138dde850390152ff88c7" title="Informs application about state changes of nodes or newly joined nodes.">callUpdate</a>(*it, <span class="keyword">true</span>);
        }
    }

    <span class="keywordflow">return</span> result;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aee63679544eb8ea21dbbf4d5dc7ef330"></a><!-- doxytag: member="PastryLeafSet::repair" ref="aee63679544eb8ea21dbbf4d5dc7ef330" args="(const PastryStateMessage *msg, const PastryStateMsgProximity *prox)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTransportAddress.html">TransportAddress</a> &amp; PastryLeafSet::repair </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPastryStateMessage.html">PastryStateMessage</a> *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPastryStateMsgProximity.html">PastryStateMsgProximity</a> *&#160;</td>
          <td class="paramname"><em>prox</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>attempt to repair the leafset using a received REPAIR message </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>the state message of type REPAIR </td></tr>
    <tr><td class="paramname">prox</td><td>record of proximity values matching the state message </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>another node to ask for REPAIR or <a class="el" href="classTransportAddress.html#ac1709545db722cbbce1367034142d31f" title="TransportAddress without specified ip and port.">TransportAddress::UNSPECIFIED_NODE</a> </dd></dl>

<p>Definition at line <a class="el" href="PastryLeafSet_8cc_source.html#l00573">573</a> of file <a class="el" href="PastryLeafSet_8cc_source.html">PastryLeafSet.cc</a>.</p>

<p>Referenced by <a class="el" href="Pastry_8cc_source.html#l01193">Pastry::handleStateMessage()</a>.</p>
<div class="fragment"><pre class="fragment">{
    std::map&lt;TransportAddress, PLSRepairData&gt;::iterator it;
    <span class="keyword">const</span> <a class="code" href="classTransportAddress.html" title="This class implements a common transport address.">TransportAddress</a>* ask;
    <span class="keywordtype">bool</span> left;

    simtime_t now = simTime();

    <span class="comment">// first eliminate outdated entries in awaitingRepair:</span>
    <span class="keywordflow">for</span> (it = <a class="code" href="classPastryLeafSet.html#ae5272dfe11057414c1651eb4d3eca5ee">awaitingRepair</a>.begin(); it != <a class="code" href="classPastryLeafSet.html#ae5272dfe11057414c1651eb4d3eca5ee">awaitingRepair</a>.end();) {
        <span class="keywordflow">if</span> (it-&gt;second.ts &lt; (now - <a class="code" href="classPastryLeafSet.html#a314a62c6e53224ba6de785f5754fcc41">repairTimeout</a>)) {
            <a class="code" href="classPastryLeafSet.html#ae5272dfe11057414c1651eb4d3eca5ee">awaitingRepair</a>.erase(it++);
        }
        <span class="keywordflow">else</span> it++;
    }

    <span class="comment">// don&#39;t expect any more repair messages:</span>
    <span class="keywordflow">if</span> (<a class="code" href="classPastryLeafSet.html#ae5272dfe11057414c1651eb4d3eca5ee">awaitingRepair</a>.empty()) <span class="keywordflow">return</span> <a class="code" href="classTransportAddress.html#ac1709545db722cbbce1367034142d31f" title="TransportAddress without specified ip and port.">TransportAddress::UNSPECIFIED_NODE</a>;

    <span class="comment">// look for source node in our list:</span>
    <span class="keywordflow">if</span> ( (it = <a class="code" href="classPastryLeafSet.html#ae5272dfe11057414c1651eb4d3eca5ee">awaitingRepair</a>.find(msg-&gt;<a class="code" href="classPastryStateMessage.html#ab854faec5faca431685829ba8296ecfd">getSender</a>())) == <a class="code" href="classPastryLeafSet.html#ae5272dfe11057414c1651eb4d3eca5ee">awaitingRepair</a>.end() )
        <span class="keywordflow">return</span> <a class="code" href="classTransportAddress.html#ac1709545db722cbbce1367034142d31f" title="TransportAddress without specified ip and port.">TransportAddress::UNSPECIFIED_NODE</a>;

    <span class="comment">// which side of the LeafSet is affected:</span>
    left = it-&gt;second.left;

    <span class="comment">// remove source node from list:</span>
    <a class="code" href="classPastryLeafSet.html#ae5272dfe11057414c1651eb4d3eca5ee">awaitingRepair</a>.erase(it);

    <span class="comment">// merge info from repair message:</span>
    <span class="keywordflow">if</span> (<a class="code" href="classPastryLeafSet.html#a477c57b8227f5ec46a3d635b4590985a" title="update own state based on a received PastryStateMessage">mergeState</a>(msg, prox) || <a class="code" href="classPastryLeafSet.html#a603a986ef0e87c7ad4e0f8e23d46adf7">isFull</a> || !<a class="code" href="classPastryLeafSet.html#abb1d399d03a2768881b272ed93f786a4">wasFull</a>) {
        EV &lt;&lt; <span class="stringliteral">&quot;[PastryLeafSet::repair()]\n&quot;</span>
           &lt;&lt; <span class="stringliteral">&quot;    LeafSet repair was successful.&quot;</span>
           &lt;&lt; endl;
        <span class="keywordflow">return</span> <a class="code" href="classTransportAddress.html#ac1709545db722cbbce1367034142d31f" title="TransportAddress without specified ip and port.">TransportAddress::UNSPECIFIED_NODE</a>;
    } <span class="keywordflow">else</span> {
        <span class="comment">// repair did not succeed, try again:</span>
        ask = &amp;( left ? <a class="code" href="classPastryLeafSet.html#a95c6d44e09bd76f79a11f097bf05e727" title="return the node with the smallest key in the LeafSet or NodeHandle::UNSPECIFIED_NODE if LeafSet is em...">getSmallestNode</a>() : <a class="code" href="classPastryLeafSet.html#a5b83a6b8a5ef6ad328b88710ea1164b8" title="return the node with the biggest key in the LeafSet or NodeHandle::UNSPECIFIED_NODE if LeafSet is emp...">getBiggestNode</a>() );
        <span class="keywordflow">if</span> (ask-&gt;<a class="code" href="classTransportAddress.html#a026e777c423ff2a0280edd2fa5472e74" title="indicates if TransportAddress is specified">isUnspecified</a>() || *ask == msg-&gt;<a class="code" href="classPastryStateMessage.html#ab854faec5faca431685829ba8296ecfd">getSender</a>()) {
            EV &lt;&lt; <span class="stringliteral">&quot;[PastryLeafSet::repair()]\n&quot;</span>
               &lt;&lt; <span class="stringliteral">&quot;    LeafSet giving up repair attempt.&quot;</span>
               &lt;&lt; endl;
            <span class="keywordflow">return</span> <a class="code" href="classTransportAddress.html#ac1709545db722cbbce1367034142d31f" title="TransportAddress without specified ip and port.">TransportAddress::UNSPECIFIED_NODE</a>;
        } <span class="keywordflow">else</span> {
            <a class="code" href="classPastryLeafSet.html#ae5272dfe11057414c1651eb4d3eca5ee">awaitingRepair</a>[*ask] = <a class="code" href="structPLSRepairData.html" title="struct for tracking repair requests">PLSRepairData</a>(simTime(), left);
        }
        <span class="keywordflow">return</span> *ask;
    }
}
</pre></div>
</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="ae5272dfe11057414c1651eb4d3eca5ee"></a><!-- doxytag: member="PastryLeafSet::awaitingRepair" ref="ae5272dfe11057414c1651eb4d3eca5ee" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;<a class="el" href="classTransportAddress.html">TransportAddress</a>, <a class="el" href="structPLSRepairData.html">PLSRepairData</a>&gt; <a class="el" href="classPastryLeafSet.html#ae5272dfe11057414c1651eb4d3eca5ee">PastryLeafSet::awaitingRepair</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="PastryLeafSet_8h_source.html#l00201">201</a> of file <a class="el" href="PastryLeafSet_8h_source.html">PastryLeafSet.h</a>.</p>

<p>Referenced by <a class="el" href="PastryLeafSet_8cc_source.html#l00521">failedNode()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00061">initializeSet()</a>, and <a class="el" href="PastryLeafSet_8cc_source.html#l00573">repair()</a>.</p>

</div>
</div>
<a class="anchor" id="ad7935e96df4a1e07256e1f456f8e57a0"></a><!-- doxytag: member="PastryLeafSet::bigger" ref="ad7935e96df4a1e07256e1f456f8e57a0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classNodeHandle.html">NodeHandle</a>&gt;::iterator <a class="el" href="classPastryLeafSet.html#ad7935e96df4a1e07256e1f456f8e57a0">PastryLeafSet::bigger</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="PastryLeafSet_8h_source.html#l00199">199</a> of file <a class="el" href="PastryLeafSet_8h_source.html">PastryLeafSet.h</a>.</p>

<p>Referenced by <a class="el" href="PastryLeafSet_8cc_source.html#l00407">balanceLeafSet()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00521">failedNode()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00466">getBiggestNode()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00095">getSuccessor()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00061">initializeSet()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00323">insertLeaf()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00143">isClosestNode()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00107">isValid()</a>, and <a class="el" href="PastryLeafSet_8cc_source.html#l00254">mergeNode()</a>.</p>

</div>
</div>
<a class="anchor" id="a603a986ef0e87c7ad4e0f8e23d46adf7"></a><!-- doxytag: member="PastryLeafSet::isFull" ref="a603a986ef0e87c7ad4e0f8e23d46adf7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classPastryLeafSet.html#a603a986ef0e87c7ad4e0f8e23d46adf7">PastryLeafSet::isFull</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="PastryLeafSet_8h_source.html#l00205">205</a> of file <a class="el" href="PastryLeafSet_8h_source.html">PastryLeafSet.h</a>.</p>

<p>Referenced by <a class="el" href="PastryLeafSet_8cc_source.html#l00407">balanceLeafSet()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00521">failedNode()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00061">initializeSet()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00323">insertLeaf()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00254">mergeNode()</a>, and <a class="el" href="PastryLeafSet_8cc_source.html#l00573">repair()</a>.</p>

</div>
</div>
<a class="anchor" id="afef9535e5da8a4151381d31df20e37a6"></a><!-- doxytag: member="PastryLeafSet::leaves" ref="afef9535e5da8a4151381d31df20e37a6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classNodeHandle.html">NodeHandle</a>&gt; <a class="el" href="classPastryLeafSet.html#afef9535e5da8a4151381d31df20e37a6">PastryLeafSet::leaves</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="PastryLeafSet_8h_source.html#l00197">197</a> of file <a class="el" href="PastryLeafSet_8h_source.html">PastryLeafSet.h</a>.</p>

<p>Referenced by <a class="el" href="PastryLeafSet_8cc_source.html#l00407">balanceLeafSet()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00212">createSiblingVector()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00171">dumpToStateMessage()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00441">dumpToVector()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00055">earlyInit()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00645">estimateMeanDistance()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00521">failedNode()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00481">findCloserNodes()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00466">getBiggestNode()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00113">getDestinationNode()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00625">getNewLeafsMessage()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00188">getRandomNode()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00451">getSmallestNode()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00061">initializeSet()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00323">insertLeaf()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00254">mergeNode()</a>, and <a class="el" href="PastryLeafSet_8cc_source.html#l00680">mergeState()</a>.</p>

</div>
</div>
<a class="anchor" id="a433ea4e50c2d5f458d5c91c16f6fc8da"></a><!-- doxytag: member="PastryLeafSet::newLeafs" ref="a433ea4e50c2d5f458d5c91c16f6fc8da" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classPastryLeafSet.html#a433ea4e50c2d5f458d5c91c16f6fc8da">PastryLeafSet::newLeafs</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="PastryLeafSet_8h_source.html#l00203">203</a> of file <a class="el" href="PastryLeafSet_8h_source.html">PastryLeafSet.h</a>.</p>

<p>Referenced by <a class="el" href="PastryLeafSet_8cc_source.html#l00521">failedNode()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00625">getNewLeafsMessage()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00061">initializeSet()</a>, and <a class="el" href="PastryLeafSet_8cc_source.html#l00323">insertLeaf()</a>.</p>

</div>
</div>
<a class="anchor" id="a2b79dd7347229e4661b0b9d34f6909fc"></a><!-- doxytag: member="PastryLeafSet::numberOfLeaves" ref="a2b79dd7347229e4661b0b9d34f6909fc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="classPastryLeafSet.html#a2b79dd7347229e4661b0b9d34f6909fc">PastryLeafSet::numberOfLeaves</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="PastryLeafSet_8h_source.html#l00194">194</a> of file <a class="el" href="PastryLeafSet_8h_source.html">PastryLeafSet.h</a>.</p>

<p>Referenced by <a class="el" href="PastryLeafSet_8cc_source.html#l00171">dumpToStateMessage()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00521">failedNode()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00625">getNewLeafsMessage()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00188">getRandomNode()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00061">initializeSet()</a>, and <a class="el" href="PastryLeafSet_8cc_source.html#l00323">insertLeaf()</a>.</p>

</div>
</div>
<a class="anchor" id="a81308a19594555ad39b7a35a26bf0e4f"></a><!-- doxytag: member="PastryLeafSet::overlay" ref="a81308a19594555ad39b7a35a26bf0e4f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBasePastry.html">BasePastry</a>* <a class="el" href="classPastryLeafSet.html#a81308a19594555ad39b7a35a26bf0e4f">PastryLeafSet::overlay</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>pointer to the main pastry module </p>

<p>Definition at line <a class="el" href="PastryLeafSet_8h_source.html#l00196">196</a> of file <a class="el" href="PastryLeafSet_8h_source.html">PastryLeafSet.h</a>.</p>

<p>Referenced by <a class="el" href="PastryLeafSet_8cc_source.html#l00521">failedNode()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00466">getBiggestNode()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00451">getSmallestNode()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00061">initializeSet()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00323">insertLeaf()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00254">mergeNode()</a>, and <a class="el" href="PastryLeafSet_8cc_source.html#l00680">mergeState()</a>.</p>

</div>
</div>
<a class="anchor" id="a314a62c6e53224ba6de785f5754fcc41"></a><!-- doxytag: member="PastryLeafSet::repairTimeout" ref="a314a62c6e53224ba6de785f5754fcc41" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">simtime_t <a class="el" href="classPastryLeafSet.html#a314a62c6e53224ba6de785f5754fcc41">PastryLeafSet::repairTimeout</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="PastryLeafSet_8h_source.html#l00195">195</a> of file <a class="el" href="PastryLeafSet_8h_source.html">PastryLeafSet.h</a>.</p>

<p>Referenced by <a class="el" href="PastryLeafSet_8cc_source.html#l00061">initializeSet()</a>, and <a class="el" href="PastryLeafSet_8cc_source.html#l00573">repair()</a>.</p>

</div>
</div>
<a class="anchor" id="a1b2af0d1e896f6879a5977536499e123"></a><!-- doxytag: member="PastryLeafSet::smaller" ref="a1b2af0d1e896f6879a5977536499e123" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classNodeHandle.html">NodeHandle</a>&gt;::iterator <a class="el" href="classPastryLeafSet.html#a1b2af0d1e896f6879a5977536499e123">PastryLeafSet::smaller</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="PastryLeafSet_8h_source.html#l00198">198</a> of file <a class="el" href="PastryLeafSet_8h_source.html">PastryLeafSet.h</a>.</p>

<p>Referenced by <a class="el" href="PastryLeafSet_8cc_source.html#l00407">balanceLeafSet()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00521">failedNode()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00101">getPredecessor()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00451">getSmallestNode()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00061">initializeSet()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00323">insertLeaf()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00143">isClosestNode()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00107">isValid()</a>, and <a class="el" href="PastryLeafSet_8cc_source.html#l00254">mergeNode()</a>.</p>

</div>
</div>
<a class="anchor" id="abb1d399d03a2768881b272ed93f786a4"></a><!-- doxytag: member="PastryLeafSet::wasFull" ref="abb1d399d03a2768881b272ed93f786a4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classPastryLeafSet.html#abb1d399d03a2768881b272ed93f786a4">PastryLeafSet::wasFull</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="PastryLeafSet_8h_source.html#l00206">206</a> of file <a class="el" href="PastryLeafSet_8h_source.html">PastryLeafSet.h</a>.</p>

<p>Referenced by <a class="el" href="PastryLeafSet_8cc_source.html#l00521">failedNode()</a>, <a class="el" href="PastryLeafSet_8cc_source.html#l00061">initializeSet()</a>, and <a class="el" href="PastryLeafSet_8cc_source.html#l00573">repair()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="PastryLeafSet_8h_source.html">PastryLeafSet.h</a></li>
<li><a class="el" href="PastryLeafSet_8cc_source.html">PastryLeafSet.cc</a></li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="classPastryLeafSet.html">PastryLeafSet</a>      </li>

    <li class="footer">Generated on Thu Mar 6 2014 14:06:57 for OverSim by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.5.1 </li>
   </ul>
 </div>


</body>
</html>
