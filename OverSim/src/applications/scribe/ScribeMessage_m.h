//
// Generated file, do not edit! Created by opp_msgc 4.3 from applications/scribe/ScribeMessage.msg.
//

#ifndef _SCRIBEMESSAGE_M_H_
#define _SCRIBEMESSAGE_M_H_

#include <omnetpp.h>

// opp_msgc version check
#define MSGC_VERSION 0x0403
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of opp_msgc: 'make clean' should help.
#endif

// cplusplus {{
#include <CommonMessages_m.h>

class ScribeTimer;

#include "ScribeGroup.h"


static const int SCRIBE_WRONGROOT_L = 8;
static const int SCRIBE_EMPTYFLAG_L = 8;


#define SCRIBE_JOINCALL_L(msg) (BASECALL_L(msg))
#define SCRIBE_JOINRESPONSE_L(msg) (BASECALL_L(msg))
#define SCRIBE_PUBLISHCALL_L(msg) (BASECALL_L(msg))
#define SCRIBE_PUBLISHRESPONSE_L(msg) (BASECALL_L(msg) + SCRIBE_WRONGROOT_L)

#define SCRIBE_SUBSCRIPTIONREFRESH_L(msg) (NODEHANDLE_L + KEY_L)
#define SCRIBE_LEAVE_L(msg) (NODEHANDLE_L + KEY_L)
#define SCRIBE_DATA_L(msg) (KEY_L + SCRIBE_EMPTYFLAG_L)
// }}



/**
 * Enum generated from <tt>applications/scribe/ScribeMessage.msg</tt> by opp_msgc.
 * <pre>
 * enum ScribeTimerType 
 * {
 * 
 *     SCRIBE_HEARTBEAT = 0; 
 *     SCRIBE_SUBSCRIPTION_REFRESH = 1; 
 *     SCRIBE_PARENT_TIMEOUT = 2; 
 *     SCRIBE_CHILD_TIMEOUT = 3; 
 * }
 * </pre>
 */
enum ScribeTimerType {
    SCRIBE_HEARTBEAT = 0,
    SCRIBE_SUBSCRIPTION_REFRESH = 1,
    SCRIBE_PARENT_TIMEOUT = 2,
    SCRIBE_CHILD_TIMEOUT = 3
};

/**
 * Class generated from <tt>applications/scribe/ScribeMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet ScribeJoinCall extends BaseCallMessage
 * {
 *         OverlayKey groupId; 
 *                             
 * }
 * </pre>
 */
class ScribeJoinCall : public ::BaseCallMessage
{
  protected:
    OverlayKey groupId_var;

  private:
    void copy(const ScribeJoinCall& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ScribeJoinCall&);

  public:
    ScribeJoinCall(const char *name=NULL, int kind=0);
    ScribeJoinCall(const ScribeJoinCall& other);
    virtual ~ScribeJoinCall();
    ScribeJoinCall& operator=(const ScribeJoinCall& other);
    virtual ScribeJoinCall *dup() const {return new ScribeJoinCall(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual OverlayKey& getGroupId();
    virtual const OverlayKey& getGroupId() const {return const_cast<ScribeJoinCall*>(this)->getGroupId();}
    virtual void setGroupId(const OverlayKey& groupId);
};

inline void doPacking(cCommBuffer *b, ScribeJoinCall& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, ScribeJoinCall& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>applications/scribe/ScribeMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet ScribeJoinResponse extends BaseResponseMessage
 * {
 *         OverlayKey groupId; 
 *                             
 * }
 * </pre>
 */
class ScribeJoinResponse : public ::BaseResponseMessage
{
  protected:
    OverlayKey groupId_var;

  private:
    void copy(const ScribeJoinResponse& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ScribeJoinResponse&);

  public:
    ScribeJoinResponse(const char *name=NULL, int kind=0);
    ScribeJoinResponse(const ScribeJoinResponse& other);
    virtual ~ScribeJoinResponse();
    ScribeJoinResponse& operator=(const ScribeJoinResponse& other);
    virtual ScribeJoinResponse *dup() const {return new ScribeJoinResponse(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual OverlayKey& getGroupId();
    virtual const OverlayKey& getGroupId() const {return const_cast<ScribeJoinResponse*>(this)->getGroupId();}
    virtual void setGroupId(const OverlayKey& groupId);
};

inline void doPacking(cCommBuffer *b, ScribeJoinResponse& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, ScribeJoinResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>applications/scribe/ScribeMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet ScribePublishCall extends BaseCallMessage
 * {
 *         OverlayKey groupId; 
 *                             
 * }
 * </pre>
 */
class ScribePublishCall : public ::BaseCallMessage
{
  protected:
    OverlayKey groupId_var;

  private:
    void copy(const ScribePublishCall& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ScribePublishCall&);

  public:
    ScribePublishCall(const char *name=NULL, int kind=0);
    ScribePublishCall(const ScribePublishCall& other);
    virtual ~ScribePublishCall();
    ScribePublishCall& operator=(const ScribePublishCall& other);
    virtual ScribePublishCall *dup() const {return new ScribePublishCall(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual OverlayKey& getGroupId();
    virtual const OverlayKey& getGroupId() const {return const_cast<ScribePublishCall*>(this)->getGroupId();}
    virtual void setGroupId(const OverlayKey& groupId);
};

inline void doPacking(cCommBuffer *b, ScribePublishCall& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, ScribePublishCall& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>applications/scribe/ScribeMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet ScribePublishResponse extends BaseResponseMessage
 * {
 *         OverlayKey groupId; 
 *                             
 *         bool wrongRoot = false;
 * }
 * </pre>
 */
class ScribePublishResponse : public ::BaseResponseMessage
{
  protected:
    OverlayKey groupId_var;
    bool wrongRoot_var;

  private:
    void copy(const ScribePublishResponse& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ScribePublishResponse&);

  public:
    ScribePublishResponse(const char *name=NULL, int kind=0);
    ScribePublishResponse(const ScribePublishResponse& other);
    virtual ~ScribePublishResponse();
    ScribePublishResponse& operator=(const ScribePublishResponse& other);
    virtual ScribePublishResponse *dup() const {return new ScribePublishResponse(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual OverlayKey& getGroupId();
    virtual const OverlayKey& getGroupId() const {return const_cast<ScribePublishResponse*>(this)->getGroupId();}
    virtual void setGroupId(const OverlayKey& groupId);
    virtual bool getWrongRoot() const;
    virtual void setWrongRoot(bool wrongRoot);
};

inline void doPacking(cCommBuffer *b, ScribePublishResponse& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, ScribePublishResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>applications/scribe/ScribeMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet ScribeSubscriptionRefreshMessage
 * {
 *         NodeHandle src;
 *         OverlayKey groupId;
 * }
 * </pre>
 */
class ScribeSubscriptionRefreshMessage : public ::cPacket
{
  protected:
    NodeHandle src_var;
    OverlayKey groupId_var;

  private:
    void copy(const ScribeSubscriptionRefreshMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ScribeSubscriptionRefreshMessage&);

  public:
    ScribeSubscriptionRefreshMessage(const char *name=NULL, int kind=0);
    ScribeSubscriptionRefreshMessage(const ScribeSubscriptionRefreshMessage& other);
    virtual ~ScribeSubscriptionRefreshMessage();
    ScribeSubscriptionRefreshMessage& operator=(const ScribeSubscriptionRefreshMessage& other);
    virtual ScribeSubscriptionRefreshMessage *dup() const {return new ScribeSubscriptionRefreshMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual NodeHandle& getSrc();
    virtual const NodeHandle& getSrc() const {return const_cast<ScribeSubscriptionRefreshMessage*>(this)->getSrc();}
    virtual void setSrc(const NodeHandle& src);
    virtual OverlayKey& getGroupId();
    virtual const OverlayKey& getGroupId() const {return const_cast<ScribeSubscriptionRefreshMessage*>(this)->getGroupId();}
    virtual void setGroupId(const OverlayKey& groupId);
};

inline void doPacking(cCommBuffer *b, ScribeSubscriptionRefreshMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, ScribeSubscriptionRefreshMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>applications/scribe/ScribeMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet ScribeLeaveMessage
 * {
 *         NodeHandle src;
 *         OverlayKey groupId;
 * }
 * </pre>
 */
class ScribeLeaveMessage : public ::cPacket
{
  protected:
    NodeHandle src_var;
    OverlayKey groupId_var;

  private:
    void copy(const ScribeLeaveMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ScribeLeaveMessage&);

  public:
    ScribeLeaveMessage(const char *name=NULL, int kind=0);
    ScribeLeaveMessage(const ScribeLeaveMessage& other);
    virtual ~ScribeLeaveMessage();
    ScribeLeaveMessage& operator=(const ScribeLeaveMessage& other);
    virtual ScribeLeaveMessage *dup() const {return new ScribeLeaveMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual NodeHandle& getSrc();
    virtual const NodeHandle& getSrc() const {return const_cast<ScribeLeaveMessage*>(this)->getSrc();}
    virtual void setSrc(const NodeHandle& src);
    virtual OverlayKey& getGroupId();
    virtual const OverlayKey& getGroupId() const {return const_cast<ScribeLeaveMessage*>(this)->getGroupId();}
    virtual void setGroupId(const OverlayKey& groupId);
};

inline void doPacking(cCommBuffer *b, ScribeLeaveMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, ScribeLeaveMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>applications/scribe/ScribeMessage.msg</tt> by opp_msgc.
 * <pre>
 * message ScribeTimer
 * {
 *         int timerType enum(ScribeTimerType);
 *         NodeHandle child;
 *         OverlayKey group;
 * }
 * </pre>
 */
class ScribeTimer : public ::cMessage
{
  protected:
    int timerType_var;
    NodeHandle child_var;
    OverlayKey group_var;

  private:
    void copy(const ScribeTimer& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ScribeTimer&);

  public:
    ScribeTimer(const char *name=NULL, int kind=0);
    ScribeTimer(const ScribeTimer& other);
    virtual ~ScribeTimer();
    ScribeTimer& operator=(const ScribeTimer& other);
    virtual ScribeTimer *dup() const {return new ScribeTimer(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getTimerType() const;
    virtual void setTimerType(int timerType);
    virtual NodeHandle& getChild();
    virtual const NodeHandle& getChild() const {return const_cast<ScribeTimer*>(this)->getChild();}
    virtual void setChild(const NodeHandle& child);
    virtual OverlayKey& getGroup();
    virtual const OverlayKey& getGroup() const {return const_cast<ScribeTimer*>(this)->getGroup();}
    virtual void setGroup(const OverlayKey& group);
};

inline void doPacking(cCommBuffer *b, ScribeTimer& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, ScribeTimer& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>applications/scribe/ScribeMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet ScribeDataMessage
 * {
 *         OverlayKey groupId;
 *         bool empty = false;
 * }
 * </pre>
 */
class ScribeDataMessage : public ::cPacket
{
  protected:
    OverlayKey groupId_var;
    bool empty_var;

  private:
    void copy(const ScribeDataMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ScribeDataMessage&);

  public:
    ScribeDataMessage(const char *name=NULL, int kind=0);
    ScribeDataMessage(const ScribeDataMessage& other);
    virtual ~ScribeDataMessage();
    ScribeDataMessage& operator=(const ScribeDataMessage& other);
    virtual ScribeDataMessage *dup() const {return new ScribeDataMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual OverlayKey& getGroupId();
    virtual const OverlayKey& getGroupId() const {return const_cast<ScribeDataMessage*>(this)->getGroupId();}
    virtual void setGroupId(const OverlayKey& groupId);
    virtual bool getEmpty() const;
    virtual void setEmpty(bool empty);
};

inline void doPacking(cCommBuffer *b, ScribeDataMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, ScribeDataMessage& obj) {obj.parsimUnpack(b);}


#endif // _SCRIBEMESSAGE_M_H_
