//
// Generated file, do not edit! Created by opp_msgc 4.3 from applications/i3/I3Message.msg.
//

#ifndef _I3MESSAGE_M_H_
#define _I3MESSAGE_M_H_

#include <omnetpp.h>

// opp_msgc version check
#define MSGC_VERSION 0x0403
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of opp_msgc: 'make clean' should help.
#endif

// cplusplus {{
#include "I3Trigger.h"
#include "I3IdentifierStack.h"
#include "I3Identifier.h"
#include "I3IPAddress.h"

#define I3TYPE_L    2
#define I3BOOL_L    1
#define I3TIME_L    32
#define INSERT_TRIGGER_L(msg) (I3TYPE_L + I3BOOL_L + msg->getTrigger().length() + msg->getSource().length())
#define QUERY_REPLY_L(msg)  (I3TYPE_L + msg->getSource().length() + msg->getIdentifier().length() + I3TIME_L)
#define REMOVE_TRIGGER_L(msg) (I3TYPE_L + msg->getTrigger().length())
#define SEND_PACKET_L(msg)    (I3TYPE_L + msg->getIdentifierStack().length() + msg->getMatchedTrigger().length())
// }}



/**
 * Enum generated from <tt>applications/i3/I3Message.msg</tt> by opp_msgc.
 * <pre>
 * enum I3MessageType
 * {
 * 
 * 	INSERT_TRIGGER = 0;
 * 	QUERY_REPLY = 1;	
 * 	REMOVE_TRIGGER = 2;
 * 	SEND_PACKET = 3;
 * }
 * </pre>
 */
enum I3MessageType {
    INSERT_TRIGGER = 0,
    QUERY_REPLY = 1,
    REMOVE_TRIGGER = 2,
    SEND_PACKET = 3
};

/**
 * Class generated from <tt>applications/i3/I3Message.msg</tt> by opp_msgc.
 * <pre>
 * packet I3Message
 * {
 * 		int type enum(I3MessageType);
 * }
 * </pre>
 */
class I3Message : public ::cPacket
{
  protected:
    int type_var;

  private:
    void copy(const I3Message& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const I3Message&);

  public:
    I3Message(const char *name=NULL, int kind=0);
    I3Message(const I3Message& other);
    virtual ~I3Message();
    I3Message& operator=(const I3Message& other);
    virtual I3Message *dup() const {return new I3Message(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getType() const;
    virtual void setType(int type);
};

inline void doPacking(cCommBuffer *b, I3Message& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, I3Message& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>applications/i3/I3Message.msg</tt> by opp_msgc.
 * <pre>
 * packet I3InsertTriggerMessage extends I3Message
 * {
 *     @customize(true);
 * 		bool sendReply;
 * 		I3Trigger trigger;
 * 		I3IPAddress source;
 * }
 * </pre>
 *
 * I3InsertTriggerMessage_Base is only useful if it gets subclassed, and I3InsertTriggerMessage is derived from it.
 * The minimum code to be written for I3InsertTriggerMessage is the following:
 *
 * <pre>
 * class I3InsertTriggerMessage : public I3InsertTriggerMessage_Base
 * {
 *   private:
 *     void copy(const I3InsertTriggerMessage& other) { ... }

 *   public:
 *     I3InsertTriggerMessage(const char *name=NULL, int kind=0) : I3InsertTriggerMessage_Base(name,kind) {}
 *     I3InsertTriggerMessage(const I3InsertTriggerMessage& other) : I3InsertTriggerMessage_Base(other) {copy(other);}
 *     I3InsertTriggerMessage& operator=(const I3InsertTriggerMessage& other) {if (this==&other) return *this; I3InsertTriggerMessage_Base::operator=(other); copy(other); return *this;}
 *     virtual I3InsertTriggerMessage *dup() const {return new I3InsertTriggerMessage(*this);}
 *     // ADD CODE HERE to redefine and implement pure virtual functions from I3InsertTriggerMessage_Base
 * };
 * </pre>
 *
 * The following should go into a .cc (.cpp) file:
 *
 * <pre>
 * Register_Class(I3InsertTriggerMessage);
 * </pre>
 */
class I3InsertTriggerMessage_Base : public ::I3Message
{
  protected:
    bool sendReply_var;
    I3Trigger trigger_var;
    I3IPAddress source_var;

  private:
    void copy(const I3InsertTriggerMessage_Base& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const I3InsertTriggerMessage_Base&);
    // make constructors protected to avoid instantiation
    I3InsertTriggerMessage_Base(const char *name=NULL, int kind=0);
    I3InsertTriggerMessage_Base(const I3InsertTriggerMessage_Base& other);
    // make assignment operator protected to force the user override it
    I3InsertTriggerMessage_Base& operator=(const I3InsertTriggerMessage_Base& other);

  public:
    virtual ~I3InsertTriggerMessage_Base();
    virtual I3InsertTriggerMessage_Base *dup() const {throw cRuntimeError("You forgot to manually add a dup() function to class I3InsertTriggerMessage");}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual bool getSendReply() const;
    virtual void setSendReply(bool sendReply);
    virtual I3Trigger& getTrigger();
    virtual const I3Trigger& getTrigger() const {return const_cast<I3InsertTriggerMessage_Base*>(this)->getTrigger();}
    virtual void setTrigger(const I3Trigger& trigger);
    virtual I3IPAddress& getSource();
    virtual const I3IPAddress& getSource() const {return const_cast<I3InsertTriggerMessage_Base*>(this)->getSource();}
    virtual void setSource(const I3IPAddress& source);
};

/**
 * Class generated from <tt>applications/i3/I3Message.msg</tt> by opp_msgc.
 * <pre>
 * packet I3QueryReplyMessage extends I3Message
 * {
 *     @customize(true);
 * 		I3IPAddress source;
 * 		I3Identifier identifier;
 * 		simtime_t sendingTime;
 * }
 * </pre>
 *
 * I3QueryReplyMessage_Base is only useful if it gets subclassed, and I3QueryReplyMessage is derived from it.
 * The minimum code to be written for I3QueryReplyMessage is the following:
 *
 * <pre>
 * class I3QueryReplyMessage : public I3QueryReplyMessage_Base
 * {
 *   private:
 *     void copy(const I3QueryReplyMessage& other) { ... }

 *   public:
 *     I3QueryReplyMessage(const char *name=NULL, int kind=0) : I3QueryReplyMessage_Base(name,kind) {}
 *     I3QueryReplyMessage(const I3QueryReplyMessage& other) : I3QueryReplyMessage_Base(other) {copy(other);}
 *     I3QueryReplyMessage& operator=(const I3QueryReplyMessage& other) {if (this==&other) return *this; I3QueryReplyMessage_Base::operator=(other); copy(other); return *this;}
 *     virtual I3QueryReplyMessage *dup() const {return new I3QueryReplyMessage(*this);}
 *     // ADD CODE HERE to redefine and implement pure virtual functions from I3QueryReplyMessage_Base
 * };
 * </pre>
 *
 * The following should go into a .cc (.cpp) file:
 *
 * <pre>
 * Register_Class(I3QueryReplyMessage);
 * </pre>
 */
class I3QueryReplyMessage_Base : public ::I3Message
{
  protected:
    I3IPAddress source_var;
    I3Identifier identifier_var;
    simtime_t sendingTime_var;

  private:
    void copy(const I3QueryReplyMessage_Base& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const I3QueryReplyMessage_Base&);
    // make constructors protected to avoid instantiation
    I3QueryReplyMessage_Base(const char *name=NULL, int kind=0);
    I3QueryReplyMessage_Base(const I3QueryReplyMessage_Base& other);
    // make assignment operator protected to force the user override it
    I3QueryReplyMessage_Base& operator=(const I3QueryReplyMessage_Base& other);

  public:
    virtual ~I3QueryReplyMessage_Base();
    virtual I3QueryReplyMessage_Base *dup() const {throw cRuntimeError("You forgot to manually add a dup() function to class I3QueryReplyMessage");}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual I3IPAddress& getSource();
    virtual const I3IPAddress& getSource() const {return const_cast<I3QueryReplyMessage_Base*>(this)->getSource();}
    virtual void setSource(const I3IPAddress& source);
    virtual I3Identifier& getIdentifier();
    virtual const I3Identifier& getIdentifier() const {return const_cast<I3QueryReplyMessage_Base*>(this)->getIdentifier();}
    virtual void setIdentifier(const I3Identifier& identifier);
    virtual simtime_t getSendingTime() const;
    virtual void setSendingTime(simtime_t sendingTime);
};

/**
 * Class generated from <tt>applications/i3/I3Message.msg</tt> by opp_msgc.
 * <pre>
 * packet I3RemoveTriggerMessage extends I3Message
 * {
 *     @customize(true);
 * 		I3Trigger trigger;
 * }
 * </pre>
 *
 * I3RemoveTriggerMessage_Base is only useful if it gets subclassed, and I3RemoveTriggerMessage is derived from it.
 * The minimum code to be written for I3RemoveTriggerMessage is the following:
 *
 * <pre>
 * class I3RemoveTriggerMessage : public I3RemoveTriggerMessage_Base
 * {
 *   private:
 *     void copy(const I3RemoveTriggerMessage& other) { ... }

 *   public:
 *     I3RemoveTriggerMessage(const char *name=NULL, int kind=0) : I3RemoveTriggerMessage_Base(name,kind) {}
 *     I3RemoveTriggerMessage(const I3RemoveTriggerMessage& other) : I3RemoveTriggerMessage_Base(other) {copy(other);}
 *     I3RemoveTriggerMessage& operator=(const I3RemoveTriggerMessage& other) {if (this==&other) return *this; I3RemoveTriggerMessage_Base::operator=(other); copy(other); return *this;}
 *     virtual I3RemoveTriggerMessage *dup() const {return new I3RemoveTriggerMessage(*this);}
 *     // ADD CODE HERE to redefine and implement pure virtual functions from I3RemoveTriggerMessage_Base
 * };
 * </pre>
 *
 * The following should go into a .cc (.cpp) file:
 *
 * <pre>
 * Register_Class(I3RemoveTriggerMessage);
 * </pre>
 */
class I3RemoveTriggerMessage_Base : public ::I3Message
{
  protected:
    I3Trigger trigger_var;

  private:
    void copy(const I3RemoveTriggerMessage_Base& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const I3RemoveTriggerMessage_Base&);
    // make constructors protected to avoid instantiation
    I3RemoveTriggerMessage_Base(const char *name=NULL, int kind=0);
    I3RemoveTriggerMessage_Base(const I3RemoveTriggerMessage_Base& other);
    // make assignment operator protected to force the user override it
    I3RemoveTriggerMessage_Base& operator=(const I3RemoveTriggerMessage_Base& other);

  public:
    virtual ~I3RemoveTriggerMessage_Base();
    virtual I3RemoveTriggerMessage_Base *dup() const {throw cRuntimeError("You forgot to manually add a dup() function to class I3RemoveTriggerMessage");}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual I3Trigger& getTrigger();
    virtual const I3Trigger& getTrigger() const {return const_cast<I3RemoveTriggerMessage_Base*>(this)->getTrigger();}
    virtual void setTrigger(const I3Trigger& trigger);
};

/**
 * Class generated from <tt>applications/i3/I3Message.msg</tt> by opp_msgc.
 * <pre>
 * packet I3SendPacketMessage extends I3Message
 * {
 *     @customize(true);
 * 		I3IdentifierStack identifierStack;
 * 		I3Trigger matchedTrigger;
 * 		bool sendReply;
 * 		I3IPAddress source;
 * }
 * </pre>
 *
 * I3SendPacketMessage_Base is only useful if it gets subclassed, and I3SendPacketMessage is derived from it.
 * The minimum code to be written for I3SendPacketMessage is the following:
 *
 * <pre>
 * class I3SendPacketMessage : public I3SendPacketMessage_Base
 * {
 *   private:
 *     void copy(const I3SendPacketMessage& other) { ... }

 *   public:
 *     I3SendPacketMessage(const char *name=NULL, int kind=0) : I3SendPacketMessage_Base(name,kind) {}
 *     I3SendPacketMessage(const I3SendPacketMessage& other) : I3SendPacketMessage_Base(other) {copy(other);}
 *     I3SendPacketMessage& operator=(const I3SendPacketMessage& other) {if (this==&other) return *this; I3SendPacketMessage_Base::operator=(other); copy(other); return *this;}
 *     virtual I3SendPacketMessage *dup() const {return new I3SendPacketMessage(*this);}
 *     // ADD CODE HERE to redefine and implement pure virtual functions from I3SendPacketMessage_Base
 * };
 * </pre>
 *
 * The following should go into a .cc (.cpp) file:
 *
 * <pre>
 * Register_Class(I3SendPacketMessage);
 * </pre>
 */
class I3SendPacketMessage_Base : public ::I3Message
{
  protected:
    I3IdentifierStack identifierStack_var;
    I3Trigger matchedTrigger_var;
    bool sendReply_var;
    I3IPAddress source_var;

  private:
    void copy(const I3SendPacketMessage_Base& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const I3SendPacketMessage_Base&);
    // make constructors protected to avoid instantiation
    I3SendPacketMessage_Base(const char *name=NULL, int kind=0);
    I3SendPacketMessage_Base(const I3SendPacketMessage_Base& other);
    // make assignment operator protected to force the user override it
    I3SendPacketMessage_Base& operator=(const I3SendPacketMessage_Base& other);

  public:
    virtual ~I3SendPacketMessage_Base();
    virtual I3SendPacketMessage_Base *dup() const {throw cRuntimeError("You forgot to manually add a dup() function to class I3SendPacketMessage");}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual I3IdentifierStack& getIdentifierStack();
    virtual const I3IdentifierStack& getIdentifierStack() const {return const_cast<I3SendPacketMessage_Base*>(this)->getIdentifierStack();}
    virtual void setIdentifierStack(const I3IdentifierStack& identifierStack);
    virtual I3Trigger& getMatchedTrigger();
    virtual const I3Trigger& getMatchedTrigger() const {return const_cast<I3SendPacketMessage_Base*>(this)->getMatchedTrigger();}
    virtual void setMatchedTrigger(const I3Trigger& matchedTrigger);
    virtual bool getSendReply() const;
    virtual void setSendReply(bool sendReply);
    virtual I3IPAddress& getSource();
    virtual const I3IPAddress& getSource() const {return const_cast<I3SendPacketMessage_Base*>(this)->getSource();}
    virtual void setSource(const I3IPAddress& source);
};


#endif // _I3MESSAGE_M_H_
