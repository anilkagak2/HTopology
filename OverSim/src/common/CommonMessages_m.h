//
// Generated file, do not edit! Created by opp_msgc 4.3 from common/CommonMessages.msg.
//

#ifndef _COMMONMESSAGES_M_H_
#define _COMMONMESSAGES_M_H_

#include <omnetpp.h>

// opp_msgc version check
#define MSGC_VERSION 0x0403
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of opp_msgc: 'make clean' should help.
#endif

// cplusplus {{
#include <OverlayKey.h>
#include <NodeHandle.h>
#include <IPvXAddress.h>
#include <TransportAddress.h>
#include <BinaryValue.h>
#include <Vector2D.h>
#include <OverSimMessage.h>

#define KEY_L OverlayKey::getLength()

static const int TYPE_L = 8;
static const int IPADDR_L = 32;
static const int UDPPORT_L = 16;
static const int HOPCOUNT_L = 16;
static const int NONCE_L = 32;
static const int COMP_L = 16;
static const int NUMSIBLINGS_L = 8;
static const int NUMREDNODES_L = 8;
static const int EXHAUSTIVEFLAG_L = 8;
static const int NEIGHBORSFLAG_L = 8;
static const int RESPONSEFLAG_L = 8;
static const int TRYAGAINFLAG_L = 8;
static const int TIER_L = 8;
static const int ARRAYSIZE_L = 8;
static const int ROUTINGTYPE_L = 8;
static const int SIGNATURE_L = 40*8;
static const int CERT_L = 40*8;
static const int PUBKEY_L = 20*8;
static const int NCSINFO_L = 32;

#define NODEHANDLE_L (IPADDR_L + UDPPORT_L + KEY_L)


#define TRANSPORTADDRESS_L (IPADDR_L + UDPPORT_L)

#define AUTHBLOCK_L (overlay->getMeasureAuthBlock() ? (SIGNATURE_L + CERT_L + PUBKEY_L) : 0)

#define BASEOVERLAY_L(msg) TYPE_L
#define BASEROUTE_L(msg) (BASEOVERLAY_L(msg) + NODEHANDLE_L + KEY_L + \
                          HOPCOUNT_L + ROUTINGTYPE_L +\
                          ARRAYSIZE_L + (msg->getVisitedHopsArraySize() *\
                          TRANSPORTADDRESS_L) +\
                          ARRAYSIZE_L + (msg->getNextHopsArraySize() *\
                          TRANSPORTADDRESS_L) +\
                          ARRAYSIZE_L)
#define BASEAPPDATA_L(msg) (BASEOVERLAY_L(msg) + 2*COMP_L)
#define BASERPC_L(msg) (BASEOVERLAY_L(msg) + NONCE_L + NODEHANDLE_L + \
	                TIER_L)
#define BASECALL_L(msg) BASERPC_L(msg)

#define BASERESPONSE_L(msg) (BASERPC_L(msg) + AUTHBLOCK_L + \
                             ((msg->getNcsInfoArraySize()) ? \
                              (msg->getNcsInfoArraySize() * NCSINFO_L + 8) : \
                              0))
#define FINDNODECALL_L(msg) (BASECALL_L(msg) + KEY_L + NUMSIBLINGS_L + \
                             NUMREDNODES_L + EXHAUSTIVEFLAG_L)

#define FINDNODERESPONSE_L(msg) (BASERESPONSE_L(msg) + NEIGHBORSFLAG_L + \
                  (msg->getClosestNodesArraySize() * NODEHANDLE_L))
#define FAILEDNODECALL_L(msg) (BASECALL_L(msg) + IPADDR_L + UDPPORT_L)
#define FAILEDNODERESPONSE_L(msg) (BASERESPONSE_L(msg) + TRYAGAINFLAG_L)
#define PINGCALL_L(msg) BASECALL_L(msg)
#define PINGRESPONSE_L(msg) BASERESPONSE_L(msg)
#define BOOTSTRAPPINGCALL_L(msg) BASECALL_L(msg)
#define BOOTSTRAPPINGRESPONSE_L(msg) BASERESPONSE_L(msg)
#define NEXTHOPCALL_L(msg) BASECALL_L(msg)
#define NEXTHOPRESPONSE_L(msg) BASERESPONSE_L(msg)
// }}



/**
 * Enum generated from <tt>common/CommonMessages.msg</tt> by opp_msgc.
 * <pre>
 * enum BaseOverlayMessageType
 * {
 * 
 *     OVERLAYSIGNALING = 0;
 *     RPC = 1;
 *     APPDATA = 2;
 *     OVERLAYROUTE = 3;
 * }
 * </pre>
 */
enum BaseOverlayMessageType {
    OVERLAYSIGNALING = 0,
    RPC = 1,
    APPDATA = 2,
    OVERLAYROUTE = 3
};

/**
 * Enum generated from <tt>common/CommonMessages.msg</tt> by opp_msgc.
 * <pre>
 * enum CompType
 * {
 * 
 *     INVALID_COMP = 0;
 *     OVERLAY_COMP = 1;
 *     TIER1_COMP = 2;
 *     TIER2_COMP = 3;
 *     TIER3_COMP = 4;
 *     BOOTSTRAPLIST_COMP = 5;
 *     NEIGHBORCACHE_COMP = 6;
 * }
 * </pre>
 */
enum CompType {
    INVALID_COMP = 0,
    OVERLAY_COMP = 1,
    TIER1_COMP = 2,
    TIER2_COMP = 3,
    TIER3_COMP = 4,
    BOOTSTRAPLIST_COMP = 5,
    NEIGHBORCACHE_COMP = 6
};

/**
 * Enum generated from <tt>common/CommonMessages.msg</tt> by opp_msgc.
 * <pre>
 * enum RoutingType
 * {
 * 
 *     NO_OVERLAY_ROUTING = 0;
 *     DEFAULT_ROUTING = 1;
 *     ITERATIVE_ROUTING = 2;
 *     EXHAUSTIVE_ITERATIVE_ROUTING = 3;
 *     SEMI_RECURSIVE_ROUTING = 4;
 *     FULL_RECURSIVE_ROUTING = 5;
 *     RECURSIVE_SOURCE_ROUTING = 6;
 *     PROX_AWARE_ITERATIVE_ROUTING = 7;
 * }
 * </pre>
 */
enum RoutingType {
    NO_OVERLAY_ROUTING = 0,
    DEFAULT_ROUTING = 1,
    ITERATIVE_ROUTING = 2,
    EXHAUSTIVE_ITERATIVE_ROUTING = 3,
    SEMI_RECURSIVE_ROUTING = 4,
    FULL_RECURSIVE_ROUTING = 5,
    RECURSIVE_SOURCE_ROUTING = 6,
    PROX_AWARE_ITERATIVE_ROUTING = 7
};

/**
 * Enum generated from <tt>common/CommonMessages.msg</tt> by opp_msgc.
 * <pre>
 * enum TransportType
 * {
 * 
 *     INVALID_TRANSPORT = 0;
 *     INTERNAL_TRANSPORT = 1;
 *     UDP_TRANSPORT = 2;
 *     ROUTE_TRANSPORT = 3;
 * }
 * </pre>
 */
enum TransportType {
    INVALID_TRANSPORT = 0,
    INTERNAL_TRANSPORT = 1,
    UDP_TRANSPORT = 2,
    ROUTE_TRANSPORT = 3
};

/**
 * Enum generated from <tt>common/CommonMessages.msg</tt> by opp_msgc.
 * <pre>
 * enum CommonAPIMessageType
 * {
 * 
 *     COMMON_API_UNDEFINED = 0;
 *     KBR_ROUTE = 1;
 *     KBR_DELIVER = 2;
 *     KBR_FORWARD = 3;
 *     KBR_FORWARD_RESPONSE = 4;
 *     KBR_UPDATE = 5;
 * }
 * </pre>
 */
enum CommonAPIMessageType {
    COMMON_API_UNDEFINED = 0,
    KBR_ROUTE = 1,
    KBR_DELIVER = 2,
    KBR_FORWARD = 3,
    KBR_FORWARD_RESPONSE = 4,
    KBR_UPDATE = 5
};

/**
 * Enum generated from <tt>common/CommonMessages.msg</tt> by opp_msgc.
 * <pre>
 * enum StatType
 * {
 * 
 *     MAINTENANCE_STAT = 0;
 *     APP_DATA_STAT = 1;
 *     APP_LOOKUP_STAT = 2;
 * 
 * }
 * </pre>
 */
enum StatType {
    MAINTENANCE_STAT = 0,
    APP_DATA_STAT = 1,
    APP_LOOKUP_STAT = 2
};

/**
 * Enum generated from <tt>common/CommonMessages.msg</tt> by opp_msgc.
 * <pre>
 * enum GameAPIMessageCommand
 * {
 * 
 *     MOVEMENT_INDICATION = 0;
 *     MOVEMENT_REQUEST = 1;
 *     NEIGHBOR_UPDATE = 2;
 *     RESIZE_AOI = 3;
 *     GAMEEVENT_CHAT = 4;
 *     GAMEEVENT_SNOW = 5;
 *     GAMEEVENT_FROZEN = 6;
 * }
 * </pre>
 */
enum GameAPIMessageCommand {
    MOVEMENT_INDICATION = 0,
    MOVEMENT_REQUEST = 1,
    NEIGHBOR_UPDATE = 2,
    RESIZE_AOI = 3,
    GAMEEVENT_CHAT = 4,
    GAMEEVENT_SNOW = 5,
    GAMEEVENT_FROZEN = 6
};

/**
 * Class generated from <tt>common/CommonMessages.msg</tt> by opp_msgc.
 * <pre>
 * class AuthBlock
 * {
 *     BinaryValue signature;
 *     BinaryValue pubKey;
 *     BinaryValue cert;
 * }
 * </pre>
 */
class AuthBlock : public ::cObject
{
  protected:
    BinaryValue signature_var;
    BinaryValue pubKey_var;
    BinaryValue cert_var;

  private:
    void copy(const AuthBlock& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const AuthBlock&);

  public:
    AuthBlock();
    AuthBlock(const AuthBlock& other);
    virtual ~AuthBlock();
    AuthBlock& operator=(const AuthBlock& other);
    virtual AuthBlock *dup() const {return new AuthBlock(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual BinaryValue& getSignature();
    virtual const BinaryValue& getSignature() const {return const_cast<AuthBlock*>(this)->getSignature();}
    virtual void setSignature(const BinaryValue& signature);
    virtual BinaryValue& getPubKey();
    virtual const BinaryValue& getPubKey() const {return const_cast<AuthBlock*>(this)->getPubKey();}
    virtual void setPubKey(const BinaryValue& pubKey);
    virtual BinaryValue& getCert();
    virtual const BinaryValue& getCert() const {return const_cast<AuthBlock*>(this)->getCert();}
    virtual void setCert(const BinaryValue& cert);
};

inline void doPacking(cCommBuffer *b, AuthBlock& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, AuthBlock& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>common/CommonMessages.msg</tt> by opp_msgc.
 * <pre>
 * packet BaseOverlayMessage extends OverSimMessage
 * {
 *     int type enum(BaseOverlayMessageType) = OVERLAYSIGNALING;  
 *     int statType enum(StatType) = MAINTENANCE_STAT; 
 * }
 * </pre>
 */
class BaseOverlayMessage : public ::OverSimMessage
{
  protected:
    int type_var;
    int statType_var;

  private:
    void copy(const BaseOverlayMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const BaseOverlayMessage&);

  public:
    BaseOverlayMessage(const char *name=NULL, int kind=0);
    BaseOverlayMessage(const BaseOverlayMessage& other);
    virtual ~BaseOverlayMessage();
    BaseOverlayMessage& operator=(const BaseOverlayMessage& other);
    virtual BaseOverlayMessage *dup() const {return new BaseOverlayMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getType() const;
    virtual void setType(int type);
    virtual int getStatType() const;
    virtual void setStatType(int statType);
};

inline void doPacking(cCommBuffer *b, BaseOverlayMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, BaseOverlayMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>common/CommonMessages.msg</tt> by opp_msgc.
 * <pre>
 * packet BaseRouteMessage extends BaseOverlayMessage
 * {
 *     OverlayKey destKey;             
 *     NodeHandle srcNode;             
 *     int routingType enum(RoutingType); 
 *     int hopCount = 0;               
 *     TransportAddress visitedHops[]; 
 *     TransportAddress nextHops[];    
 *     simtime_t hopStamp;             
 *     simtime_t hopDelay[];           
 * }
 * </pre>
 */
class BaseRouteMessage : public ::BaseOverlayMessage
{
  protected:
    OverlayKey destKey_var;
    NodeHandle srcNode_var;
    int routingType_var;
    int hopCount_var;
    TransportAddress *visitedHops_var; // array ptr
    unsigned int visitedHops_arraysize;
    TransportAddress *nextHops_var; // array ptr
    unsigned int nextHops_arraysize;
    simtime_t hopStamp_var;
    simtime_t *hopDelay_var; // array ptr
    unsigned int hopDelay_arraysize;

  private:
    void copy(const BaseRouteMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const BaseRouteMessage&);

  public:
    BaseRouteMessage(const char *name=NULL, int kind=0);
    BaseRouteMessage(const BaseRouteMessage& other);
    virtual ~BaseRouteMessage();
    BaseRouteMessage& operator=(const BaseRouteMessage& other);
    virtual BaseRouteMessage *dup() const {return new BaseRouteMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual OverlayKey& getDestKey();
    virtual const OverlayKey& getDestKey() const {return const_cast<BaseRouteMessage*>(this)->getDestKey();}
    virtual void setDestKey(const OverlayKey& destKey);
    virtual NodeHandle& getSrcNode();
    virtual const NodeHandle& getSrcNode() const {return const_cast<BaseRouteMessage*>(this)->getSrcNode();}
    virtual void setSrcNode(const NodeHandle& srcNode);
    virtual int getRoutingType() const;
    virtual void setRoutingType(int routingType);
    virtual int getHopCount() const;
    virtual void setHopCount(int hopCount);
    virtual void setVisitedHopsArraySize(unsigned int size);
    virtual unsigned int getVisitedHopsArraySize() const;
    virtual TransportAddress& getVisitedHops(unsigned int k);
    virtual const TransportAddress& getVisitedHops(unsigned int k) const {return const_cast<BaseRouteMessage*>(this)->getVisitedHops(k);}
    virtual void setVisitedHops(unsigned int k, const TransportAddress& visitedHops);
    virtual void setNextHopsArraySize(unsigned int size);
    virtual unsigned int getNextHopsArraySize() const;
    virtual TransportAddress& getNextHops(unsigned int k);
    virtual const TransportAddress& getNextHops(unsigned int k) const {return const_cast<BaseRouteMessage*>(this)->getNextHops(k);}
    virtual void setNextHops(unsigned int k, const TransportAddress& nextHops);
    virtual simtime_t getHopStamp() const;
    virtual void setHopStamp(simtime_t hopStamp);
    virtual void setHopDelayArraySize(unsigned int size);
    virtual unsigned int getHopDelayArraySize() const;
    virtual simtime_t getHopDelay(unsigned int k) const;
    virtual void setHopDelay(unsigned int k, simtime_t hopDelay);
};

inline void doPacking(cCommBuffer *b, BaseRouteMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, BaseRouteMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>common/CommonMessages.msg</tt> by opp_msgc.
 * <pre>
 * packet BaseAppDataMessage extends BaseOverlayMessage
 * {
 *     int destComp enum(CompType); 
 *     int srcComp enum(CompType);  
 * }
 * </pre>
 */
class BaseAppDataMessage : public ::BaseOverlayMessage
{
  protected:
    int destComp_var;
    int srcComp_var;

  private:
    void copy(const BaseAppDataMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const BaseAppDataMessage&);

  public:
    BaseAppDataMessage(const char *name=NULL, int kind=0);
    BaseAppDataMessage(const BaseAppDataMessage& other);
    virtual ~BaseAppDataMessage();
    BaseAppDataMessage& operator=(const BaseAppDataMessage& other);
    virtual BaseAppDataMessage *dup() const {return new BaseAppDataMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getDestComp() const;
    virtual void setDestComp(int destComp);
    virtual int getSrcComp() const;
    virtual void setSrcComp(int srcComp);
};

inline void doPacking(cCommBuffer *b, BaseAppDataMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, BaseAppDataMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>common/CommonMessages.msg</tt> by opp_msgc.
 * <pre>
 * packet BaseRpcMessage extends BaseOverlayMessage
 * {
 *     unsigned int nonce;  
 *     NodeHandle srcNode;  
 *     AuthBlock authBlock[] @sizetype(uint8_t); 
 * }
 * </pre>
 */
class BaseRpcMessage : public ::BaseOverlayMessage
{
  protected:
    unsigned int nonce_var;
    NodeHandle srcNode_var;
    AuthBlock *authBlock_var; // array ptr
    uint8_t authBlock_arraysize;

  private:
    void copy(const BaseRpcMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const BaseRpcMessage&);

  public:
    BaseRpcMessage(const char *name=NULL, int kind=0);
    BaseRpcMessage(const BaseRpcMessage& other);
    virtual ~BaseRpcMessage();
    BaseRpcMessage& operator=(const BaseRpcMessage& other);
    virtual BaseRpcMessage *dup() const {return new BaseRpcMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned int getNonce() const;
    virtual void setNonce(unsigned int nonce);
    virtual NodeHandle& getSrcNode();
    virtual const NodeHandle& getSrcNode() const {return const_cast<BaseRpcMessage*>(this)->getSrcNode();}
    virtual void setSrcNode(const NodeHandle& srcNode);
    virtual void setAuthBlockArraySize(uint8_t size);
    virtual uint8_t getAuthBlockArraySize() const;
    virtual AuthBlock& getAuthBlock(uint8_t k);
    virtual const AuthBlock& getAuthBlock(uint8_t k) const {return const_cast<BaseRpcMessage*>(this)->getAuthBlock(k);}
    virtual void setAuthBlock(uint8_t k, const AuthBlock& authBlock);
};

inline void doPacking(cCommBuffer *b, BaseRpcMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, BaseRpcMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>common/CommonMessages.msg</tt> by opp_msgc.
 * <pre>
 * packet BaseCallMessage extends BaseRpcMessage
 * {
 * }
 * </pre>
 */
class BaseCallMessage : public ::BaseRpcMessage
{
  protected:

  private:
    void copy(const BaseCallMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const BaseCallMessage&);

  public:
    BaseCallMessage(const char *name=NULL, int kind=0);
    BaseCallMessage(const BaseCallMessage& other);
    virtual ~BaseCallMessage();
    BaseCallMessage& operator=(const BaseCallMessage& other);
    virtual BaseCallMessage *dup() const {return new BaseCallMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, BaseCallMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, BaseCallMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>common/CommonMessages.msg</tt> by opp_msgc.
 * <pre>
 * packet BaseResponseMessage extends BaseRpcMessage
 * {
 *     int callHopCount = 0;
 *     double ncsInfo[]; 
 * }
 * </pre>
 */
class BaseResponseMessage : public ::BaseRpcMessage
{
  protected:
    int callHopCount_var;
    double *ncsInfo_var; // array ptr
    unsigned int ncsInfo_arraysize;

  private:
    void copy(const BaseResponseMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const BaseResponseMessage&);

  public:
    BaseResponseMessage(const char *name=NULL, int kind=0);
    BaseResponseMessage(const BaseResponseMessage& other);
    virtual ~BaseResponseMessage();
    BaseResponseMessage& operator=(const BaseResponseMessage& other);
    virtual BaseResponseMessage *dup() const {return new BaseResponseMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getCallHopCount() const;
    virtual void setCallHopCount(int callHopCount);
    virtual void setNcsInfoArraySize(unsigned int size);
    virtual unsigned int getNcsInfoArraySize() const;
    virtual double getNcsInfo(unsigned int k) const;
    virtual void setNcsInfo(unsigned int k, double ncsInfo);
};

inline void doPacking(cCommBuffer *b, BaseResponseMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, BaseResponseMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>common/CommonMessages.msg</tt> by opp_msgc.
 * <pre>
 * packet RpcTimeoutMessage extends BaseRpcMessage
 * {
 * }
 * </pre>
 */
class RpcTimeoutMessage : public ::BaseRpcMessage
{
  protected:

  private:
    void copy(const RpcTimeoutMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const RpcTimeoutMessage&);

  public:
    RpcTimeoutMessage(const char *name=NULL, int kind=0);
    RpcTimeoutMessage(const RpcTimeoutMessage& other);
    virtual ~RpcTimeoutMessage();
    RpcTimeoutMessage& operator=(const RpcTimeoutMessage& other);
    virtual RpcTimeoutMessage *dup() const {return new RpcTimeoutMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, RpcTimeoutMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, RpcTimeoutMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>common/CommonMessages.msg</tt> by opp_msgc.
 * <pre>
 * packet FindNodeCall extends BaseCallMessage
 * {
 *     OverlayKey lookupKey;   
 *     int numRedundantNodes;  
 *     int numSiblings;        
 *     bool exhaustiveIterative = false; 
 * }
 * </pre>
 */
class FindNodeCall : public ::BaseCallMessage
{
  protected:
    OverlayKey lookupKey_var;
    int numRedundantNodes_var;
    int numSiblings_var;
    bool exhaustiveIterative_var;

  private:
    void copy(const FindNodeCall& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const FindNodeCall&);

  public:
    FindNodeCall(const char *name=NULL, int kind=0);
    FindNodeCall(const FindNodeCall& other);
    virtual ~FindNodeCall();
    FindNodeCall& operator=(const FindNodeCall& other);
    virtual FindNodeCall *dup() const {return new FindNodeCall(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual OverlayKey& getLookupKey();
    virtual const OverlayKey& getLookupKey() const {return const_cast<FindNodeCall*>(this)->getLookupKey();}
    virtual void setLookupKey(const OverlayKey& lookupKey);
    virtual int getNumRedundantNodes() const;
    virtual void setNumRedundantNodes(int numRedundantNodes);
    virtual int getNumSiblings() const;
    virtual void setNumSiblings(int numSiblings);
    virtual bool getExhaustiveIterative() const;
    virtual void setExhaustiveIterative(bool exhaustiveIterative);
};

inline void doPacking(cCommBuffer *b, FindNodeCall& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, FindNodeCall& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>common/CommonMessages.msg</tt> by opp_msgc.
 * <pre>
 * packet FindNodeResponse extends BaseResponseMessage
 * {
 *     
 *     bool siblings;
 *     NodeHandle closestNodes[];  
 * }
 * </pre>
 */
class FindNodeResponse : public ::BaseResponseMessage
{
  protected:
    bool siblings_var;
    NodeHandle *closestNodes_var; // array ptr
    unsigned int closestNodes_arraysize;

  private:
    void copy(const FindNodeResponse& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const FindNodeResponse&);

  public:
    FindNodeResponse(const char *name=NULL, int kind=0);
    FindNodeResponse(const FindNodeResponse& other);
    virtual ~FindNodeResponse();
    FindNodeResponse& operator=(const FindNodeResponse& other);
    virtual FindNodeResponse *dup() const {return new FindNodeResponse(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual bool getSiblings() const;
    virtual void setSiblings(bool siblings);
    virtual void setClosestNodesArraySize(unsigned int size);
    virtual unsigned int getClosestNodesArraySize() const;
    virtual NodeHandle& getClosestNodes(unsigned int k);
    virtual const NodeHandle& getClosestNodes(unsigned int k) const {return const_cast<FindNodeResponse*>(this)->getClosestNodes(k);}
    virtual void setClosestNodes(unsigned int k, const NodeHandle& closestNodes);
};

inline void doPacking(cCommBuffer *b, FindNodeResponse& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, FindNodeResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>common/CommonMessages.msg</tt> by opp_msgc.
 * <pre>
 * packet FailedNodeCall extends BaseCallMessage
 * {
 *     TransportAddress failedNode;
 * }
 * </pre>
 */
class FailedNodeCall : public ::BaseCallMessage
{
  protected:
    TransportAddress failedNode_var;

  private:
    void copy(const FailedNodeCall& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const FailedNodeCall&);

  public:
    FailedNodeCall(const char *name=NULL, int kind=0);
    FailedNodeCall(const FailedNodeCall& other);
    virtual ~FailedNodeCall();
    FailedNodeCall& operator=(const FailedNodeCall& other);
    virtual FailedNodeCall *dup() const {return new FailedNodeCall(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual TransportAddress& getFailedNode();
    virtual const TransportAddress& getFailedNode() const {return const_cast<FailedNodeCall*>(this)->getFailedNode();}
    virtual void setFailedNode(const TransportAddress& failedNode);
};

inline void doPacking(cCommBuffer *b, FailedNodeCall& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, FailedNodeCall& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>common/CommonMessages.msg</tt> by opp_msgc.
 * <pre>
 * packet FailedNodeResponse extends BaseResponseMessage
 * {
 *     bool tryAgain;
 * }
 * </pre>
 */
class FailedNodeResponse : public ::BaseResponseMessage
{
  protected:
    bool tryAgain_var;

  private:
    void copy(const FailedNodeResponse& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const FailedNodeResponse&);

  public:
    FailedNodeResponse(const char *name=NULL, int kind=0);
    FailedNodeResponse(const FailedNodeResponse& other);
    virtual ~FailedNodeResponse();
    FailedNodeResponse& operator=(const FailedNodeResponse& other);
    virtual FailedNodeResponse *dup() const {return new FailedNodeResponse(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual bool getTryAgain() const;
    virtual void setTryAgain(bool tryAgain);
};

inline void doPacking(cCommBuffer *b, FailedNodeResponse& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, FailedNodeResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>common/CommonMessages.msg</tt> by opp_msgc.
 * <pre>
 * packet PingCall extends BaseCallMessage
 * {
 * }
 * </pre>
 */
class PingCall : public ::BaseCallMessage
{
  protected:

  private:
    void copy(const PingCall& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PingCall&);

  public:
    PingCall(const char *name=NULL, int kind=0);
    PingCall(const PingCall& other);
    virtual ~PingCall();
    PingCall& operator=(const PingCall& other);
    virtual PingCall *dup() const {return new PingCall(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, PingCall& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, PingCall& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>common/CommonMessages.msg</tt> by opp_msgc.
 * <pre>
 * packet PingResponse extends BaseResponseMessage
 * {
 * }
 * </pre>
 */
class PingResponse : public ::BaseResponseMessage
{
  protected:

  private:
    void copy(const PingResponse& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PingResponse&);

  public:
    PingResponse(const char *name=NULL, int kind=0);
    PingResponse(const PingResponse& other);
    virtual ~PingResponse();
    PingResponse& operator=(const PingResponse& other);
    virtual PingResponse *dup() const {return new PingResponse(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, PingResponse& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, PingResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>common/CommonMessages.msg</tt> by opp_msgc.
 * <pre>
 * packet CompReadyMessage
 * {
 *     bool ready;              
 *     int comp enum(CompType); 
 *     OverlayKey nodeId = OverlayKey::UNSPECIFIED_KEY;
 * }
 * </pre>
 */
class CompReadyMessage : public ::cPacket
{
  protected:
    bool ready_var;
    int comp_var;
    OverlayKey nodeId_var;

  private:
    void copy(const CompReadyMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const CompReadyMessage&);

  public:
    CompReadyMessage(const char *name=NULL, int kind=0);
    CompReadyMessage(const CompReadyMessage& other);
    virtual ~CompReadyMessage();
    CompReadyMessage& operator=(const CompReadyMessage& other);
    virtual CompReadyMessage *dup() const {return new CompReadyMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual bool getReady() const;
    virtual void setReady(bool ready);
    virtual int getComp() const;
    virtual void setComp(int comp);
    virtual OverlayKey& getNodeId();
    virtual const OverlayKey& getNodeId() const {return const_cast<CompReadyMessage*>(this)->getNodeId();}
    virtual void setNodeId(const OverlayKey& nodeId);
};

inline void doPacking(cCommBuffer *b, CompReadyMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, CompReadyMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>common/CommonMessages.msg</tt> by opp_msgc.
 * <pre>
 * packet BootstrapLookupMessage extends BaseOverlayMessage
 * {
 * }
 * </pre>
 */
class BootstrapLookupMessage : public ::BaseOverlayMessage
{
  protected:

  private:
    void copy(const BootstrapLookupMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const BootstrapLookupMessage&);

  public:
    BootstrapLookupMessage(const char *name=NULL, int kind=0);
    BootstrapLookupMessage(const BootstrapLookupMessage& other);
    virtual ~BootstrapLookupMessage();
    BootstrapLookupMessage& operator=(const BootstrapLookupMessage& other);
    virtual BootstrapLookupMessage *dup() const {return new BootstrapLookupMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, BootstrapLookupMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, BootstrapLookupMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>common/CommonMessages.msg</tt> by opp_msgc.
 * <pre>
 * packet NextHopCall extends BaseCallMessage
 * {
 * }
 * </pre>
 */
class NextHopCall : public ::BaseCallMessage
{
  protected:

  private:
    void copy(const NextHopCall& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NextHopCall&);

  public:
    NextHopCall(const char *name=NULL, int kind=0);
    NextHopCall(const NextHopCall& other);
    virtual ~NextHopCall();
    NextHopCall& operator=(const NextHopCall& other);
    virtual NextHopCall *dup() const {return new NextHopCall(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, NextHopCall& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, NextHopCall& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>common/CommonMessages.msg</tt> by opp_msgc.
 * <pre>
 * packet NextHopResponse extends BaseResponseMessage
 * {
 * }
 * </pre>
 */
class NextHopResponse : public ::BaseResponseMessage
{
  protected:

  private:
    void copy(const NextHopResponse& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NextHopResponse&);

  public:
    NextHopResponse(const char *name=NULL, int kind=0);
    NextHopResponse(const NextHopResponse& other);
    virtual ~NextHopResponse();
    NextHopResponse& operator=(const NextHopResponse& other);
    virtual NextHopResponse *dup() const {return new NextHopResponse(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, NextHopResponse& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, NextHopResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>common/CommonMessages.msg</tt> by opp_msgc.
 * <pre>
 * message SingleHostUnderlayPacketNotification
 * {
 * }
 * </pre>
 */
class SingleHostUnderlayPacketNotification : public ::cMessage
{
  protected:

  private:
    void copy(const SingleHostUnderlayPacketNotification& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SingleHostUnderlayPacketNotification&);

  public:
    SingleHostUnderlayPacketNotification(const char *name=NULL, int kind=0);
    SingleHostUnderlayPacketNotification(const SingleHostUnderlayPacketNotification& other);
    virtual ~SingleHostUnderlayPacketNotification();
    SingleHostUnderlayPacketNotification& operator=(const SingleHostUnderlayPacketNotification& other);
    virtual SingleHostUnderlayPacketNotification *dup() const {return new SingleHostUnderlayPacketNotification(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, SingleHostUnderlayPacketNotification& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, SingleHostUnderlayPacketNotification& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>common/CommonMessages.msg</tt> by opp_msgc.
 * <pre>
 * message TcpDataMessage
 * {
 *     BinaryValue data;
 * }
 * </pre>
 */
class TcpDataMessage : public ::cMessage
{
  protected:
    BinaryValue data_var;

  private:
    void copy(const TcpDataMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const TcpDataMessage&);

  public:
    TcpDataMessage(const char *name=NULL, int kind=0);
    TcpDataMessage(const TcpDataMessage& other);
    virtual ~TcpDataMessage();
    TcpDataMessage& operator=(const TcpDataMessage& other);
    virtual TcpDataMessage *dup() const {return new TcpDataMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual BinaryValue& getData();
    virtual const BinaryValue& getData() const {return const_cast<TcpDataMessage*>(this)->getData();}
    virtual void setData(const BinaryValue& data);
};

inline void doPacking(cCommBuffer *b, TcpDataMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, TcpDataMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>common/CommonMessages.msg</tt> by opp_msgc.
 * <pre>
 * packet CommonAPIMessage
 * {
 *     int type enum(CommonAPIMessageType) = COMMON_API_UNDEFINED;  
 * }
 * </pre>
 */
class CommonAPIMessage : public ::cPacket
{
  protected:
    int type_var;

  private:
    void copy(const CommonAPIMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const CommonAPIMessage&);

  public:
    CommonAPIMessage(const char *name=NULL, int kind=0);
    CommonAPIMessage(const CommonAPIMessage& other);
    virtual ~CommonAPIMessage();
    CommonAPIMessage& operator=(const CommonAPIMessage& other);
    virtual CommonAPIMessage *dup() const {return new CommonAPIMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getType() const;
    virtual void setType(int type);
};

inline void doPacking(cCommBuffer *b, CommonAPIMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, CommonAPIMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>common/CommonMessages.msg</tt> by opp_msgc.
 * <pre>
 * packet KBRroute extends CommonAPIMessage
 * {
 *     OverlayKey destKey;                
 *     int destComp enum(CompType);       
 *     int srcComp enum(CompType);        
 *     TransportAddress sourceRoute[];    
 *     int routingType enum(RoutingType); 
 * }
 * </pre>
 */
class KBRroute : public ::CommonAPIMessage
{
  protected:
    OverlayKey destKey_var;
    int destComp_var;
    int srcComp_var;
    TransportAddress *sourceRoute_var; // array ptr
    unsigned int sourceRoute_arraysize;
    int routingType_var;

  private:
    void copy(const KBRroute& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const KBRroute&);

  public:
    KBRroute(const char *name=NULL, int kind=0);
    KBRroute(const KBRroute& other);
    virtual ~KBRroute();
    KBRroute& operator=(const KBRroute& other);
    virtual KBRroute *dup() const {return new KBRroute(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual OverlayKey& getDestKey();
    virtual const OverlayKey& getDestKey() const {return const_cast<KBRroute*>(this)->getDestKey();}
    virtual void setDestKey(const OverlayKey& destKey);
    virtual int getDestComp() const;
    virtual void setDestComp(int destComp);
    virtual int getSrcComp() const;
    virtual void setSrcComp(int srcComp);
    virtual void setSourceRouteArraySize(unsigned int size);
    virtual unsigned int getSourceRouteArraySize() const;
    virtual TransportAddress& getSourceRoute(unsigned int k);
    virtual const TransportAddress& getSourceRoute(unsigned int k) const {return const_cast<KBRroute*>(this)->getSourceRoute(k);}
    virtual void setSourceRoute(unsigned int k, const TransportAddress& sourceRoute);
    virtual int getRoutingType() const;
    virtual void setRoutingType(int routingType);
};

inline void doPacking(cCommBuffer *b, KBRroute& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, KBRroute& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>common/CommonMessages.msg</tt> by opp_msgc.
 * <pre>
 * packet KBRforward extends CommonAPIMessage
 * {
 *     OverlayKey destKey;     
 *     NodeHandle nextHopNode; 
 * }
 * </pre>
 */
class KBRforward : public ::CommonAPIMessage
{
  protected:
    OverlayKey destKey_var;
    NodeHandle nextHopNode_var;

  private:
    void copy(const KBRforward& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const KBRforward&);

  public:
    KBRforward(const char *name=NULL, int kind=0);
    KBRforward(const KBRforward& other);
    virtual ~KBRforward();
    KBRforward& operator=(const KBRforward& other);
    virtual KBRforward *dup() const {return new KBRforward(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual OverlayKey& getDestKey();
    virtual const OverlayKey& getDestKey() const {return const_cast<KBRforward*>(this)->getDestKey();}
    virtual void setDestKey(const OverlayKey& destKey);
    virtual NodeHandle& getNextHopNode();
    virtual const NodeHandle& getNextHopNode() const {return const_cast<KBRforward*>(this)->getNextHopNode();}
    virtual void setNextHopNode(const NodeHandle& nextHopNode);
};

inline void doPacking(cCommBuffer *b, KBRforward& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, KBRforward& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>common/CommonMessages.msg</tt> by opp_msgc.
 * <pre>
 * packet KBRdeliver extends CommonAPIMessage
 * {
 *     OverlayKey destKey; 
 * }
 * </pre>
 */
class KBRdeliver : public ::CommonAPIMessage
{
  protected:
    OverlayKey destKey_var;

  private:
    void copy(const KBRdeliver& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const KBRdeliver&);

  public:
    KBRdeliver(const char *name=NULL, int kind=0);
    KBRdeliver(const KBRdeliver& other);
    virtual ~KBRdeliver();
    KBRdeliver& operator=(const KBRdeliver& other);
    virtual KBRdeliver *dup() const {return new KBRdeliver(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual OverlayKey& getDestKey();
    virtual const OverlayKey& getDestKey() const {return const_cast<KBRdeliver*>(this)->getDestKey();}
    virtual void setDestKey(const OverlayKey& destKey);
};

inline void doPacking(cCommBuffer *b, KBRdeliver& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, KBRdeliver& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>common/CommonMessages.msg</tt> by opp_msgc.
 * <pre>
 * packet KBRupdate extends CommonAPIMessage
 * {
 *     NodeHandle node; 
 *     bool joined; 
 * }
 * </pre>
 */
class KBRupdate : public ::CommonAPIMessage
{
  protected:
    NodeHandle node_var;
    bool joined_var;

  private:
    void copy(const KBRupdate& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const KBRupdate&);

  public:
    KBRupdate(const char *name=NULL, int kind=0);
    KBRupdate(const KBRupdate& other);
    virtual ~KBRupdate();
    KBRupdate& operator=(const KBRupdate& other);
    virtual KBRupdate *dup() const {return new KBRupdate(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual NodeHandle& getNode();
    virtual const NodeHandle& getNode() const {return const_cast<KBRupdate*>(this)->getNode();}
    virtual void setNode(const NodeHandle& node);
    virtual bool getJoined() const;
    virtual void setJoined(bool joined);
};

inline void doPacking(cCommBuffer *b, KBRupdate& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, KBRupdate& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>common/CommonMessages.msg</tt> by opp_msgc.
 * <pre>
 * class DhtDumpEntry
 * {
 *     OverlayKey key;
 *     uint32_t kind;
 *     uint32_t id;
 *     BinaryValue value;
 *     int ttl;
 *     NodeHandle ownerNode;
 *     bool is_modifiable;
 *     bool responsible;
 * }
 * </pre>
 */
class DhtDumpEntry : public ::cObject
{
  protected:
    OverlayKey key_var;
    uint32_t kind_var;
    uint32_t id_var;
    BinaryValue value_var;
    int ttl_var;
    NodeHandle ownerNode_var;
    bool is_modifiable_var;
    bool responsible_var;

  private:
    void copy(const DhtDumpEntry& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const DhtDumpEntry&);

  public:
    DhtDumpEntry();
    DhtDumpEntry(const DhtDumpEntry& other);
    virtual ~DhtDumpEntry();
    DhtDumpEntry& operator=(const DhtDumpEntry& other);
    virtual DhtDumpEntry *dup() const {return new DhtDumpEntry(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual OverlayKey& getKey();
    virtual const OverlayKey& getKey() const {return const_cast<DhtDumpEntry*>(this)->getKey();}
    virtual void setKey(const OverlayKey& key);
    virtual uint32_t getKind() const;
    virtual void setKind(uint32_t kind);
    virtual uint32_t getId() const;
    virtual void setId(uint32_t id);
    virtual BinaryValue& getValue();
    virtual const BinaryValue& getValue() const {return const_cast<DhtDumpEntry*>(this)->getValue();}
    virtual void setValue(const BinaryValue& value);
    virtual int getTtl() const;
    virtual void setTtl(int ttl);
    virtual NodeHandle& getOwnerNode();
    virtual const NodeHandle& getOwnerNode() const {return const_cast<DhtDumpEntry*>(this)->getOwnerNode();}
    virtual void setOwnerNode(const NodeHandle& ownerNode);
    virtual bool getIs_modifiable() const;
    virtual void setIs_modifiable(bool is_modifiable);
    virtual bool getResponsible() const;
    virtual void setResponsible(bool responsible);
};

inline void doPacking(cCommBuffer *b, DhtDumpEntry& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, DhtDumpEntry& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>common/CommonMessages.msg</tt> by opp_msgc.
 * <pre>
 * packet DHTputCAPICall extends BaseCallMessage
 * {
 *     OverlayKey key; 
 *     uint32_t kind = 1; 
 *     uint32_t id = 1; 
 *     BinaryValue value; 
 *     int ttl; 
 *     bool isModifiable; 
 * }
 * </pre>
 */
class DHTputCAPICall : public ::BaseCallMessage
{
  protected:
    OverlayKey key_var;
    uint32_t kind_var;
    uint32_t id_var;
    BinaryValue value_var;
    int ttl_var;
    bool isModifiable_var;

  private:
    void copy(const DHTputCAPICall& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const DHTputCAPICall&);

  public:
    DHTputCAPICall(const char *name=NULL, int kind=0);
    DHTputCAPICall(const DHTputCAPICall& other);
    virtual ~DHTputCAPICall();
    DHTputCAPICall& operator=(const DHTputCAPICall& other);
    virtual DHTputCAPICall *dup() const {return new DHTputCAPICall(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual OverlayKey& getKey();
    virtual const OverlayKey& getKey() const {return const_cast<DHTputCAPICall*>(this)->getKey();}
    virtual void setKey(const OverlayKey& key);
    virtual uint32_t getKind() const;
    virtual void setKind(uint32_t kind);
    virtual uint32_t getId() const;
    virtual void setId(uint32_t id);
    virtual BinaryValue& getValue();
    virtual const BinaryValue& getValue() const {return const_cast<DHTputCAPICall*>(this)->getValue();}
    virtual void setValue(const BinaryValue& value);
    virtual int getTtl() const;
    virtual void setTtl(int ttl);
    virtual bool getIsModifiable() const;
    virtual void setIsModifiable(bool isModifiable);
};

inline void doPacking(cCommBuffer *b, DHTputCAPICall& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, DHTputCAPICall& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>common/CommonMessages.msg</tt> by opp_msgc.
 * <pre>
 * packet DHTgetCAPICall extends BaseCallMessage
 * {
 *     OverlayKey key; 
 *     uint32_t kind = 1; 
 *     uint32_t id = 1; 
 * }
 * </pre>
 */
class DHTgetCAPICall : public ::BaseCallMessage
{
  protected:
    OverlayKey key_var;
    uint32_t kind_var;
    uint32_t id_var;

  private:
    void copy(const DHTgetCAPICall& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const DHTgetCAPICall&);

  public:
    DHTgetCAPICall(const char *name=NULL, int kind=0);
    DHTgetCAPICall(const DHTgetCAPICall& other);
    virtual ~DHTgetCAPICall();
    DHTgetCAPICall& operator=(const DHTgetCAPICall& other);
    virtual DHTgetCAPICall *dup() const {return new DHTgetCAPICall(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual OverlayKey& getKey();
    virtual const OverlayKey& getKey() const {return const_cast<DHTgetCAPICall*>(this)->getKey();}
    virtual void setKey(const OverlayKey& key);
    virtual uint32_t getKind() const;
    virtual void setKind(uint32_t kind);
    virtual uint32_t getId() const;
    virtual void setId(uint32_t id);
};

inline void doPacking(cCommBuffer *b, DHTgetCAPICall& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, DHTgetCAPICall& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>common/CommonMessages.msg</tt> by opp_msgc.
 * <pre>
 * packet DHTputCAPIResponse extends BaseResponseMessage
 * {
 *     bool isSuccess;
 * }
 * </pre>
 */
class DHTputCAPIResponse : public ::BaseResponseMessage
{
  protected:
    bool isSuccess_var;

  private:
    void copy(const DHTputCAPIResponse& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const DHTputCAPIResponse&);

  public:
    DHTputCAPIResponse(const char *name=NULL, int kind=0);
    DHTputCAPIResponse(const DHTputCAPIResponse& other);
    virtual ~DHTputCAPIResponse();
    DHTputCAPIResponse& operator=(const DHTputCAPIResponse& other);
    virtual DHTputCAPIResponse *dup() const {return new DHTputCAPIResponse(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual bool getIsSuccess() const;
    virtual void setIsSuccess(bool isSuccess);
};

inline void doPacking(cCommBuffer *b, DHTputCAPIResponse& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, DHTputCAPIResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>common/CommonMessages.msg</tt> by opp_msgc.
 * <pre>
 * packet DHTgetCAPIResponse extends BaseResponseMessage
 * {
 *     DhtDumpEntry result[]; 
 *     bool isSuccess;
 * }
 * </pre>
 */
class DHTgetCAPIResponse : public ::BaseResponseMessage
{
  protected:
    DhtDumpEntry *result_var; // array ptr
    unsigned int result_arraysize;
    bool isSuccess_var;

  private:
    void copy(const DHTgetCAPIResponse& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const DHTgetCAPIResponse&);

  public:
    DHTgetCAPIResponse(const char *name=NULL, int kind=0);
    DHTgetCAPIResponse(const DHTgetCAPIResponse& other);
    virtual ~DHTgetCAPIResponse();
    DHTgetCAPIResponse& operator=(const DHTgetCAPIResponse& other);
    virtual DHTgetCAPIResponse *dup() const {return new DHTgetCAPIResponse(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual void setResultArraySize(unsigned int size);
    virtual unsigned int getResultArraySize() const;
    virtual DhtDumpEntry& getResult(unsigned int k);
    virtual const DhtDumpEntry& getResult(unsigned int k) const {return const_cast<DHTgetCAPIResponse*>(this)->getResult(k);}
    virtual void setResult(unsigned int k, const DhtDumpEntry& result);
    virtual bool getIsSuccess() const;
    virtual void setIsSuccess(bool isSuccess);
};

inline void doPacking(cCommBuffer *b, DHTgetCAPIResponse& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, DHTgetCAPIResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>common/CommonMessages.msg</tt> by opp_msgc.
 * <pre>
 * packet DHTdumpCall extends BaseCallMessage
 * {
 * }
 * </pre>
 */
class DHTdumpCall : public ::BaseCallMessage
{
  protected:

  private:
    void copy(const DHTdumpCall& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const DHTdumpCall&);

  public:
    DHTdumpCall(const char *name=NULL, int kind=0);
    DHTdumpCall(const DHTdumpCall& other);
    virtual ~DHTdumpCall();
    DHTdumpCall& operator=(const DHTdumpCall& other);
    virtual DHTdumpCall *dup() const {return new DHTdumpCall(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, DHTdumpCall& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, DHTdumpCall& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>common/CommonMessages.msg</tt> by opp_msgc.
 * <pre>
 * packet DHTdumpResponse extends BaseResponseMessage
 * {
 *     DhtDumpEntry record[]; 
 * }
 * </pre>
 */
class DHTdumpResponse : public ::BaseResponseMessage
{
  protected:
    DhtDumpEntry *record_var; // array ptr
    unsigned int record_arraysize;

  private:
    void copy(const DHTdumpResponse& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const DHTdumpResponse&);

  public:
    DHTdumpResponse(const char *name=NULL, int kind=0);
    DHTdumpResponse(const DHTdumpResponse& other);
    virtual ~DHTdumpResponse();
    DHTdumpResponse& operator=(const DHTdumpResponse& other);
    virtual DHTdumpResponse *dup() const {return new DHTdumpResponse(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual void setRecordArraySize(unsigned int size);
    virtual unsigned int getRecordArraySize() const;
    virtual DhtDumpEntry& getRecord(unsigned int k);
    virtual const DhtDumpEntry& getRecord(unsigned int k) const {return const_cast<DHTdumpResponse*>(this)->getRecord(k);}
    virtual void setRecord(unsigned int k, const DhtDumpEntry& record);
};

inline void doPacking(cCommBuffer *b, DHTdumpResponse& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, DHTdumpResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>common/CommonMessages.msg</tt> by opp_msgc.
 * <pre>
 * packet LookupCall extends BaseCallMessage
 * {
 *     OverlayKey key;
 *     int numSiblings;
 *     int routingType enum(RoutingType) = DEFAULT_ROUTING;
 * }
 * </pre>
 */
class LookupCall : public ::BaseCallMessage
{
  protected:
    OverlayKey key_var;
    int numSiblings_var;
    int routingType_var;

  private:
    void copy(const LookupCall& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const LookupCall&);

  public:
    LookupCall(const char *name=NULL, int kind=0);
    LookupCall(const LookupCall& other);
    virtual ~LookupCall();
    LookupCall& operator=(const LookupCall& other);
    virtual LookupCall *dup() const {return new LookupCall(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual OverlayKey& getKey();
    virtual const OverlayKey& getKey() const {return const_cast<LookupCall*>(this)->getKey();}
    virtual void setKey(const OverlayKey& key);
    virtual int getNumSiblings() const;
    virtual void setNumSiblings(int numSiblings);
    virtual int getRoutingType() const;
    virtual void setRoutingType(int routingType);
};

inline void doPacking(cCommBuffer *b, LookupCall& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, LookupCall& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>common/CommonMessages.msg</tt> by opp_msgc.
 * <pre>
 * packet LookupResponse extends BaseResponseMessage
 * {
 *     OverlayKey key;        
 *     int hopCount = 0;      
 *     bool isValid;          
 *     NodeHandle siblings[]; 
 * }
 * </pre>
 */
class LookupResponse : public ::BaseResponseMessage
{
  protected:
    OverlayKey key_var;
    int hopCount_var;
    bool isValid_var;
    NodeHandle *siblings_var; // array ptr
    unsigned int siblings_arraysize;

  private:
    void copy(const LookupResponse& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const LookupResponse&);

  public:
    LookupResponse(const char *name=NULL, int kind=0);
    LookupResponse(const LookupResponse& other);
    virtual ~LookupResponse();
    LookupResponse& operator=(const LookupResponse& other);
    virtual LookupResponse *dup() const {return new LookupResponse(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual OverlayKey& getKey();
    virtual const OverlayKey& getKey() const {return const_cast<LookupResponse*>(this)->getKey();}
    virtual void setKey(const OverlayKey& key);
    virtual int getHopCount() const;
    virtual void setHopCount(int hopCount);
    virtual bool getIsValid() const;
    virtual void setIsValid(bool isValid);
    virtual void setSiblingsArraySize(unsigned int size);
    virtual unsigned int getSiblingsArraySize() const;
    virtual NodeHandle& getSiblings(unsigned int k);
    virtual const NodeHandle& getSiblings(unsigned int k) const {return const_cast<LookupResponse*>(this)->getSiblings(k);}
    virtual void setSiblings(unsigned int k, const NodeHandle& siblings);
};

inline void doPacking(cCommBuffer *b, LookupResponse& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, LookupResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>common/CommonMessages.msg</tt> by opp_msgc.
 * <pre>
 * packet P2pnsRegisterCall extends BaseCallMessage
 * {
 *     BinaryValue p2pName; 
 *     uint32_t kind = 1; 
 *     uint32_t id = 1;  
 *     BinaryValue address; 
 *     int ttl;             
 * }
 * </pre>
 */
class P2pnsRegisterCall : public ::BaseCallMessage
{
  protected:
    BinaryValue p2pName_var;
    uint32_t kind_var;
    uint32_t id_var;
    BinaryValue address_var;
    int ttl_var;

  private:
    void copy(const P2pnsRegisterCall& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const P2pnsRegisterCall&);

  public:
    P2pnsRegisterCall(const char *name=NULL, int kind=0);
    P2pnsRegisterCall(const P2pnsRegisterCall& other);
    virtual ~P2pnsRegisterCall();
    P2pnsRegisterCall& operator=(const P2pnsRegisterCall& other);
    virtual P2pnsRegisterCall *dup() const {return new P2pnsRegisterCall(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual BinaryValue& getP2pName();
    virtual const BinaryValue& getP2pName() const {return const_cast<P2pnsRegisterCall*>(this)->getP2pName();}
    virtual void setP2pName(const BinaryValue& p2pName);
    virtual uint32_t getKind() const;
    virtual void setKind(uint32_t kind);
    virtual uint32_t getId() const;
    virtual void setId(uint32_t id);
    virtual BinaryValue& getAddress();
    virtual const BinaryValue& getAddress() const {return const_cast<P2pnsRegisterCall*>(this)->getAddress();}
    virtual void setAddress(const BinaryValue& address);
    virtual int getTtl() const;
    virtual void setTtl(int ttl);
};

inline void doPacking(cCommBuffer *b, P2pnsRegisterCall& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, P2pnsRegisterCall& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>common/CommonMessages.msg</tt> by opp_msgc.
 * <pre>
 * packet P2pnsRegisterResponse extends BaseResponseMessage
 * {
 *     BinaryValue p2pName;  
 *     BinaryValue address;  
 *     bool isSuccess;       
 * }
 * </pre>
 */
class P2pnsRegisterResponse : public ::BaseResponseMessage
{
  protected:
    BinaryValue p2pName_var;
    BinaryValue address_var;
    bool isSuccess_var;

  private:
    void copy(const P2pnsRegisterResponse& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const P2pnsRegisterResponse&);

  public:
    P2pnsRegisterResponse(const char *name=NULL, int kind=0);
    P2pnsRegisterResponse(const P2pnsRegisterResponse& other);
    virtual ~P2pnsRegisterResponse();
    P2pnsRegisterResponse& operator=(const P2pnsRegisterResponse& other);
    virtual P2pnsRegisterResponse *dup() const {return new P2pnsRegisterResponse(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual BinaryValue& getP2pName();
    virtual const BinaryValue& getP2pName() const {return const_cast<P2pnsRegisterResponse*>(this)->getP2pName();}
    virtual void setP2pName(const BinaryValue& p2pName);
    virtual BinaryValue& getAddress();
    virtual const BinaryValue& getAddress() const {return const_cast<P2pnsRegisterResponse*>(this)->getAddress();}
    virtual void setAddress(const BinaryValue& address);
    virtual bool getIsSuccess() const;
    virtual void setIsSuccess(bool isSuccess);
};

inline void doPacking(cCommBuffer *b, P2pnsRegisterResponse& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, P2pnsRegisterResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>common/CommonMessages.msg</tt> by opp_msgc.
 * <pre>
 * packet P2pnsResolveCall extends BaseCallMessage
 * {
 *     BinaryValue p2pName;    
 *     uint32_t kind = 1; 
 *     uint32_t id = 1; 
 * }
 * </pre>
 */
class P2pnsResolveCall : public ::BaseCallMessage
{
  protected:
    BinaryValue p2pName_var;
    uint32_t kind_var;
    uint32_t id_var;

  private:
    void copy(const P2pnsResolveCall& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const P2pnsResolveCall&);

  public:
    P2pnsResolveCall(const char *name=NULL, int kind=0);
    P2pnsResolveCall(const P2pnsResolveCall& other);
    virtual ~P2pnsResolveCall();
    P2pnsResolveCall& operator=(const P2pnsResolveCall& other);
    virtual P2pnsResolveCall *dup() const {return new P2pnsResolveCall(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual BinaryValue& getP2pName();
    virtual const BinaryValue& getP2pName() const {return const_cast<P2pnsResolveCall*>(this)->getP2pName();}
    virtual void setP2pName(const BinaryValue& p2pName);
    virtual uint32_t getKind() const;
    virtual void setKind(uint32_t kind);
    virtual uint32_t getId() const;
    virtual void setId(uint32_t id);
};

inline void doPacking(cCommBuffer *b, P2pnsResolveCall& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, P2pnsResolveCall& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>common/CommonMessages.msg</tt> by opp_msgc.
 * <pre>
 * packet P2pnsResolveResponse extends BaseResponseMessage
 * {
 *     BinaryValue p2pName;  
 *     BinaryValue address[];  
 *     uint32_t kind[];
 *     uint32_t id[];
 *     bool isSuccess;       
 * }
 * </pre>
 */
class P2pnsResolveResponse : public ::BaseResponseMessage
{
  protected:
    BinaryValue p2pName_var;
    BinaryValue *address_var; // array ptr
    unsigned int address_arraysize;
    uint32_t *kind_var; // array ptr
    unsigned int kind_arraysize;
    uint32_t *id_var; // array ptr
    unsigned int id_arraysize;
    bool isSuccess_var;

  private:
    void copy(const P2pnsResolveResponse& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const P2pnsResolveResponse&);

  public:
    P2pnsResolveResponse(const char *name=NULL, int kind=0);
    P2pnsResolveResponse(const P2pnsResolveResponse& other);
    virtual ~P2pnsResolveResponse();
    P2pnsResolveResponse& operator=(const P2pnsResolveResponse& other);
    virtual P2pnsResolveResponse *dup() const {return new P2pnsResolveResponse(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual BinaryValue& getP2pName();
    virtual const BinaryValue& getP2pName() const {return const_cast<P2pnsResolveResponse*>(this)->getP2pName();}
    virtual void setP2pName(const BinaryValue& p2pName);
    virtual void setAddressArraySize(unsigned int size);
    virtual unsigned int getAddressArraySize() const;
    virtual BinaryValue& getAddress(unsigned int k);
    virtual const BinaryValue& getAddress(unsigned int k) const {return const_cast<P2pnsResolveResponse*>(this)->getAddress(k);}
    virtual void setAddress(unsigned int k, const BinaryValue& address);
    virtual void setKindArraySize(unsigned int size);
    virtual unsigned int getKindArraySize() const;
    virtual uint32_t getKind(unsigned int k) const;
    virtual void setKind(unsigned int k, uint32_t kind);
    virtual void setIdArraySize(unsigned int size);
    virtual unsigned int getIdArraySize() const;
    virtual uint32_t getId(unsigned int k) const;
    virtual void setId(unsigned int k, uint32_t id);
    virtual bool getIsSuccess() const;
    virtual void setIsSuccess(bool isSuccess);
};

inline void doPacking(cCommBuffer *b, P2pnsResolveResponse& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, P2pnsResolveResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>common/CommonMessages.msg</tt> by opp_msgc.
 * <pre>
 * class OverlayCtrlInfo
 * {
 *     TransportAddress lastHop;    
 *     NodeHandle srcNode;          
 *     NodeHandle srcRoute;         
 *     int hopCount = 0;            
 *     TransportAddress visitedHops[];     
 *     int srcComp enum(CompType);  
 *     int destComp enum(CompType); 
 *     int transportType enum(TransportType) = INVALID_TRANSPORT; 
 *     int routingType enum(RoutingType);
 * }
 * </pre>
 */
class OverlayCtrlInfo : public ::cObject
{
  protected:
    TransportAddress lastHop_var;
    NodeHandle srcNode_var;
    NodeHandle srcRoute_var;
    int hopCount_var;
    TransportAddress *visitedHops_var; // array ptr
    unsigned int visitedHops_arraysize;
    int srcComp_var;
    int destComp_var;
    int transportType_var;
    int routingType_var;

  private:
    void copy(const OverlayCtrlInfo& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const OverlayCtrlInfo&);

  public:
    OverlayCtrlInfo();
    OverlayCtrlInfo(const OverlayCtrlInfo& other);
    virtual ~OverlayCtrlInfo();
    OverlayCtrlInfo& operator=(const OverlayCtrlInfo& other);
    virtual OverlayCtrlInfo *dup() const {return new OverlayCtrlInfo(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual TransportAddress& getLastHop();
    virtual const TransportAddress& getLastHop() const {return const_cast<OverlayCtrlInfo*>(this)->getLastHop();}
    virtual void setLastHop(const TransportAddress& lastHop);
    virtual NodeHandle& getSrcNode();
    virtual const NodeHandle& getSrcNode() const {return const_cast<OverlayCtrlInfo*>(this)->getSrcNode();}
    virtual void setSrcNode(const NodeHandle& srcNode);
    virtual NodeHandle& getSrcRoute();
    virtual const NodeHandle& getSrcRoute() const {return const_cast<OverlayCtrlInfo*>(this)->getSrcRoute();}
    virtual void setSrcRoute(const NodeHandle& srcRoute);
    virtual int getHopCount() const;
    virtual void setHopCount(int hopCount);
    virtual void setVisitedHopsArraySize(unsigned int size);
    virtual unsigned int getVisitedHopsArraySize() const;
    virtual TransportAddress& getVisitedHops(unsigned int k);
    virtual const TransportAddress& getVisitedHops(unsigned int k) const {return const_cast<OverlayCtrlInfo*>(this)->getVisitedHops(k);}
    virtual void setVisitedHops(unsigned int k, const TransportAddress& visitedHops);
    virtual int getSrcComp() const;
    virtual void setSrcComp(int srcComp);
    virtual int getDestComp() const;
    virtual void setDestComp(int destComp);
    virtual int getTransportType() const;
    virtual void setTransportType(int transportType);
    virtual int getRoutingType() const;
    virtual void setRoutingType(int routingType);
};

inline void doPacking(cCommBuffer *b, OverlayCtrlInfo& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, OverlayCtrlInfo& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>common/CommonMessages.msg</tt> by opp_msgc.
 * <pre>
 * class BinaryValueArray
 * {
 *     BinaryValue values[] @sizetype(uint16_t);
 * }
 * </pre>
 */
class BinaryValueArray : public ::cObject
{
  protected:
    BinaryValue *values_var; // array ptr
    uint16_t values_arraysize;

  private:
    void copy(const BinaryValueArray& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const BinaryValueArray&);

  public:
    BinaryValueArray();
    BinaryValueArray(const BinaryValueArray& other);
    virtual ~BinaryValueArray();
    BinaryValueArray& operator=(const BinaryValueArray& other);
    virtual BinaryValueArray *dup() const {return new BinaryValueArray(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual void setValuesArraySize(uint16_t size);
    virtual uint16_t getValuesArraySize() const;
    virtual BinaryValue& getValues(uint16_t k);
    virtual const BinaryValue& getValues(uint16_t k) const {return const_cast<BinaryValueArray*>(this)->getValues(k);}
    virtual void setValues(uint16_t k, const BinaryValue& values);
};

inline void doPacking(cCommBuffer *b, BinaryValueArray& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, BinaryValueArray& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>common/CommonMessages.msg</tt> by opp_msgc.
 * <pre>
 * packet ALMMessage
 * {
 *     OverlayKey groupId;
 * }
 * </pre>
 */
class ALMMessage : public ::cPacket
{
  protected:
    OverlayKey groupId_var;

  private:
    void copy(const ALMMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ALMMessage&);

  public:
    ALMMessage(const char *name=NULL, int kind=0);
    ALMMessage(const ALMMessage& other);
    virtual ~ALMMessage();
    ALMMessage& operator=(const ALMMessage& other);
    virtual ALMMessage *dup() const {return new ALMMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual OverlayKey& getGroupId();
    virtual const OverlayKey& getGroupId() const {return const_cast<ALMMessage*>(this)->getGroupId();}
    virtual void setGroupId(const OverlayKey& groupId);
};

inline void doPacking(cCommBuffer *b, ALMMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, ALMMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>common/CommonMessages.msg</tt> by opp_msgc.
 * <pre>
 * packet ALMCreateMessage extends ALMMessage
 * {
 * }
 * </pre>
 */
class ALMCreateMessage : public ::ALMMessage
{
  protected:

  private:
    void copy(const ALMCreateMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ALMCreateMessage&);

  public:
    ALMCreateMessage(const char *name=NULL, int kind=0);
    ALMCreateMessage(const ALMCreateMessage& other);
    virtual ~ALMCreateMessage();
    ALMCreateMessage& operator=(const ALMCreateMessage& other);
    virtual ALMCreateMessage *dup() const {return new ALMCreateMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, ALMCreateMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, ALMCreateMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>common/CommonMessages.msg</tt> by opp_msgc.
 * <pre>
 * packet ALMDeleteMessage extends ALMMessage
 * {
 * }
 * </pre>
 */
class ALMDeleteMessage : public ::ALMMessage
{
  protected:

  private:
    void copy(const ALMDeleteMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ALMDeleteMessage&);

  public:
    ALMDeleteMessage(const char *name=NULL, int kind=0);
    ALMDeleteMessage(const ALMDeleteMessage& other);
    virtual ~ALMDeleteMessage();
    ALMDeleteMessage& operator=(const ALMDeleteMessage& other);
    virtual ALMDeleteMessage *dup() const {return new ALMDeleteMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, ALMDeleteMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, ALMDeleteMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>common/CommonMessages.msg</tt> by opp_msgc.
 * <pre>
 * packet ALMSubscribeMessage extends ALMMessage
 * {
 * }
 * </pre>
 */
class ALMSubscribeMessage : public ::ALMMessage
{
  protected:

  private:
    void copy(const ALMSubscribeMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ALMSubscribeMessage&);

  public:
    ALMSubscribeMessage(const char *name=NULL, int kind=0);
    ALMSubscribeMessage(const ALMSubscribeMessage& other);
    virtual ~ALMSubscribeMessage();
    ALMSubscribeMessage& operator=(const ALMSubscribeMessage& other);
    virtual ALMSubscribeMessage *dup() const {return new ALMSubscribeMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, ALMSubscribeMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, ALMSubscribeMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>common/CommonMessages.msg</tt> by opp_msgc.
 * <pre>
 * packet ALMLeaveMessage extends ALMMessage
 * {
 * }
 * </pre>
 */
class ALMLeaveMessage : public ::ALMMessage
{
  protected:

  private:
    void copy(const ALMLeaveMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ALMLeaveMessage&);

  public:
    ALMLeaveMessage(const char *name=NULL, int kind=0);
    ALMLeaveMessage(const ALMLeaveMessage& other);
    virtual ~ALMLeaveMessage();
    ALMLeaveMessage& operator=(const ALMLeaveMessage& other);
    virtual ALMLeaveMessage *dup() const {return new ALMLeaveMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, ALMLeaveMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, ALMLeaveMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>common/CommonMessages.msg</tt> by opp_msgc.
 * <pre>
 * packet ALMMulticastMessage extends ALMMessage
 * {
 * }
 * </pre>
 */
class ALMMulticastMessage : public ::ALMMessage
{
  protected:

  private:
    void copy(const ALMMulticastMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ALMMulticastMessage&);

  public:
    ALMMulticastMessage(const char *name=NULL, int kind=0);
    ALMMulticastMessage(const ALMMulticastMessage& other);
    virtual ~ALMMulticastMessage();
    ALMMulticastMessage& operator=(const ALMMulticastMessage& other);
    virtual ALMMulticastMessage *dup() const {return new ALMMulticastMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, ALMMulticastMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, ALMMulticastMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>common/CommonMessages.msg</tt> by opp_msgc.
 * <pre>
 * packet ALMAnycastMessage extends ALMMessage
 * {
 * }
 * </pre>
 */
class ALMAnycastMessage : public ::ALMMessage
{
  protected:

  private:
    void copy(const ALMAnycastMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ALMAnycastMessage&);

  public:
    ALMAnycastMessage(const char *name=NULL, int kind=0);
    ALMAnycastMessage(const ALMAnycastMessage& other);
    virtual ~ALMAnycastMessage();
    ALMAnycastMessage& operator=(const ALMAnycastMessage& other);
    virtual ALMAnycastMessage *dup() const {return new ALMAnycastMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, ALMAnycastMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, ALMAnycastMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>common/CommonMessages.msg</tt> by opp_msgc.
 * <pre>
 * packet GameAPIMessage extends BaseOverlayMessage 
 * {
 *     int command enum(GameAPIMessageCommand);
 * }
 * </pre>
 */
class GameAPIMessage : public ::BaseOverlayMessage
{
  protected:
    int command_var;

  private:
    void copy(const GameAPIMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const GameAPIMessage&);

  public:
    GameAPIMessage(const char *name=NULL, int kind=0);
    GameAPIMessage(const GameAPIMessage& other);
    virtual ~GameAPIMessage();
    GameAPIMessage& operator=(const GameAPIMessage& other);
    virtual GameAPIMessage *dup() const {return new GameAPIMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getCommand() const;
    virtual void setCommand(int command);
};

inline void doPacking(cCommBuffer *b, GameAPIMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, GameAPIMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>common/CommonMessages.msg</tt> by opp_msgc.
 * <pre>
 * packet GameAPIListMessage extends GameAPIMessage 
 * {
 *     NodeHandle removeNeighbor[];
 *     NodeHandle addNeighbor[];
 *     Vector2D neighborPosition[];
 * }
 * </pre>
 */
class GameAPIListMessage : public ::GameAPIMessage
{
  protected:
    NodeHandle *removeNeighbor_var; // array ptr
    unsigned int removeNeighbor_arraysize;
    NodeHandle *addNeighbor_var; // array ptr
    unsigned int addNeighbor_arraysize;
    Vector2D *neighborPosition_var; // array ptr
    unsigned int neighborPosition_arraysize;

  private:
    void copy(const GameAPIListMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const GameAPIListMessage&);

  public:
    GameAPIListMessage(const char *name=NULL, int kind=0);
    GameAPIListMessage(const GameAPIListMessage& other);
    virtual ~GameAPIListMessage();
    GameAPIListMessage& operator=(const GameAPIListMessage& other);
    virtual GameAPIListMessage *dup() const {return new GameAPIListMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual void setRemoveNeighborArraySize(unsigned int size);
    virtual unsigned int getRemoveNeighborArraySize() const;
    virtual NodeHandle& getRemoveNeighbor(unsigned int k);
    virtual const NodeHandle& getRemoveNeighbor(unsigned int k) const {return const_cast<GameAPIListMessage*>(this)->getRemoveNeighbor(k);}
    virtual void setRemoveNeighbor(unsigned int k, const NodeHandle& removeNeighbor);
    virtual void setAddNeighborArraySize(unsigned int size);
    virtual unsigned int getAddNeighborArraySize() const;
    virtual NodeHandle& getAddNeighbor(unsigned int k);
    virtual const NodeHandle& getAddNeighbor(unsigned int k) const {return const_cast<GameAPIListMessage*>(this)->getAddNeighbor(k);}
    virtual void setAddNeighbor(unsigned int k, const NodeHandle& addNeighbor);
    virtual void setNeighborPositionArraySize(unsigned int size);
    virtual unsigned int getNeighborPositionArraySize() const;
    virtual Vector2D& getNeighborPosition(unsigned int k);
    virtual const Vector2D& getNeighborPosition(unsigned int k) const {return const_cast<GameAPIListMessage*>(this)->getNeighborPosition(k);}
    virtual void setNeighborPosition(unsigned int k, const Vector2D& neighborPosition);
};

inline void doPacking(cCommBuffer *b, GameAPIListMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, GameAPIListMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>common/CommonMessages.msg</tt> by opp_msgc.
 * <pre>
 * packet GameAPIPositionMessage extends GameAPIMessage 
 * {
 *     Vector2D position;
 * }
 * </pre>
 */
class GameAPIPositionMessage : public ::GameAPIMessage
{
  protected:
    Vector2D position_var;

  private:
    void copy(const GameAPIPositionMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const GameAPIPositionMessage&);

  public:
    GameAPIPositionMessage(const char *name=NULL, int kind=0);
    GameAPIPositionMessage(const GameAPIPositionMessage& other);
    virtual ~GameAPIPositionMessage();
    GameAPIPositionMessage& operator=(const GameAPIPositionMessage& other);
    virtual GameAPIPositionMessage *dup() const {return new GameAPIPositionMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual Vector2D& getPosition();
    virtual const Vector2D& getPosition() const {return const_cast<GameAPIPositionMessage*>(this)->getPosition();}
    virtual void setPosition(const Vector2D& position);
};

inline void doPacking(cCommBuffer *b, GameAPIPositionMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, GameAPIPositionMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>common/CommonMessages.msg</tt> by opp_msgc.
 * <pre>
 * packet GameAPIResizeAOIMessage extends GameAPIMessage
 * {
 *     double AOIsize;
 * }
 * </pre>
 */
class GameAPIResizeAOIMessage : public ::GameAPIMessage
{
  protected:
    double AOIsize_var;

  private:
    void copy(const GameAPIResizeAOIMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const GameAPIResizeAOIMessage&);

  public:
    GameAPIResizeAOIMessage(const char *name=NULL, int kind=0);
    GameAPIResizeAOIMessage(const GameAPIResizeAOIMessage& other);
    virtual ~GameAPIResizeAOIMessage();
    GameAPIResizeAOIMessage& operator=(const GameAPIResizeAOIMessage& other);
    virtual GameAPIResizeAOIMessage *dup() const {return new GameAPIResizeAOIMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual double getAOIsize() const;
    virtual void setAOIsize(double AOIsize);
};

inline void doPacking(cCommBuffer *b, GameAPIResizeAOIMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, GameAPIResizeAOIMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>common/CommonMessages.msg</tt> by opp_msgc.
 * <pre>
 * packet GameAPIChatMessage extends GameAPIMessage
 * {
 *     NodeHandle src;
 *     string msg;
 * }
 * </pre>
 */
class GameAPIChatMessage : public ::GameAPIMessage
{
  protected:
    NodeHandle src_var;
    opp_string msg_var;

  private:
    void copy(const GameAPIChatMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const GameAPIChatMessage&);

  public:
    GameAPIChatMessage(const char *name=NULL, int kind=0);
    GameAPIChatMessage(const GameAPIChatMessage& other);
    virtual ~GameAPIChatMessage();
    GameAPIChatMessage& operator=(const GameAPIChatMessage& other);
    virtual GameAPIChatMessage *dup() const {return new GameAPIChatMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual NodeHandle& getSrc();
    virtual const NodeHandle& getSrc() const {return const_cast<GameAPIChatMessage*>(this)->getSrc();}
    virtual void setSrc(const NodeHandle& src);
    virtual const char * getMsg() const;
    virtual void setMsg(const char * msg);
};

inline void doPacking(cCommBuffer *b, GameAPIChatMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, GameAPIChatMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>common/CommonMessages.msg</tt> by opp_msgc.
 * <pre>
 * packet GameAPISnowMessage extends GameAPIMessage
 * {
 *     NodeHandle src;
 *     Vector2D start;
 *     Vector2D end;
 *     int timeSec;
 *     int timeUsec;
 * }
 * </pre>
 */
class GameAPISnowMessage : public ::GameAPIMessage
{
  protected:
    NodeHandle src_var;
    Vector2D start_var;
    Vector2D end_var;
    int timeSec_var;
    int timeUsec_var;

  private:
    void copy(const GameAPISnowMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const GameAPISnowMessage&);

  public:
    GameAPISnowMessage(const char *name=NULL, int kind=0);
    GameAPISnowMessage(const GameAPISnowMessage& other);
    virtual ~GameAPISnowMessage();
    GameAPISnowMessage& operator=(const GameAPISnowMessage& other);
    virtual GameAPISnowMessage *dup() const {return new GameAPISnowMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual NodeHandle& getSrc();
    virtual const NodeHandle& getSrc() const {return const_cast<GameAPISnowMessage*>(this)->getSrc();}
    virtual void setSrc(const NodeHandle& src);
    virtual Vector2D& getStart();
    virtual const Vector2D& getStart() const {return const_cast<GameAPISnowMessage*>(this)->getStart();}
    virtual void setStart(const Vector2D& start);
    virtual Vector2D& getEnd();
    virtual const Vector2D& getEnd() const {return const_cast<GameAPISnowMessage*>(this)->getEnd();}
    virtual void setEnd(const Vector2D& end);
    virtual int getTimeSec() const;
    virtual void setTimeSec(int timeSec);
    virtual int getTimeUsec() const;
    virtual void setTimeUsec(int timeUsec);
};

inline void doPacking(cCommBuffer *b, GameAPISnowMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, GameAPISnowMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>common/CommonMessages.msg</tt> by opp_msgc.
 * <pre>
 * packet GameAPIFrozenMessage extends GameAPIMessage
 * {
 *     NodeHandle src;
 *     int thrower;	
 *     int timeSec;
 *     int timeUsec;
 * }
 * </pre>
 */
class GameAPIFrozenMessage : public ::GameAPIMessage
{
  protected:
    NodeHandle src_var;
    int thrower_var;
    int timeSec_var;
    int timeUsec_var;

  private:
    void copy(const GameAPIFrozenMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const GameAPIFrozenMessage&);

  public:
    GameAPIFrozenMessage(const char *name=NULL, int kind=0);
    GameAPIFrozenMessage(const GameAPIFrozenMessage& other);
    virtual ~GameAPIFrozenMessage();
    GameAPIFrozenMessage& operator=(const GameAPIFrozenMessage& other);
    virtual GameAPIFrozenMessage *dup() const {return new GameAPIFrozenMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual NodeHandle& getSrc();
    virtual const NodeHandle& getSrc() const {return const_cast<GameAPIFrozenMessage*>(this)->getSrc();}
    virtual void setSrc(const NodeHandle& src);
    virtual int getThrower() const;
    virtual void setThrower(int thrower);
    virtual int getTimeSec() const;
    virtual void setTimeSec(int timeSec);
    virtual int getTimeUsec() const;
    virtual void setTimeUsec(int timeUsec);
};

inline void doPacking(cCommBuffer *b, GameAPIFrozenMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, GameAPIFrozenMessage& obj) {obj.parsimUnpack(b);}


#endif // _COMMONMESSAGES_M_H_
