//
// Generated file, do not edit! Created by opp_msgc 4.3 from tier2/p2pns/P2pnsMessage.msg.
//

#ifndef _P2PNSMESSAGE_M_H_
#define _P2PNSMESSAGE_M_H_

#include <omnetpp.h>

// opp_msgc version check
#define MSGC_VERSION 0x0403
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of opp_msgc: 'make clean' should help.
#endif

// cplusplus {{
#include <IPvXAddress.h>
#include <NodeHandle.h>
#include <TransportAddress.h>
#include <CommonMessages_m.h>
#include <BinaryValue.h>

#define P2PNSTUNNELMESSAGE_L(msg) (KEY_L + \
                                   msg->getPayload().size() * sizeof(char))
// }}



/**
 * Class generated from <tt>tier2/p2pns/P2pnsMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet P2pnsTunnelMessage extends OverSimMessage
 * {
 *     OverlayKey srcId;   
 *     BinaryValue payload; 
 * }
 * </pre>
 */
class P2pnsTunnelMessage : public ::OverSimMessage
{
  protected:
    OverlayKey srcId_var;
    BinaryValue payload_var;

  private:
    void copy(const P2pnsTunnelMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const P2pnsTunnelMessage&);

  public:
    P2pnsTunnelMessage(const char *name=NULL, int kind=0);
    P2pnsTunnelMessage(const P2pnsTunnelMessage& other);
    virtual ~P2pnsTunnelMessage();
    P2pnsTunnelMessage& operator=(const P2pnsTunnelMessage& other);
    virtual P2pnsTunnelMessage *dup() const {return new P2pnsTunnelMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual OverlayKey& getSrcId();
    virtual const OverlayKey& getSrcId() const {return const_cast<P2pnsTunnelMessage*>(this)->getSrcId();}
    virtual void setSrcId(const OverlayKey& srcId);
    virtual BinaryValue& getPayload();
    virtual const BinaryValue& getPayload() const {return const_cast<P2pnsTunnelMessage*>(this)->getPayload();}
    virtual void setPayload(const BinaryValue& payload);
};

inline void doPacking(cCommBuffer *b, P2pnsTunnelMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, P2pnsTunnelMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>tier2/p2pns/P2pnsMessage.msg</tt> by opp_msgc.
 * <pre>
 * message P2pnsKeepaliveTimer
 * {
 *     OverlayKey key;      
 * }
 * </pre>
 */
class P2pnsKeepaliveTimer : public ::cMessage
{
  protected:
    OverlayKey key_var;

  private:
    void copy(const P2pnsKeepaliveTimer& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const P2pnsKeepaliveTimer&);

  public:
    P2pnsKeepaliveTimer(const char *name=NULL, int kind=0);
    P2pnsKeepaliveTimer(const P2pnsKeepaliveTimer& other);
    virtual ~P2pnsKeepaliveTimer();
    P2pnsKeepaliveTimer& operator=(const P2pnsKeepaliveTimer& other);
    virtual P2pnsKeepaliveTimer *dup() const {return new P2pnsKeepaliveTimer(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual OverlayKey& getKey();
    virtual const OverlayKey& getKey() const {return const_cast<P2pnsKeepaliveTimer*>(this)->getKey();}
    virtual void setKey(const OverlayKey& key);
};

inline void doPacking(cCommBuffer *b, P2pnsKeepaliveTimer& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, P2pnsKeepaliveTimer& obj) {obj.parsimUnpack(b);}


#endif // _P2PNSMESSAGE_M_H_
