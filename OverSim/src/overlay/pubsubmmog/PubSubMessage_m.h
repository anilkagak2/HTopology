//
// Generated file, do not edit! Created by opp_msgc 4.3 from overlay/pubsubmmog/PubSubMessage.msg.
//

#ifndef _PUBSUBMESSAGE_M_H_
#define _PUBSUBMESSAGE_M_H_

#include <omnetpp.h>

// opp_msgc version check
#define MSGC_VERSION 0x0403
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of opp_msgc: 'make clean' should help.
#endif

// cplusplus {{
#include <CommonMessages_m.h>
#include <Vector2D.h>

static const int PUBSUB_FLAG_L = 8;
static const int PUBSUB_VECTOR_L = 128;
static const int PUBSUB_RESS_L = 32;
static const int PUBSUB_SUBSPACE_L = 32;
static const int PUBSUB_CHILDPOS_L = 16;
static const int PUBSUB_TIMESTAMP_L = 32;

#define PUBSUB_JOINCALL_L(msg) (BASECALL_L(msg) + PUBSUB_VECTOR_L + PUBSUB_RESS_L)
#define PUBSUB_JOINRESPONSE_L(msg) (BASECALL_L(msg) + NODEHANDLE_L)
#define PUBSUB_RESPONSIBLENODECALL_L(msg) (BASECALL_L(msg) + PUBSUB_VECTOR_L)
#define PUBSUB_RESPONSIBLENODERESPONSE_L(msg) (BASECALL_L(msg) + NODEHANDLE_L)
#define PUBSUB_TAKEOVERSUBSPACECALL_L(msg) (BASECALL_L(msg) + PUBSUB_VECTOR_L)
#define PUBSUB_TAKEOVERSUBSPACERESPONSE_L(msg) (BASECALL_L(msg))
#define PUBSUB_SUBSCRIPTIONCALL_L(msg) (BASECALL_L(msg) + PUBSUB_SUBSPACE_L)
#define PUBSUB_SUBSCRIPTIONRESPONSE_L(msg) (BASECALL_L(msg) + PUBSUB_FLAG_L)
#define PUBSUB_UNSUBSCRIPTION_L(msg) (NODEHANDLE_L + PUBSUB_SUBSPACE_L)
#define PUBSUB_HELPCALL_L(msg) (BASECALL_L(msg) + PUBSUB_SUBSPACE_L + PUBSUB_FLAG_L)
#define PUBSUB_HELPRESPONSE_L(msg) (BASECALL_L(msg) + NODEHANDLE_L)
#define PUBSUB_INTERMEDIATECALL_L(msg) (BASECALL_L(msg) + PUBSUB_SUBSPACE_L)
#define PUBSUB_INTERMEDIATERESPONSE_L(msg) (BASECALL_L(msg))
#define PUBSUB_BACKUPCALL_L(msg) (BASECALL_L(msg) + msg->getIntermediatesArraySize()*NODEHANDLE_L + msg->getChildrenArraySize()*(NODEHANDLE_L+PUBSUB_CHILDPOS_L))
#define PUBSUB_BACKUPRESPONSE_L(msg) (BASECALL_L(msg))
#define PUBSUB_PINGCALL_L(msg) (BASECALL_L(msg) + PUBSUB_SUBSPACE_L + PUBSUB_FLAG_L)
#define PUBSUB_PINGRESPONSE_L(msg) (BASECALL_L(msg))
#define PUBSUB_REPLACEMENT_L(msg) (PUBSUB_SUBSPACE_L + NODEHANDLE_L)
#define PUBSUB_FAILEDNODE_L(msg) (IPADDR_L + UDPPORT_L)
#define PUBSUB_NODELEFT_L(msg) (PUBSUB_SUBSPACE_L + NODEHANDLE_L)
#define PUBSUB_ADOPTCHILDCALL_L(msg) (BASECALL_L(msg) + PUBSUB_SUBSPACE_L + NODEHANDLE_L)
#define PUBSUB_ADOPTCHILDRESPONSE_L(msg) (BASECALL_L(msg))
#define PUBSUB_RELEASEINTERMEDIATE_L(msg) (PUBSUB_SUBSPACE_L)
#define PUBSUB_HELPRELEASE_L(msg) (PUBSUB_SUBSPACE_L + NODEHANDLE_L)
#define PUBSUB_BACKUPSUBSCRIPTION_L(msg) (PUBSUB_SUBSPACE_L + NODEHANDLE_L*3)
#define PUBSUB_BACKUPINTERMEDIATE_L(msg) (PUBSUB_SUBSPACE_L + NODEHANDLE_L + PUBSUB_CHILDPOS_L)
#define PUBSUB_BACKUPUNSUBSCRIBE_L(msg) (PUBSUB_SUBSPACE_L + NODEHANDLE_L*2)
#define PUBSUB_MOVE_L(msg) (PUBSUB_SUBSPACE_L + NODEHANDLE_L + PUBSUB_VECTOR_L + PUBSUB_TIMESTAMP_L)
#define PUBSUB_MOVELIST_L(msg) (PUBSUB_SUBSPACE_L + PUBSUB_TIMESTAMP_L + msg->getPlayerArraySize()*(NODEHANDLE_L+PUBSUB_VECTOR_L))
// }}



/**
 * Enum generated from <tt>overlay/pubsubmmog/PubSubMessage.msg</tt> by opp_msgc.
 * <pre>
 * enum PubSubTimerType 
 * {
 * 
 *     PUBSUB_HEARTBEAT = 0;
 *     PUBSUB_CHILDPING = 1;
 *     PUBSUB_PARENT_TIMEOUT = 2;
 *     PUBSUB_TAKEOVER_GRACE_TIME = 3;
 *     PUBSUB_EVENTDELIVERY = 4;
 * }
 * </pre>
 */
enum PubSubTimerType {
    PUBSUB_HEARTBEAT = 0,
    PUBSUB_CHILDPING = 1,
    PUBSUB_PARENT_TIMEOUT = 2,
    PUBSUB_TAKEOVER_GRACE_TIME = 3,
    PUBSUB_EVENTDELIVERY = 4
};

/**
 * Enum generated from <tt>overlay/pubsubmmog/PubSubMessage.msg</tt> by opp_msgc.
 * <pre>
 * enum PubSubHelpType
 * {
 * 
 *     PUBSUB_BACKUP = 0;
 *     PUBSUB_INTERMEDIATE = 1;
 * }
 * </pre>
 */
enum PubSubHelpType {
    PUBSUB_BACKUP = 0,
    PUBSUB_INTERMEDIATE = 1
};

/**
 * Enum generated from <tt>overlay/pubsubmmog/PubSubMessage.msg</tt> by opp_msgc.
 * <pre>
 * enum PubSubPingType
 * {
 * 
 *     PUBSUB_PING_BACKUP = 0;
 *     PUBSUB_PING_INTERMEDIATE = 1;
 *     PUBSUB_PING_CHILD = 2;
 * }
 * </pre>
 */
enum PubSubPingType {
    PUBSUB_PING_BACKUP = 0,
    PUBSUB_PING_INTERMEDIATE = 1,
    PUBSUB_PING_CHILD = 2
};

/**
 * Class generated from <tt>overlay/pubsubmmog/PubSubMessage.msg</tt> by opp_msgc.
 * <pre>
 * message PubSubTimer
 * {
 *         int type enum(PubSubTimerType);
 *         int subspaceId;
 * }
 * </pre>
 */
class PubSubTimer : public ::cMessage
{
  protected:
    int type_var;
    int subspaceId_var;

  private:
    void copy(const PubSubTimer& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PubSubTimer&);

  public:
    PubSubTimer(const char *name=NULL, int kind=0);
    PubSubTimer(const PubSubTimer& other);
    virtual ~PubSubTimer();
    PubSubTimer& operator=(const PubSubTimer& other);
    virtual PubSubTimer *dup() const {return new PubSubTimer(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getType() const;
    virtual void setType(int type);
    virtual int getSubspaceId() const;
    virtual void setSubspaceId(int subspaceId);
};

inline void doPacking(cCommBuffer *b, PubSubTimer& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, PubSubTimer& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/pubsubmmog/PubSubMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet PubSubJoinCall extends BaseCallMessage
 * {
 *         Vector2D position;
 *         int ressources;
 * }
 * </pre>
 */
class PubSubJoinCall : public ::BaseCallMessage
{
  protected:
    Vector2D position_var;
    int ressources_var;

  private:
    void copy(const PubSubJoinCall& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PubSubJoinCall&);

  public:
    PubSubJoinCall(const char *name=NULL, int kind=0);
    PubSubJoinCall(const PubSubJoinCall& other);
    virtual ~PubSubJoinCall();
    PubSubJoinCall& operator=(const PubSubJoinCall& other);
    virtual PubSubJoinCall *dup() const {return new PubSubJoinCall(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual Vector2D& getPosition();
    virtual const Vector2D& getPosition() const {return const_cast<PubSubJoinCall*>(this)->getPosition();}
    virtual void setPosition(const Vector2D& position);
    virtual int getRessources() const;
    virtual void setRessources(int ressources);
};

inline void doPacking(cCommBuffer *b, PubSubJoinCall& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, PubSubJoinCall& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/pubsubmmog/PubSubMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet PubSubJoinResponse extends BaseResponseMessage
 * {
 *         NodeHandle responsibleNode;
 *         
 * }
 * </pre>
 */
class PubSubJoinResponse : public ::BaseResponseMessage
{
  protected:
    NodeHandle responsibleNode_var;

  private:
    void copy(const PubSubJoinResponse& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PubSubJoinResponse&);

  public:
    PubSubJoinResponse(const char *name=NULL, int kind=0);
    PubSubJoinResponse(const PubSubJoinResponse& other);
    virtual ~PubSubJoinResponse();
    PubSubJoinResponse& operator=(const PubSubJoinResponse& other);
    virtual PubSubJoinResponse *dup() const {return new PubSubJoinResponse(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual NodeHandle& getResponsibleNode();
    virtual const NodeHandle& getResponsibleNode() const {return const_cast<PubSubJoinResponse*>(this)->getResponsibleNode();}
    virtual void setResponsibleNode(const NodeHandle& responsibleNode);
};

inline void doPacking(cCommBuffer *b, PubSubJoinResponse& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, PubSubJoinResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/pubsubmmog/PubSubMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet PubSubResponsibleNodeCall extends BaseCallMessage
 * {
 *         Vector2D subspacePos; 
 * }
 * </pre>
 */
class PubSubResponsibleNodeCall : public ::BaseCallMessage
{
  protected:
    Vector2D subspacePos_var;

  private:
    void copy(const PubSubResponsibleNodeCall& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PubSubResponsibleNodeCall&);

  public:
    PubSubResponsibleNodeCall(const char *name=NULL, int kind=0);
    PubSubResponsibleNodeCall(const PubSubResponsibleNodeCall& other);
    virtual ~PubSubResponsibleNodeCall();
    PubSubResponsibleNodeCall& operator=(const PubSubResponsibleNodeCall& other);
    virtual PubSubResponsibleNodeCall *dup() const {return new PubSubResponsibleNodeCall(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual Vector2D& getSubspacePos();
    virtual const Vector2D& getSubspacePos() const {return const_cast<PubSubResponsibleNodeCall*>(this)->getSubspacePos();}
    virtual void setSubspacePos(const Vector2D& subspacePos);
};

inline void doPacking(cCommBuffer *b, PubSubResponsibleNodeCall& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, PubSubResponsibleNodeCall& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/pubsubmmog/PubSubMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet PubSubResponsibleNodeResponse extends BaseResponseMessage
 * {
 *         int subspaceId; 
 *         NodeHandle responsibleNode;
 * }
 * </pre>
 */
class PubSubResponsibleNodeResponse : public ::BaseResponseMessage
{
  protected:
    int subspaceId_var;
    NodeHandle responsibleNode_var;

  private:
    void copy(const PubSubResponsibleNodeResponse& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PubSubResponsibleNodeResponse&);

  public:
    PubSubResponsibleNodeResponse(const char *name=NULL, int kind=0);
    PubSubResponsibleNodeResponse(const PubSubResponsibleNodeResponse& other);
    virtual ~PubSubResponsibleNodeResponse();
    PubSubResponsibleNodeResponse& operator=(const PubSubResponsibleNodeResponse& other);
    virtual PubSubResponsibleNodeResponse *dup() const {return new PubSubResponsibleNodeResponse(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getSubspaceId() const;
    virtual void setSubspaceId(int subspaceId);
    virtual NodeHandle& getResponsibleNode();
    virtual const NodeHandle& getResponsibleNode() const {return const_cast<PubSubResponsibleNodeResponse*>(this)->getResponsibleNode();}
    virtual void setResponsibleNode(const NodeHandle& responsibleNode);
};

inline void doPacking(cCommBuffer *b, PubSubResponsibleNodeResponse& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, PubSubResponsibleNodeResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/pubsubmmog/PubSubMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet PubSubTakeOverSubspaceCall extends BaseCallMessage
 * {
 *         Vector2D subspacePos; 
 * }
 * </pre>
 */
class PubSubTakeOverSubspaceCall : public ::BaseCallMessage
{
  protected:
    Vector2D subspacePos_var;

  private:
    void copy(const PubSubTakeOverSubspaceCall& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PubSubTakeOverSubspaceCall&);

  public:
    PubSubTakeOverSubspaceCall(const char *name=NULL, int kind=0);
    PubSubTakeOverSubspaceCall(const PubSubTakeOverSubspaceCall& other);
    virtual ~PubSubTakeOverSubspaceCall();
    PubSubTakeOverSubspaceCall& operator=(const PubSubTakeOverSubspaceCall& other);
    virtual PubSubTakeOverSubspaceCall *dup() const {return new PubSubTakeOverSubspaceCall(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual Vector2D& getSubspacePos();
    virtual const Vector2D& getSubspacePos() const {return const_cast<PubSubTakeOverSubspaceCall*>(this)->getSubspacePos();}
    virtual void setSubspacePos(const Vector2D& subspacePos);
};

inline void doPacking(cCommBuffer *b, PubSubTakeOverSubspaceCall& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, PubSubTakeOverSubspaceCall& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/pubsubmmog/PubSubMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet PubSubTakeOverSubspaceResponse extends BaseResponseMessage
 * {
 *         Vector2D subspacePos; 
 * }
 * </pre>
 */
class PubSubTakeOverSubspaceResponse : public ::BaseResponseMessage
{
  protected:
    Vector2D subspacePos_var;

  private:
    void copy(const PubSubTakeOverSubspaceResponse& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PubSubTakeOverSubspaceResponse&);

  public:
    PubSubTakeOverSubspaceResponse(const char *name=NULL, int kind=0);
    PubSubTakeOverSubspaceResponse(const PubSubTakeOverSubspaceResponse& other);
    virtual ~PubSubTakeOverSubspaceResponse();
    PubSubTakeOverSubspaceResponse& operator=(const PubSubTakeOverSubspaceResponse& other);
    virtual PubSubTakeOverSubspaceResponse *dup() const {return new PubSubTakeOverSubspaceResponse(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual Vector2D& getSubspacePos();
    virtual const Vector2D& getSubspacePos() const {return const_cast<PubSubTakeOverSubspaceResponse*>(this)->getSubspacePos();}
    virtual void setSubspacePos(const Vector2D& subspacePos);
};

inline void doPacking(cCommBuffer *b, PubSubTakeOverSubspaceResponse& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, PubSubTakeOverSubspaceResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/pubsubmmog/PubSubMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet PubSubSubscriptionCall extends BaseCallMessage
 * {
 *         int subspaceId;
 * }
 * </pre>
 */
class PubSubSubscriptionCall : public ::BaseCallMessage
{
  protected:
    int subspaceId_var;

  private:
    void copy(const PubSubSubscriptionCall& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PubSubSubscriptionCall&);

  public:
    PubSubSubscriptionCall(const char *name=NULL, int kind=0);
    PubSubSubscriptionCall(const PubSubSubscriptionCall& other);
    virtual ~PubSubSubscriptionCall();
    PubSubSubscriptionCall& operator=(const PubSubSubscriptionCall& other);
    virtual PubSubSubscriptionCall *dup() const {return new PubSubSubscriptionCall(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getSubspaceId() const;
    virtual void setSubspaceId(int subspaceId);
};

inline void doPacking(cCommBuffer *b, PubSubSubscriptionCall& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, PubSubSubscriptionCall& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/pubsubmmog/PubSubMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet PubSubSubscriptionResponse extends BaseResponseMessage
 * {
 *         bool failed = false;
 * }
 * </pre>
 */
class PubSubSubscriptionResponse : public ::BaseResponseMessage
{
  protected:
    bool failed_var;

  private:
    void copy(const PubSubSubscriptionResponse& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PubSubSubscriptionResponse&);

  public:
    PubSubSubscriptionResponse(const char *name=NULL, int kind=0);
    PubSubSubscriptionResponse(const PubSubSubscriptionResponse& other);
    virtual ~PubSubSubscriptionResponse();
    PubSubSubscriptionResponse& operator=(const PubSubSubscriptionResponse& other);
    virtual PubSubSubscriptionResponse *dup() const {return new PubSubSubscriptionResponse(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual bool getFailed() const;
    virtual void setFailed(bool failed);
};

inline void doPacking(cCommBuffer *b, PubSubSubscriptionResponse& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, PubSubSubscriptionResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/pubsubmmog/PubSubMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet PubSubUnsubscriptionMessage extends BaseOverlayMessage
 * {
 *         int subspaceId;
 *         NodeHandle src;
 * }
 * </pre>
 */
class PubSubUnsubscriptionMessage : public ::BaseOverlayMessage
{
  protected:
    int subspaceId_var;
    NodeHandle src_var;

  private:
    void copy(const PubSubUnsubscriptionMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PubSubUnsubscriptionMessage&);

  public:
    PubSubUnsubscriptionMessage(const char *name=NULL, int kind=0);
    PubSubUnsubscriptionMessage(const PubSubUnsubscriptionMessage& other);
    virtual ~PubSubUnsubscriptionMessage();
    PubSubUnsubscriptionMessage& operator=(const PubSubUnsubscriptionMessage& other);
    virtual PubSubUnsubscriptionMessage *dup() const {return new PubSubUnsubscriptionMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getSubspaceId() const;
    virtual void setSubspaceId(int subspaceId);
    virtual NodeHandle& getSrc();
    virtual const NodeHandle& getSrc() const {return const_cast<PubSubUnsubscriptionMessage*>(this)->getSrc();}
    virtual void setSrc(const NodeHandle& src);
};

inline void doPacking(cCommBuffer *b, PubSubUnsubscriptionMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, PubSubUnsubscriptionMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/pubsubmmog/PubSubMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet PubSubHelpCall extends BaseCallMessage
 * {
 *         int subspaceId; 
 *         int helpType enum(PubSubHelpType);
 * }
 * </pre>
 */
class PubSubHelpCall : public ::BaseCallMessage
{
  protected:
    int subspaceId_var;
    int helpType_var;

  private:
    void copy(const PubSubHelpCall& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PubSubHelpCall&);

  public:
    PubSubHelpCall(const char *name=NULL, int kind=0);
    PubSubHelpCall(const PubSubHelpCall& other);
    virtual ~PubSubHelpCall();
    PubSubHelpCall& operator=(const PubSubHelpCall& other);
    virtual PubSubHelpCall *dup() const {return new PubSubHelpCall(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getSubspaceId() const;
    virtual void setSubspaceId(int subspaceId);
    virtual int getHelpType() const;
    virtual void setHelpType(int helpType);
};

inline void doPacking(cCommBuffer *b, PubSubHelpCall& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, PubSubHelpCall& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/pubsubmmog/PubSubMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet PubSubHelpResponse extends BaseResponseMessage
 * {
 *         int subspaceId; 
 *         int helpType enum(PubSubHelpType); 
 *         NodeHandle node;
 * }
 * </pre>
 */
class PubSubHelpResponse : public ::BaseResponseMessage
{
  protected:
    int subspaceId_var;
    int helpType_var;
    NodeHandle node_var;

  private:
    void copy(const PubSubHelpResponse& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PubSubHelpResponse&);

  public:
    PubSubHelpResponse(const char *name=NULL, int kind=0);
    PubSubHelpResponse(const PubSubHelpResponse& other);
    virtual ~PubSubHelpResponse();
    PubSubHelpResponse& operator=(const PubSubHelpResponse& other);
    virtual PubSubHelpResponse *dup() const {return new PubSubHelpResponse(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getSubspaceId() const;
    virtual void setSubspaceId(int subspaceId);
    virtual int getHelpType() const;
    virtual void setHelpType(int helpType);
    virtual NodeHandle& getNode();
    virtual const NodeHandle& getNode() const {return const_cast<PubSubHelpResponse*>(this)->getNode();}
    virtual void setNode(const NodeHandle& node);
};

inline void doPacking(cCommBuffer *b, PubSubHelpResponse& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, PubSubHelpResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/pubsubmmog/PubSubMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet PubSubIntermediateCall extends BaseCallMessage
 * {
 *         int subspaceId;
 * }
 * </pre>
 */
class PubSubIntermediateCall : public ::BaseCallMessage
{
  protected:
    int subspaceId_var;

  private:
    void copy(const PubSubIntermediateCall& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PubSubIntermediateCall&);

  public:
    PubSubIntermediateCall(const char *name=NULL, int kind=0);
    PubSubIntermediateCall(const PubSubIntermediateCall& other);
    virtual ~PubSubIntermediateCall();
    PubSubIntermediateCall& operator=(const PubSubIntermediateCall& other);
    virtual PubSubIntermediateCall *dup() const {return new PubSubIntermediateCall(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getSubspaceId() const;
    virtual void setSubspaceId(int subspaceId);
};

inline void doPacking(cCommBuffer *b, PubSubIntermediateCall& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, PubSubIntermediateCall& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/pubsubmmog/PubSubMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet PubSubIntermediateResponse extends BaseResponseMessage
 * {
 *         int subspaceId; 
 * }
 * </pre>
 */
class PubSubIntermediateResponse : public ::BaseResponseMessage
{
  protected:
    int subspaceId_var;

  private:
    void copy(const PubSubIntermediateResponse& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PubSubIntermediateResponse&);

  public:
    PubSubIntermediateResponse(const char *name=NULL, int kind=0);
    PubSubIntermediateResponse(const PubSubIntermediateResponse& other);
    virtual ~PubSubIntermediateResponse();
    PubSubIntermediateResponse& operator=(const PubSubIntermediateResponse& other);
    virtual PubSubIntermediateResponse *dup() const {return new PubSubIntermediateResponse(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getSubspaceId() const;
    virtual void setSubspaceId(int subspaceId);
};

inline void doPacking(cCommBuffer *b, PubSubIntermediateResponse& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, PubSubIntermediateResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/pubsubmmog/PubSubMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet PubSubBackupCall extends BaseCallMessage
 * {
 *         int subspaceId;
 *         NodeHandle intermediates[];
 *         NodeHandle children[];
 *         int childrenPos[];
 * }
 * </pre>
 */
class PubSubBackupCall : public ::BaseCallMessage
{
  protected:
    int subspaceId_var;
    NodeHandle *intermediates_var; // array ptr
    unsigned int intermediates_arraysize;
    NodeHandle *children_var; // array ptr
    unsigned int children_arraysize;
    int *childrenPos_var; // array ptr
    unsigned int childrenPos_arraysize;

  private:
    void copy(const PubSubBackupCall& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PubSubBackupCall&);

  public:
    PubSubBackupCall(const char *name=NULL, int kind=0);
    PubSubBackupCall(const PubSubBackupCall& other);
    virtual ~PubSubBackupCall();
    PubSubBackupCall& operator=(const PubSubBackupCall& other);
    virtual PubSubBackupCall *dup() const {return new PubSubBackupCall(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getSubspaceId() const;
    virtual void setSubspaceId(int subspaceId);
    virtual void setIntermediatesArraySize(unsigned int size);
    virtual unsigned int getIntermediatesArraySize() const;
    virtual NodeHandle& getIntermediates(unsigned int k);
    virtual const NodeHandle& getIntermediates(unsigned int k) const {return const_cast<PubSubBackupCall*>(this)->getIntermediates(k);}
    virtual void setIntermediates(unsigned int k, const NodeHandle& intermediates);
    virtual void setChildrenArraySize(unsigned int size);
    virtual unsigned int getChildrenArraySize() const;
    virtual NodeHandle& getChildren(unsigned int k);
    virtual const NodeHandle& getChildren(unsigned int k) const {return const_cast<PubSubBackupCall*>(this)->getChildren(k);}
    virtual void setChildren(unsigned int k, const NodeHandle& children);
    virtual void setChildrenPosArraySize(unsigned int size);
    virtual unsigned int getChildrenPosArraySize() const;
    virtual int getChildrenPos(unsigned int k) const;
    virtual void setChildrenPos(unsigned int k, int childrenPos);
};

inline void doPacking(cCommBuffer *b, PubSubBackupCall& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, PubSubBackupCall& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/pubsubmmog/PubSubMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet PubSubBackupResponse extends BaseResponseMessage
 * {
 *         int subspaceId; 
 * }
 * </pre>
 */
class PubSubBackupResponse : public ::BaseResponseMessage
{
  protected:
    int subspaceId_var;

  private:
    void copy(const PubSubBackupResponse& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PubSubBackupResponse&);

  public:
    PubSubBackupResponse(const char *name=NULL, int kind=0);
    PubSubBackupResponse(const PubSubBackupResponse& other);
    virtual ~PubSubBackupResponse();
    PubSubBackupResponse& operator=(const PubSubBackupResponse& other);
    virtual PubSubBackupResponse *dup() const {return new PubSubBackupResponse(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getSubspaceId() const;
    virtual void setSubspaceId(int subspaceId);
};

inline void doPacking(cCommBuffer *b, PubSubBackupResponse& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, PubSubBackupResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/pubsubmmog/PubSubMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet PubSubPingCall extends BaseCallMessage
 * {
 *         int subspaceId;
 *         int pingType enum(PubSubPingType);
 * }
 * </pre>
 */
class PubSubPingCall : public ::BaseCallMessage
{
  protected:
    int subspaceId_var;
    int pingType_var;

  private:
    void copy(const PubSubPingCall& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PubSubPingCall&);

  public:
    PubSubPingCall(const char *name=NULL, int kind=0);
    PubSubPingCall(const PubSubPingCall& other);
    virtual ~PubSubPingCall();
    PubSubPingCall& operator=(const PubSubPingCall& other);
    virtual PubSubPingCall *dup() const {return new PubSubPingCall(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getSubspaceId() const;
    virtual void setSubspaceId(int subspaceId);
    virtual int getPingType() const;
    virtual void setPingType(int pingType);
};

inline void doPacking(cCommBuffer *b, PubSubPingCall& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, PubSubPingCall& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/pubsubmmog/PubSubMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet PubSubPingResponse extends BaseResponseMessage
 * {
 *         int subspaceId; 
 * }
 * </pre>
 */
class PubSubPingResponse : public ::BaseResponseMessage
{
  protected:
    int subspaceId_var;

  private:
    void copy(const PubSubPingResponse& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PubSubPingResponse&);

  public:
    PubSubPingResponse(const char *name=NULL, int kind=0);
    PubSubPingResponse(const PubSubPingResponse& other);
    virtual ~PubSubPingResponse();
    PubSubPingResponse& operator=(const PubSubPingResponse& other);
    virtual PubSubPingResponse *dup() const {return new PubSubPingResponse(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getSubspaceId() const;
    virtual void setSubspaceId(int subspaceId);
};

inline void doPacking(cCommBuffer *b, PubSubPingResponse& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, PubSubPingResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/pubsubmmog/PubSubMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet PubSubReplacementMessage extends BaseOverlayMessage
 * {
 *         int subspaceId;
 *         NodeHandle newResponsibleNode;
 * }
 * </pre>
 */
class PubSubReplacementMessage : public ::BaseOverlayMessage
{
  protected:
    int subspaceId_var;
    NodeHandle newResponsibleNode_var;

  private:
    void copy(const PubSubReplacementMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PubSubReplacementMessage&);

  public:
    PubSubReplacementMessage(const char *name=NULL, int kind=0);
    PubSubReplacementMessage(const PubSubReplacementMessage& other);
    virtual ~PubSubReplacementMessage();
    PubSubReplacementMessage& operator=(const PubSubReplacementMessage& other);
    virtual PubSubReplacementMessage *dup() const {return new PubSubReplacementMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getSubspaceId() const;
    virtual void setSubspaceId(int subspaceId);
    virtual NodeHandle& getNewResponsibleNode();
    virtual const NodeHandle& getNewResponsibleNode() const {return const_cast<PubSubReplacementMessage*>(this)->getNewResponsibleNode();}
    virtual void setNewResponsibleNode(const NodeHandle& newResponsibleNode);
};

inline void doPacking(cCommBuffer *b, PubSubReplacementMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, PubSubReplacementMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/pubsubmmog/PubSubMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet PubSubFailedNodeMessage extends BaseOverlayMessage
 * {
 *         TransportAddress failedNode;
 * }
 * </pre>
 */
class PubSubFailedNodeMessage : public ::BaseOverlayMessage
{
  protected:
    TransportAddress failedNode_var;

  private:
    void copy(const PubSubFailedNodeMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PubSubFailedNodeMessage&);

  public:
    PubSubFailedNodeMessage(const char *name=NULL, int kind=0);
    PubSubFailedNodeMessage(const PubSubFailedNodeMessage& other);
    virtual ~PubSubFailedNodeMessage();
    PubSubFailedNodeMessage& operator=(const PubSubFailedNodeMessage& other);
    virtual PubSubFailedNodeMessage *dup() const {return new PubSubFailedNodeMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual TransportAddress& getFailedNode();
    virtual const TransportAddress& getFailedNode() const {return const_cast<PubSubFailedNodeMessage*>(this)->getFailedNode();}
    virtual void setFailedNode(const TransportAddress& failedNode);
};

inline void doPacking(cCommBuffer *b, PubSubFailedNodeMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, PubSubFailedNodeMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/pubsubmmog/PubSubMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet PubSubNodeLeftMessage extends BaseOverlayMessage
 * {
 *         int subspaceId;
 *         NodeHandle node;
 * }
 * </pre>
 */
class PubSubNodeLeftMessage : public ::BaseOverlayMessage
{
  protected:
    int subspaceId_var;
    NodeHandle node_var;

  private:
    void copy(const PubSubNodeLeftMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PubSubNodeLeftMessage&);

  public:
    PubSubNodeLeftMessage(const char *name=NULL, int kind=0);
    PubSubNodeLeftMessage(const PubSubNodeLeftMessage& other);
    virtual ~PubSubNodeLeftMessage();
    PubSubNodeLeftMessage& operator=(const PubSubNodeLeftMessage& other);
    virtual PubSubNodeLeftMessage *dup() const {return new PubSubNodeLeftMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getSubspaceId() const;
    virtual void setSubspaceId(int subspaceId);
    virtual NodeHandle& getNode();
    virtual const NodeHandle& getNode() const {return const_cast<PubSubNodeLeftMessage*>(this)->getNode();}
    virtual void setNode(const NodeHandle& node);
};

inline void doPacking(cCommBuffer *b, PubSubNodeLeftMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, PubSubNodeLeftMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/pubsubmmog/PubSubMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet PubSubAdoptChildCall extends BaseCallMessage
 * {
 *         int subspaceId;
 *         NodeHandle child;
 * }
 * </pre>
 */
class PubSubAdoptChildCall : public ::BaseCallMessage
{
  protected:
    int subspaceId_var;
    NodeHandle child_var;

  private:
    void copy(const PubSubAdoptChildCall& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PubSubAdoptChildCall&);

  public:
    PubSubAdoptChildCall(const char *name=NULL, int kind=0);
    PubSubAdoptChildCall(const PubSubAdoptChildCall& other);
    virtual ~PubSubAdoptChildCall();
    PubSubAdoptChildCall& operator=(const PubSubAdoptChildCall& other);
    virtual PubSubAdoptChildCall *dup() const {return new PubSubAdoptChildCall(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getSubspaceId() const;
    virtual void setSubspaceId(int subspaceId);
    virtual NodeHandle& getChild();
    virtual const NodeHandle& getChild() const {return const_cast<PubSubAdoptChildCall*>(this)->getChild();}
    virtual void setChild(const NodeHandle& child);
};

inline void doPacking(cCommBuffer *b, PubSubAdoptChildCall& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, PubSubAdoptChildCall& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/pubsubmmog/PubSubMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet PubSubAdoptChildResponse extends BaseResponseMessage
 * {
 *         int subspaceId; 
 *         NodeHandle child; 
 * }
 * </pre>
 */
class PubSubAdoptChildResponse : public ::BaseResponseMessage
{
  protected:
    int subspaceId_var;
    NodeHandle child_var;

  private:
    void copy(const PubSubAdoptChildResponse& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PubSubAdoptChildResponse&);

  public:
    PubSubAdoptChildResponse(const char *name=NULL, int kind=0);
    PubSubAdoptChildResponse(const PubSubAdoptChildResponse& other);
    virtual ~PubSubAdoptChildResponse();
    PubSubAdoptChildResponse& operator=(const PubSubAdoptChildResponse& other);
    virtual PubSubAdoptChildResponse *dup() const {return new PubSubAdoptChildResponse(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getSubspaceId() const;
    virtual void setSubspaceId(int subspaceId);
    virtual NodeHandle& getChild();
    virtual const NodeHandle& getChild() const {return const_cast<PubSubAdoptChildResponse*>(this)->getChild();}
    virtual void setChild(const NodeHandle& child);
};

inline void doPacking(cCommBuffer *b, PubSubAdoptChildResponse& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, PubSubAdoptChildResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/pubsubmmog/PubSubMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet PubSubReleaseIntermediateMessage extends BaseOverlayMessage
 * {
 *         int subspaceId;
 * }
 * </pre>
 */
class PubSubReleaseIntermediateMessage : public ::BaseOverlayMessage
{
  protected:
    int subspaceId_var;

  private:
    void copy(const PubSubReleaseIntermediateMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PubSubReleaseIntermediateMessage&);

  public:
    PubSubReleaseIntermediateMessage(const char *name=NULL, int kind=0);
    PubSubReleaseIntermediateMessage(const PubSubReleaseIntermediateMessage& other);
    virtual ~PubSubReleaseIntermediateMessage();
    PubSubReleaseIntermediateMessage& operator=(const PubSubReleaseIntermediateMessage& other);
    virtual PubSubReleaseIntermediateMessage *dup() const {return new PubSubReleaseIntermediateMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getSubspaceId() const;
    virtual void setSubspaceId(int subspaceId);
};

inline void doPacking(cCommBuffer *b, PubSubReleaseIntermediateMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, PubSubReleaseIntermediateMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/pubsubmmog/PubSubMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet PubSubHelpReleaseMessage extends BaseOverlayMessage
 * {
 *         int subspaceId;
 *         NodeHandle node;
 * }
 * </pre>
 */
class PubSubHelpReleaseMessage : public ::BaseOverlayMessage
{
  protected:
    int subspaceId_var;
    NodeHandle node_var;

  private:
    void copy(const PubSubHelpReleaseMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PubSubHelpReleaseMessage&);

  public:
    PubSubHelpReleaseMessage(const char *name=NULL, int kind=0);
    PubSubHelpReleaseMessage(const PubSubHelpReleaseMessage& other);
    virtual ~PubSubHelpReleaseMessage();
    PubSubHelpReleaseMessage& operator=(const PubSubHelpReleaseMessage& other);
    virtual PubSubHelpReleaseMessage *dup() const {return new PubSubHelpReleaseMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getSubspaceId() const;
    virtual void setSubspaceId(int subspaceId);
    virtual NodeHandle& getNode();
    virtual const NodeHandle& getNode() const {return const_cast<PubSubHelpReleaseMessage*>(this)->getNode();}
    virtual void setNode(const NodeHandle& node);
};

inline void doPacking(cCommBuffer *b, PubSubHelpReleaseMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, PubSubHelpReleaseMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/pubsubmmog/PubSubMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet PubSubBackupSubscriptionMessage extends BaseOverlayMessage
 * {
 *         int subspaceId;
 *         NodeHandle child;
 *         NodeHandle parent;
 *         NodeHandle oldParent;
 * }
 * </pre>
 */
class PubSubBackupSubscriptionMessage : public ::BaseOverlayMessage
{
  protected:
    int subspaceId_var;
    NodeHandle child_var;
    NodeHandle parent_var;
    NodeHandle oldParent_var;

  private:
    void copy(const PubSubBackupSubscriptionMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PubSubBackupSubscriptionMessage&);

  public:
    PubSubBackupSubscriptionMessage(const char *name=NULL, int kind=0);
    PubSubBackupSubscriptionMessage(const PubSubBackupSubscriptionMessage& other);
    virtual ~PubSubBackupSubscriptionMessage();
    PubSubBackupSubscriptionMessage& operator=(const PubSubBackupSubscriptionMessage& other);
    virtual PubSubBackupSubscriptionMessage *dup() const {return new PubSubBackupSubscriptionMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getSubspaceId() const;
    virtual void setSubspaceId(int subspaceId);
    virtual NodeHandle& getChild();
    virtual const NodeHandle& getChild() const {return const_cast<PubSubBackupSubscriptionMessage*>(this)->getChild();}
    virtual void setChild(const NodeHandle& child);
    virtual NodeHandle& getParent();
    virtual const NodeHandle& getParent() const {return const_cast<PubSubBackupSubscriptionMessage*>(this)->getParent();}
    virtual void setParent(const NodeHandle& parent);
    virtual NodeHandle& getOldParent();
    virtual const NodeHandle& getOldParent() const {return const_cast<PubSubBackupSubscriptionMessage*>(this)->getOldParent();}
    virtual void setOldParent(const NodeHandle& oldParent);
};

inline void doPacking(cCommBuffer *b, PubSubBackupSubscriptionMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, PubSubBackupSubscriptionMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/pubsubmmog/PubSubMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet PubSubBackupIntermediateMessage extends BaseOverlayMessage
 * {
 *         int subspaceId;
 *         NodeHandle node;
 *         int pos;
 * }
 * </pre>
 */
class PubSubBackupIntermediateMessage : public ::BaseOverlayMessage
{
  protected:
    int subspaceId_var;
    NodeHandle node_var;
    int pos_var;

  private:
    void copy(const PubSubBackupIntermediateMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PubSubBackupIntermediateMessage&);

  public:
    PubSubBackupIntermediateMessage(const char *name=NULL, int kind=0);
    PubSubBackupIntermediateMessage(const PubSubBackupIntermediateMessage& other);
    virtual ~PubSubBackupIntermediateMessage();
    PubSubBackupIntermediateMessage& operator=(const PubSubBackupIntermediateMessage& other);
    virtual PubSubBackupIntermediateMessage *dup() const {return new PubSubBackupIntermediateMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getSubspaceId() const;
    virtual void setSubspaceId(int subspaceId);
    virtual NodeHandle& getNode();
    virtual const NodeHandle& getNode() const {return const_cast<PubSubBackupIntermediateMessage*>(this)->getNode();}
    virtual void setNode(const NodeHandle& node);
    virtual int getPos() const;
    virtual void setPos(int pos);
};

inline void doPacking(cCommBuffer *b, PubSubBackupIntermediateMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, PubSubBackupIntermediateMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/pubsubmmog/PubSubMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet PubSubBackupUnsubscribeMessage extends BaseOverlayMessage
 * {
 *         int subspaceId;
 *         NodeHandle child;
 *         NodeHandle intermediate;
 * }
 * </pre>
 */
class PubSubBackupUnsubscribeMessage : public ::BaseOverlayMessage
{
  protected:
    int subspaceId_var;
    NodeHandle child_var;
    NodeHandle intermediate_var;

  private:
    void copy(const PubSubBackupUnsubscribeMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PubSubBackupUnsubscribeMessage&);

  public:
    PubSubBackupUnsubscribeMessage(const char *name=NULL, int kind=0);
    PubSubBackupUnsubscribeMessage(const PubSubBackupUnsubscribeMessage& other);
    virtual ~PubSubBackupUnsubscribeMessage();
    PubSubBackupUnsubscribeMessage& operator=(const PubSubBackupUnsubscribeMessage& other);
    virtual PubSubBackupUnsubscribeMessage *dup() const {return new PubSubBackupUnsubscribeMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getSubspaceId() const;
    virtual void setSubspaceId(int subspaceId);
    virtual NodeHandle& getChild();
    virtual const NodeHandle& getChild() const {return const_cast<PubSubBackupUnsubscribeMessage*>(this)->getChild();}
    virtual void setChild(const NodeHandle& child);
    virtual NodeHandle& getIntermediate();
    virtual const NodeHandle& getIntermediate() const {return const_cast<PubSubBackupUnsubscribeMessage*>(this)->getIntermediate();}
    virtual void setIntermediate(const NodeHandle& intermediate);
};

inline void doPacking(cCommBuffer *b, PubSubBackupUnsubscribeMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, PubSubBackupUnsubscribeMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/pubsubmmog/PubSubMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet PubSubMoveMessage extends BaseOverlayMessage
 * {
 *         int subspaceId;
 *         simtime_t timestamp;
 *         NodeHandle player;
 *         Vector2D position;
 * }
 * </pre>
 */
class PubSubMoveMessage : public ::BaseOverlayMessage
{
  protected:
    int subspaceId_var;
    simtime_t timestamp_var;
    NodeHandle player_var;
    Vector2D position_var;

  private:
    void copy(const PubSubMoveMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PubSubMoveMessage&);

  public:
    PubSubMoveMessage(const char *name=NULL, int kind=0);
    PubSubMoveMessage(const PubSubMoveMessage& other);
    virtual ~PubSubMoveMessage();
    PubSubMoveMessage& operator=(const PubSubMoveMessage& other);
    virtual PubSubMoveMessage *dup() const {return new PubSubMoveMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getSubspaceId() const;
    virtual void setSubspaceId(int subspaceId);
    virtual simtime_t getTimestamp() const;
    virtual void setTimestamp(simtime_t timestamp);
    virtual NodeHandle& getPlayer();
    virtual const NodeHandle& getPlayer() const {return const_cast<PubSubMoveMessage*>(this)->getPlayer();}
    virtual void setPlayer(const NodeHandle& player);
    virtual Vector2D& getPosition();
    virtual const Vector2D& getPosition() const {return const_cast<PubSubMoveMessage*>(this)->getPosition();}
    virtual void setPosition(const Vector2D& position);
};

inline void doPacking(cCommBuffer *b, PubSubMoveMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, PubSubMoveMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/pubsubmmog/PubSubMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet PubSubMoveListMessage extends BaseOverlayMessage
 * {
 *         int subspaceId;
 *         simtime_t timestamp;
 *         NodeHandle player[];
 *         Vector2D position[];
 *         simtime_t positionAge[];
 * }
 * </pre>
 */
class PubSubMoveListMessage : public ::BaseOverlayMessage
{
  protected:
    int subspaceId_var;
    simtime_t timestamp_var;
    NodeHandle *player_var; // array ptr
    unsigned int player_arraysize;
    Vector2D *position_var; // array ptr
    unsigned int position_arraysize;
    simtime_t *positionAge_var; // array ptr
    unsigned int positionAge_arraysize;

  private:
    void copy(const PubSubMoveListMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PubSubMoveListMessage&);

  public:
    PubSubMoveListMessage(const char *name=NULL, int kind=0);
    PubSubMoveListMessage(const PubSubMoveListMessage& other);
    virtual ~PubSubMoveListMessage();
    PubSubMoveListMessage& operator=(const PubSubMoveListMessage& other);
    virtual PubSubMoveListMessage *dup() const {return new PubSubMoveListMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getSubspaceId() const;
    virtual void setSubspaceId(int subspaceId);
    virtual simtime_t getTimestamp() const;
    virtual void setTimestamp(simtime_t timestamp);
    virtual void setPlayerArraySize(unsigned int size);
    virtual unsigned int getPlayerArraySize() const;
    virtual NodeHandle& getPlayer(unsigned int k);
    virtual const NodeHandle& getPlayer(unsigned int k) const {return const_cast<PubSubMoveListMessage*>(this)->getPlayer(k);}
    virtual void setPlayer(unsigned int k, const NodeHandle& player);
    virtual void setPositionArraySize(unsigned int size);
    virtual unsigned int getPositionArraySize() const;
    virtual Vector2D& getPosition(unsigned int k);
    virtual const Vector2D& getPosition(unsigned int k) const {return const_cast<PubSubMoveListMessage*>(this)->getPosition(k);}
    virtual void setPosition(unsigned int k, const Vector2D& position);
    virtual void setPositionAgeArraySize(unsigned int size);
    virtual unsigned int getPositionAgeArraySize() const;
    virtual simtime_t getPositionAge(unsigned int k) const;
    virtual void setPositionAge(unsigned int k, simtime_t positionAge);
};

inline void doPacking(cCommBuffer *b, PubSubMoveListMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, PubSubMoveListMessage& obj) {obj.parsimUnpack(b);}


#endif // _PUBSUBMESSAGE_M_H_
