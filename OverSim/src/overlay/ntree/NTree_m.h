//
// Generated file, do not edit! Created by opp_msgc 4.3 from overlay/ntree/NTree.msg.
//

#ifndef _NTREE_M_H_
#define _NTREE_M_H_

#include <omnetpp.h>

// opp_msgc version check
#define MSGC_VERSION 0x0403
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of opp_msgc: 'make clean' should help.
#endif

// cplusplus {{
#include <CommonMessages_m.h>
#include <Vector2D.h>

static const int NTREEPOSITION_L = 128;
static const int NTREESIZE_L = 64;
static const int NTREEQUADRANT_L = 2;
static const int NTREECHILDCOUNT_L = 16;

#define NTREEJOINCALL_L(msg) (NTREEPOSITION_L + BASECALL_L(msg))
#define NTREEJOINRESPONSE_L(msg) (NTREEPOSITION_L + NTREESIZE_L + msg->getMembersArraySize() * NODEHANDLE_L + BASERESPONSE_L(msg))
#define NTREEDIVIDECALL_L(msg) (NTREEPOSITION_L + NTREESIZE_L + NTREEQUADRANT_L + BASECALL_L(msg))
#define NTREEDIVIDERESPONSE_L(msg) (BASERESPONSE_L(msg))
#define NTREEPINGCALL_L(msg) (NTREEPOSITION_L + NTREESIZE_L + NODEHANDLE_L + BASECALL_L(msg))
#define NTREENODEPINGCALL_L(msg) (NTREEPINGCALL_L(msg) + 4*NODEHANDLE_L + NTREEQUADRANT_L)
#define NTREEPINGRESPONSE_L(msg) (BASERESPONSE_L(msg))
#define NTREENODEPINGRESPONSE_L(msg) (NTREEPINGRESPONSE_L(msg) + msg->getMembersArraySize() * NODEHANDLE_L + NTREECHILDCOUNT_L)
#define NTREEDELETE_L(msg) (NTREEPOSITION_L + NTREESIZE_L + 4*NODEHANDLE_L + BASEOVERLAY_L(msg))
#define NTREECOLLAPSE_L(msg) (NTREEPOSITION_L + NTREESIZE_L + NODEHANDLE_L + BASEOVERLAY_L(msg))
#define NTREELEAVE_L(msg) (NTREEPOSITION_L + NODEHANDLE_L + BASEOVERLAY_L(msg))
#define NTREEMOVE_L(msg) (NTREEPOSITION_L + NODEHANDLE_L + BASEOVERLAY_L(msg))
#define NTREEADD_L(msg) (NTREEPOSITION_L + NODEHANDLE_L + BASEOVERLAY_L(msg))
#define NTREEREPLACE_L(msg) (NTREEPOSITION_L + NTREESIZE_L + (msg->getChildrenArraySize() +1)*NODEHANDLE_L + TRANSPORTADDRESS_L + 1 + BASEOVERLAY_L(msg))
#define NTREETAKEOVER_L(msg) (NTREEPOSITION_L + NTREESIZE_L + NODEHANDLE_L + BASEOVERLAY_L(msg))
// }}



/**
 * Class generated from <tt>overlay/ntree/NTree.msg</tt> by opp_msgc.
 * <pre>
 * packet NTreeJoinCall extends BaseCallMessage
 * {
 *         Vector2D position;
 * }
 * </pre>
 */
class NTreeJoinCall : public ::BaseCallMessage
{
  protected:
    Vector2D position_var;

  private:
    void copy(const NTreeJoinCall& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NTreeJoinCall&);

  public:
    NTreeJoinCall(const char *name=NULL, int kind=0);
    NTreeJoinCall(const NTreeJoinCall& other);
    virtual ~NTreeJoinCall();
    NTreeJoinCall& operator=(const NTreeJoinCall& other);
    virtual NTreeJoinCall *dup() const {return new NTreeJoinCall(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual Vector2D& getPosition();
    virtual const Vector2D& getPosition() const {return const_cast<NTreeJoinCall*>(this)->getPosition();}
    virtual void setPosition(const Vector2D& position);
};

inline void doPacking(cCommBuffer *b, NTreeJoinCall& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, NTreeJoinCall& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/ntree/NTree.msg</tt> by opp_msgc.
 * <pre>
 * packet NTreeJoinResponse extends BaseResponseMessage
 * {
 *         Vector2D origin;
 *         double size;
 *         NodeHandle members[];
 * }
 * </pre>
 */
class NTreeJoinResponse : public ::BaseResponseMessage
{
  protected:
    Vector2D origin_var;
    double size_var;
    NodeHandle *members_var; // array ptr
    unsigned int members_arraysize;

  private:
    void copy(const NTreeJoinResponse& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NTreeJoinResponse&);

  public:
    NTreeJoinResponse(const char *name=NULL, int kind=0);
    NTreeJoinResponse(const NTreeJoinResponse& other);
    virtual ~NTreeJoinResponse();
    NTreeJoinResponse& operator=(const NTreeJoinResponse& other);
    virtual NTreeJoinResponse *dup() const {return new NTreeJoinResponse(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual Vector2D& getOrigin();
    virtual const Vector2D& getOrigin() const {return const_cast<NTreeJoinResponse*>(this)->getOrigin();}
    virtual void setOrigin(const Vector2D& origin);
    virtual double getSize() const;
    virtual void setSize(double size);
    virtual void setMembersArraySize(unsigned int size);
    virtual unsigned int getMembersArraySize() const;
    virtual NodeHandle& getMembers(unsigned int k);
    virtual const NodeHandle& getMembers(unsigned int k) const {return const_cast<NTreeJoinResponse*>(this)->getMembers(k);}
    virtual void setMembers(unsigned int k, const NodeHandle& members);
};

inline void doPacking(cCommBuffer *b, NTreeJoinResponse& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, NTreeJoinResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/ntree/NTree.msg</tt> by opp_msgc.
 * <pre>
 * packet NTreeDivideCall extends BaseCallMessage
 * {
 *         Vector2D origin;
 *         double size;
 *         int quadrant;
 * }
 * </pre>
 */
class NTreeDivideCall : public ::BaseCallMessage
{
  protected:
    Vector2D origin_var;
    double size_var;
    int quadrant_var;

  private:
    void copy(const NTreeDivideCall& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NTreeDivideCall&);

  public:
    NTreeDivideCall(const char *name=NULL, int kind=0);
    NTreeDivideCall(const NTreeDivideCall& other);
    virtual ~NTreeDivideCall();
    NTreeDivideCall& operator=(const NTreeDivideCall& other);
    virtual NTreeDivideCall *dup() const {return new NTreeDivideCall(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual Vector2D& getOrigin();
    virtual const Vector2D& getOrigin() const {return const_cast<NTreeDivideCall*>(this)->getOrigin();}
    virtual void setOrigin(const Vector2D& origin);
    virtual double getSize() const;
    virtual void setSize(double size);
    virtual int getQuadrant() const;
    virtual void setQuadrant(int quadrant);
};

inline void doPacking(cCommBuffer *b, NTreeDivideCall& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, NTreeDivideCall& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/ntree/NTree.msg</tt> by opp_msgc.
 * <pre>
 * packet NTreeDivideResponse extends BaseResponseMessage
 * {
 *         int quadrant;
 * }
 * </pre>
 */
class NTreeDivideResponse : public ::BaseResponseMessage
{
  protected:
    int quadrant_var;

  private:
    void copy(const NTreeDivideResponse& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NTreeDivideResponse&);

  public:
    NTreeDivideResponse(const char *name=NULL, int kind=0);
    NTreeDivideResponse(const NTreeDivideResponse& other);
    virtual ~NTreeDivideResponse();
    NTreeDivideResponse& operator=(const NTreeDivideResponse& other);
    virtual NTreeDivideResponse *dup() const {return new NTreeDivideResponse(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getQuadrant() const;
    virtual void setQuadrant(int quadrant);
};

inline void doPacking(cCommBuffer *b, NTreeDivideResponse& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, NTreeDivideResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/ntree/NTree.msg</tt> by opp_msgc.
 * <pre>
 * packet NTreePingCall extends BaseCallMessage
 * {
 *         Vector2D origin;
 *         double size;
 *         NodeHandle parent;
 * }
 * </pre>
 */
class NTreePingCall : public ::BaseCallMessage
{
  protected:
    Vector2D origin_var;
    double size_var;
    NodeHandle parent_var;

  private:
    void copy(const NTreePingCall& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NTreePingCall&);

  public:
    NTreePingCall(const char *name=NULL, int kind=0);
    NTreePingCall(const NTreePingCall& other);
    virtual ~NTreePingCall();
    NTreePingCall& operator=(const NTreePingCall& other);
    virtual NTreePingCall *dup() const {return new NTreePingCall(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual Vector2D& getOrigin();
    virtual const Vector2D& getOrigin() const {return const_cast<NTreePingCall*>(this)->getOrigin();}
    virtual void setOrigin(const Vector2D& origin);
    virtual double getSize() const;
    virtual void setSize(double size);
    virtual NodeHandle& getParent();
    virtual const NodeHandle& getParent() const {return const_cast<NTreePingCall*>(this)->getParent();}
    virtual void setParent(const NodeHandle& parent);
};

inline void doPacking(cCommBuffer *b, NTreePingCall& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, NTreePingCall& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/ntree/NTree.msg</tt> by opp_msgc.
 * <pre>
 * packet NTreeNodePingCall extends NTreePingCall
 * {
 *         NodeHandle siblings[4];
 *         int quadrant;
 * }
 * </pre>
 */
class NTreeNodePingCall : public ::NTreePingCall
{
  protected:
    NodeHandle siblings_var[4];
    int quadrant_var;

  private:
    void copy(const NTreeNodePingCall& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NTreeNodePingCall&);

  public:
    NTreeNodePingCall(const char *name=NULL, int kind=0);
    NTreeNodePingCall(const NTreeNodePingCall& other);
    virtual ~NTreeNodePingCall();
    NTreeNodePingCall& operator=(const NTreeNodePingCall& other);
    virtual NTreeNodePingCall *dup() const {return new NTreeNodePingCall(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned int getSiblingsArraySize() const;
    virtual NodeHandle& getSiblings(unsigned int k);
    virtual const NodeHandle& getSiblings(unsigned int k) const {return const_cast<NTreeNodePingCall*>(this)->getSiblings(k);}
    virtual void setSiblings(unsigned int k, const NodeHandle& siblings);
    virtual int getQuadrant() const;
    virtual void setQuadrant(int quadrant);
};

inline void doPacking(cCommBuffer *b, NTreeNodePingCall& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, NTreeNodePingCall& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/ntree/NTree.msg</tt> by opp_msgc.
 * <pre>
 * packet NTreePingResponse extends BaseResponseMessage
 * {
 * }
 * </pre>
 */
class NTreePingResponse : public ::BaseResponseMessage
{
  protected:

  private:
    void copy(const NTreePingResponse& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NTreePingResponse&);

  public:
    NTreePingResponse(const char *name=NULL, int kind=0);
    NTreePingResponse(const NTreePingResponse& other);
    virtual ~NTreePingResponse();
    NTreePingResponse& operator=(const NTreePingResponse& other);
    virtual NTreePingResponse *dup() const {return new NTreePingResponse(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, NTreePingResponse& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, NTreePingResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/ntree/NTree.msg</tt> by opp_msgc.
 * <pre>
 * packet NTreeNodePingResponse extends NTreePingResponse
 * {
 *         NodeHandle members[];
 *         int aggChildCount;
 * }
 * </pre>
 */
class NTreeNodePingResponse : public ::NTreePingResponse
{
  protected:
    NodeHandle *members_var; // array ptr
    unsigned int members_arraysize;
    int aggChildCount_var;

  private:
    void copy(const NTreeNodePingResponse& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NTreeNodePingResponse&);

  public:
    NTreeNodePingResponse(const char *name=NULL, int kind=0);
    NTreeNodePingResponse(const NTreeNodePingResponse& other);
    virtual ~NTreeNodePingResponse();
    NTreeNodePingResponse& operator=(const NTreeNodePingResponse& other);
    virtual NTreeNodePingResponse *dup() const {return new NTreeNodePingResponse(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual void setMembersArraySize(unsigned int size);
    virtual unsigned int getMembersArraySize() const;
    virtual NodeHandle& getMembers(unsigned int k);
    virtual const NodeHandle& getMembers(unsigned int k) const {return const_cast<NTreeNodePingResponse*>(this)->getMembers(k);}
    virtual void setMembers(unsigned int k, const NodeHandle& members);
    virtual int getAggChildCount() const;
    virtual void setAggChildCount(int aggChildCount);
};

inline void doPacking(cCommBuffer *b, NTreeNodePingResponse& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, NTreeNodePingResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/ntree/NTree.msg</tt> by opp_msgc.
 * <pre>
 * packet NTreeGroupDeleteMessage extends BaseOverlayMessage
 * {
 *         Vector2D origin;
 *         double size;
 *         NodeHandle newChild[4];
 * }
 * </pre>
 */
class NTreeGroupDeleteMessage : public ::BaseOverlayMessage
{
  protected:
    Vector2D origin_var;
    double size_var;
    NodeHandle newChild_var[4];

  private:
    void copy(const NTreeGroupDeleteMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NTreeGroupDeleteMessage&);

  public:
    NTreeGroupDeleteMessage(const char *name=NULL, int kind=0);
    NTreeGroupDeleteMessage(const NTreeGroupDeleteMessage& other);
    virtual ~NTreeGroupDeleteMessage();
    NTreeGroupDeleteMessage& operator=(const NTreeGroupDeleteMessage& other);
    virtual NTreeGroupDeleteMessage *dup() const {return new NTreeGroupDeleteMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual Vector2D& getOrigin();
    virtual const Vector2D& getOrigin() const {return const_cast<NTreeGroupDeleteMessage*>(this)->getOrigin();}
    virtual void setOrigin(const Vector2D& origin);
    virtual double getSize() const;
    virtual void setSize(double size);
    virtual unsigned int getNewChildArraySize() const;
    virtual NodeHandle& getNewChild(unsigned int k);
    virtual const NodeHandle& getNewChild(unsigned int k) const {return const_cast<NTreeGroupDeleteMessage*>(this)->getNewChild(k);}
    virtual void setNewChild(unsigned int k, const NodeHandle& newChild);
};

inline void doPacking(cCommBuffer *b, NTreeGroupDeleteMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, NTreeGroupDeleteMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/ntree/NTree.msg</tt> by opp_msgc.
 * <pre>
 * packet NTreeCollapseMessage extends BaseOverlayMessage
 * {
 *         Vector2D origin;
 *         double size;
 *         NodeHandle player;
 * }
 * </pre>
 */
class NTreeCollapseMessage : public ::BaseOverlayMessage
{
  protected:
    Vector2D origin_var;
    double size_var;
    NodeHandle player_var;

  private:
    void copy(const NTreeCollapseMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NTreeCollapseMessage&);

  public:
    NTreeCollapseMessage(const char *name=NULL, int kind=0);
    NTreeCollapseMessage(const NTreeCollapseMessage& other);
    virtual ~NTreeCollapseMessage();
    NTreeCollapseMessage& operator=(const NTreeCollapseMessage& other);
    virtual NTreeCollapseMessage *dup() const {return new NTreeCollapseMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual Vector2D& getOrigin();
    virtual const Vector2D& getOrigin() const {return const_cast<NTreeCollapseMessage*>(this)->getOrigin();}
    virtual void setOrigin(const Vector2D& origin);
    virtual double getSize() const;
    virtual void setSize(double size);
    virtual NodeHandle& getPlayer();
    virtual const NodeHandle& getPlayer() const {return const_cast<NTreeCollapseMessage*>(this)->getPlayer();}
    virtual void setPlayer(const NodeHandle& player);
};

inline void doPacking(cCommBuffer *b, NTreeCollapseMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, NTreeCollapseMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/ntree/NTree.msg</tt> by opp_msgc.
 * <pre>
 * packet NTreeLeaveMessage extends BaseOverlayMessage
 * {
 *         NodeHandle player;
 *         Vector2D position;
 * }
 * </pre>
 */
class NTreeLeaveMessage : public ::BaseOverlayMessage
{
  protected:
    NodeHandle player_var;
    Vector2D position_var;

  private:
    void copy(const NTreeLeaveMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NTreeLeaveMessage&);

  public:
    NTreeLeaveMessage(const char *name=NULL, int kind=0);
    NTreeLeaveMessage(const NTreeLeaveMessage& other);
    virtual ~NTreeLeaveMessage();
    NTreeLeaveMessage& operator=(const NTreeLeaveMessage& other);
    virtual NTreeLeaveMessage *dup() const {return new NTreeLeaveMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual NodeHandle& getPlayer();
    virtual const NodeHandle& getPlayer() const {return const_cast<NTreeLeaveMessage*>(this)->getPlayer();}
    virtual void setPlayer(const NodeHandle& player);
    virtual Vector2D& getPosition();
    virtual const Vector2D& getPosition() const {return const_cast<NTreeLeaveMessage*>(this)->getPosition();}
    virtual void setPosition(const Vector2D& position);
};

inline void doPacking(cCommBuffer *b, NTreeLeaveMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, NTreeLeaveMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/ntree/NTree.msg</tt> by opp_msgc.
 * <pre>
 * packet NTreeMoveMessage extends BaseOverlayMessage
 * {
 *         NodeHandle player;
 *         Vector2D position;
 * }
 * </pre>
 */
class NTreeMoveMessage : public ::BaseOverlayMessage
{
  protected:
    NodeHandle player_var;
    Vector2D position_var;

  private:
    void copy(const NTreeMoveMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NTreeMoveMessage&);

  public:
    NTreeMoveMessage(const char *name=NULL, int kind=0);
    NTreeMoveMessage(const NTreeMoveMessage& other);
    virtual ~NTreeMoveMessage();
    NTreeMoveMessage& operator=(const NTreeMoveMessage& other);
    virtual NTreeMoveMessage *dup() const {return new NTreeMoveMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual NodeHandle& getPlayer();
    virtual const NodeHandle& getPlayer() const {return const_cast<NTreeMoveMessage*>(this)->getPlayer();}
    virtual void setPlayer(const NodeHandle& player);
    virtual Vector2D& getPosition();
    virtual const Vector2D& getPosition() const {return const_cast<NTreeMoveMessage*>(this)->getPosition();}
    virtual void setPosition(const Vector2D& position);
};

inline void doPacking(cCommBuffer *b, NTreeMoveMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, NTreeMoveMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/ntree/NTree.msg</tt> by opp_msgc.
 * <pre>
 * packet NTreeGroupAddMessage extends BaseOverlayMessage
 * {
 *         NodeHandle player;
 *         Vector2D origin;
 * }
 * </pre>
 */
class NTreeGroupAddMessage : public ::BaseOverlayMessage
{
  protected:
    NodeHandle player_var;
    Vector2D origin_var;

  private:
    void copy(const NTreeGroupAddMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NTreeGroupAddMessage&);

  public:
    NTreeGroupAddMessage(const char *name=NULL, int kind=0);
    NTreeGroupAddMessage(const NTreeGroupAddMessage& other);
    virtual ~NTreeGroupAddMessage();
    NTreeGroupAddMessage& operator=(const NTreeGroupAddMessage& other);
    virtual NTreeGroupAddMessage *dup() const {return new NTreeGroupAddMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual NodeHandle& getPlayer();
    virtual const NodeHandle& getPlayer() const {return const_cast<NTreeGroupAddMessage*>(this)->getPlayer();}
    virtual void setPlayer(const NodeHandle& player);
    virtual Vector2D& getOrigin();
    virtual const Vector2D& getOrigin() const {return const_cast<NTreeGroupAddMessage*>(this)->getOrigin();}
    virtual void setOrigin(const Vector2D& origin);
};

inline void doPacking(cCommBuffer *b, NTreeGroupAddMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, NTreeGroupAddMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/ntree/NTree.msg</tt> by opp_msgc.
 * <pre>
 * packet NTreeReplaceNodeMessage extends BaseOverlayMessage
 * {
 *         Vector2D origin;
 *         double size;
 *         NodeHandle parent;
 *         NodeHandle children[];
 *         TransportAddress oldNode;
 *         bool isLeaf;
 * }
 * </pre>
 */
class NTreeReplaceNodeMessage : public ::BaseOverlayMessage
{
  protected:
    Vector2D origin_var;
    double size_var;
    NodeHandle parent_var;
    NodeHandle *children_var; // array ptr
    unsigned int children_arraysize;
    TransportAddress oldNode_var;
    bool isLeaf_var;

  private:
    void copy(const NTreeReplaceNodeMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NTreeReplaceNodeMessage&);

  public:
    NTreeReplaceNodeMessage(const char *name=NULL, int kind=0);
    NTreeReplaceNodeMessage(const NTreeReplaceNodeMessage& other);
    virtual ~NTreeReplaceNodeMessage();
    NTreeReplaceNodeMessage& operator=(const NTreeReplaceNodeMessage& other);
    virtual NTreeReplaceNodeMessage *dup() const {return new NTreeReplaceNodeMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual Vector2D& getOrigin();
    virtual const Vector2D& getOrigin() const {return const_cast<NTreeReplaceNodeMessage*>(this)->getOrigin();}
    virtual void setOrigin(const Vector2D& origin);
    virtual double getSize() const;
    virtual void setSize(double size);
    virtual NodeHandle& getParent();
    virtual const NodeHandle& getParent() const {return const_cast<NTreeReplaceNodeMessage*>(this)->getParent();}
    virtual void setParent(const NodeHandle& parent);
    virtual void setChildrenArraySize(unsigned int size);
    virtual unsigned int getChildrenArraySize() const;
    virtual NodeHandle& getChildren(unsigned int k);
    virtual const NodeHandle& getChildren(unsigned int k) const {return const_cast<NTreeReplaceNodeMessage*>(this)->getChildren(k);}
    virtual void setChildren(unsigned int k, const NodeHandle& children);
    virtual TransportAddress& getOldNode();
    virtual const TransportAddress& getOldNode() const {return const_cast<NTreeReplaceNodeMessage*>(this)->getOldNode();}
    virtual void setOldNode(const TransportAddress& oldNode);
    virtual bool getIsLeaf() const;
    virtual void setIsLeaf(bool isLeaf);
};

inline void doPacking(cCommBuffer *b, NTreeReplaceNodeMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, NTreeReplaceNodeMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/ntree/NTree.msg</tt> by opp_msgc.
 * <pre>
 * packet NTreeTakeOverMessage extends BaseOverlayMessage
 * {
 *         Vector2D origin;
 *         double size;
 *         NodeHandle player;
 * }
 * </pre>
 */
class NTreeTakeOverMessage : public ::BaseOverlayMessage
{
  protected:
    Vector2D origin_var;
    double size_var;
    NodeHandle player_var;

  private:
    void copy(const NTreeTakeOverMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NTreeTakeOverMessage&);

  public:
    NTreeTakeOverMessage(const char *name=NULL, int kind=0);
    NTreeTakeOverMessage(const NTreeTakeOverMessage& other);
    virtual ~NTreeTakeOverMessage();
    NTreeTakeOverMessage& operator=(const NTreeTakeOverMessage& other);
    virtual NTreeTakeOverMessage *dup() const {return new NTreeTakeOverMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual Vector2D& getOrigin();
    virtual const Vector2D& getOrigin() const {return const_cast<NTreeTakeOverMessage*>(this)->getOrigin();}
    virtual void setOrigin(const Vector2D& origin);
    virtual double getSize() const;
    virtual void setSize(double size);
    virtual NodeHandle& getPlayer();
    virtual const NodeHandle& getPlayer() const {return const_cast<NTreeTakeOverMessage*>(this)->getPlayer();}
    virtual void setPlayer(const NodeHandle& player);
};

inline void doPacking(cCommBuffer *b, NTreeTakeOverMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, NTreeTakeOverMessage& obj) {obj.parsimUnpack(b);}


#endif // _NTREE_M_H_
