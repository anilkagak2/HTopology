//
// Generated file, do not edit! Created by opp_msgc 4.3 from overlay/vast/Vast.msg.
//

#ifndef _VAST_M_H_
#define _VAST_M_H_

#include <omnetpp.h>

// opp_msgc version check
#define MSGC_VERSION 0x0403
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of opp_msgc: 'make clean' should help.
#endif

// cplusplus {{
#include <NodeHandle.h>
#include <OverlayKey.h>
#include <Vector2D.h>
#include <CommonMessages_m.h>


static const int VASTCOMMAND_L = 8;
static const int POSITION_L = 128;
static const int ENTRYCOUNT_L = 32;
static const int COUNT_L = 32;
static const int FLAG_L = 8;

#define VAST_L(msg) (VASTCOMMAND_L + NODEHANDLE_L + KEY_L + POSITION_L + COUNT_L)
#define VASTLIST_L(msg) (VAST_L(msg) + ENTRYCOUNT_L + FLAG_L + msg->getNeighborNodeArraySize() * (NODEHANDLE_L + POSITION_L))
#define VASTMOVE_L(msg) (VAST_L(msg) + POSITION_L + 2 * FLAG_L)
#define VASTDISCARD_L(msg) (VAST_L(msg) + NODEHANDLE_L)
// }}



/**
 * Enum generated from <tt>overlay/vast/Vast.msg</tt> by opp_msgc.
 * <pre>
 * enum VASTCommand
 * {
 *     JOIN_REQUEST = 0;
 *     JOIN_ACKNOWLEDGE = 1;
 *     NODE_MOVE = 2;
 *     NEW_NEIGHBORS = 3;
 *     NODE_LEAVE = 4;
 *     ENCLOSING_NEIGHBORS_REQUEST = 5;
 *     BACKUP_NEIGHBORS = 6;
 *     PING = 7;
 *     PONG = 8;
 *     DISCARD_NODE = 9;
 *     VAST_EVENT = 10;
 * }
 * </pre>
 */
enum VASTCommand {
    JOIN_REQUEST = 0,
    JOIN_ACKNOWLEDGE = 1,
    NODE_MOVE = 2,
    NEW_NEIGHBORS = 3,
    NODE_LEAVE = 4,
    ENCLOSING_NEIGHBORS_REQUEST = 5,
    BACKUP_NEIGHBORS = 6,
    PING = 7,
    PONG = 8,
    DISCARD_NODE = 9,
    VAST_EVENT = 10
};

/**
 * Class generated from <tt>overlay/vast/Vast.msg</tt> by opp_msgc.
 * <pre>
 * packet VastMessage extends BaseOverlayMessage
 * {
 *     int command enum(VASTCommand);
 *     NodeHandle sourceNode;
 *     OverlayKey destKey;
 *     Vector2D pos;
 *     int neighborCount;
 * }
 * </pre>
 */
class VastMessage : public ::BaseOverlayMessage
{
  protected:
    int command_var;
    NodeHandle sourceNode_var;
    OverlayKey destKey_var;
    Vector2D pos_var;
    int neighborCount_var;

  private:
    void copy(const VastMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const VastMessage&);

  public:
    VastMessage(const char *name=NULL, int kind=0);
    VastMessage(const VastMessage& other);
    virtual ~VastMessage();
    VastMessage& operator=(const VastMessage& other);
    virtual VastMessage *dup() const {return new VastMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getCommand() const;
    virtual void setCommand(int command);
    virtual NodeHandle& getSourceNode();
    virtual const NodeHandle& getSourceNode() const {return const_cast<VastMessage*>(this)->getSourceNode();}
    virtual void setSourceNode(const NodeHandle& sourceNode);
    virtual OverlayKey& getDestKey();
    virtual const OverlayKey& getDestKey() const {return const_cast<VastMessage*>(this)->getDestKey();}
    virtual void setDestKey(const OverlayKey& destKey);
    virtual Vector2D& getPos();
    virtual const Vector2D& getPos() const {return const_cast<VastMessage*>(this)->getPos();}
    virtual void setPos(const Vector2D& pos);
    virtual int getNeighborCount() const;
    virtual void setNeighborCount(int neighborCount);
};

inline void doPacking(cCommBuffer *b, VastMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, VastMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/vast/Vast.msg</tt> by opp_msgc.
 * <pre>
 * packet VastListMessage extends VastMessage 
 * {
 *     NodeHandle neighborNode[];
 *     Vector2D neighborPos[];
 *     bool requestEnclosingNeighbors = false;
 * }
 * </pre>
 */
class VastListMessage : public ::VastMessage
{
  protected:
    NodeHandle *neighborNode_var; // array ptr
    unsigned int neighborNode_arraysize;
    Vector2D *neighborPos_var; // array ptr
    unsigned int neighborPos_arraysize;
    bool requestEnclosingNeighbors_var;

  private:
    void copy(const VastListMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const VastListMessage&);

  public:
    VastListMessage(const char *name=NULL, int kind=0);
    VastListMessage(const VastListMessage& other);
    virtual ~VastListMessage();
    VastListMessage& operator=(const VastListMessage& other);
    virtual VastListMessage *dup() const {return new VastListMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual void setNeighborNodeArraySize(unsigned int size);
    virtual unsigned int getNeighborNodeArraySize() const;
    virtual NodeHandle& getNeighborNode(unsigned int k);
    virtual const NodeHandle& getNeighborNode(unsigned int k) const {return const_cast<VastListMessage*>(this)->getNeighborNode(k);}
    virtual void setNeighborNode(unsigned int k, const NodeHandle& neighborNode);
    virtual void setNeighborPosArraySize(unsigned int size);
    virtual unsigned int getNeighborPosArraySize() const;
    virtual Vector2D& getNeighborPos(unsigned int k);
    virtual const Vector2D& getNeighborPos(unsigned int k) const {return const_cast<VastListMessage*>(this)->getNeighborPos(k);}
    virtual void setNeighborPos(unsigned int k, const Vector2D& neighborPos);
    virtual bool getRequestEnclosingNeighbors() const;
    virtual void setRequestEnclosingNeighbors(bool requestEnclosingNeighbors);
};

inline void doPacking(cCommBuffer *b, VastListMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, VastListMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/vast/Vast.msg</tt> by opp_msgc.
 * <pre>
 * packet VastMoveMessage extends VastMessage 
 * {
 *     Vector2D newPos;
 *     bool is_boundary = false;
 *     bool request_list = false;
 * }
 * </pre>
 */
class VastMoveMessage : public ::VastMessage
{
  protected:
    Vector2D newPos_var;
    bool is_boundary_var;
    bool request_list_var;

  private:
    void copy(const VastMoveMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const VastMoveMessage&);

  public:
    VastMoveMessage(const char *name=NULL, int kind=0);
    VastMoveMessage(const VastMoveMessage& other);
    virtual ~VastMoveMessage();
    VastMoveMessage& operator=(const VastMoveMessage& other);
    virtual VastMoveMessage *dup() const {return new VastMoveMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual Vector2D& getNewPos();
    virtual const Vector2D& getNewPos() const {return const_cast<VastMoveMessage*>(this)->getNewPos();}
    virtual void setNewPos(const Vector2D& newPos);
    virtual bool getIs_boundary() const;
    virtual void setIs_boundary(bool is_boundary);
    virtual bool getRequest_list() const;
    virtual void setRequest_list(bool request_list);
};

inline void doPacking(cCommBuffer *b, VastMoveMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, VastMoveMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/vast/Vast.msg</tt> by opp_msgc.
 * <pre>
 * packet VastDiscardMessage extends VastMessage 
 * {
 *     NodeHandle discardNode;
 * }
 * </pre>
 */
class VastDiscardMessage : public ::VastMessage
{
  protected:
    NodeHandle discardNode_var;

  private:
    void copy(const VastDiscardMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const VastDiscardMessage&);

  public:
    VastDiscardMessage(const char *name=NULL, int kind=0);
    VastDiscardMessage(const VastDiscardMessage& other);
    virtual ~VastDiscardMessage();
    VastDiscardMessage& operator=(const VastDiscardMessage& other);
    virtual VastDiscardMessage *dup() const {return new VastDiscardMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual NodeHandle& getDiscardNode();
    virtual const NodeHandle& getDiscardNode() const {return const_cast<VastDiscardMessage*>(this)->getDiscardNode();}
    virtual void setDiscardNode(const NodeHandle& discardNode);
};

inline void doPacking(cCommBuffer *b, VastDiscardMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, VastDiscardMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/vast/Vast.msg</tt> by opp_msgc.
 * <pre>
 * packet VastEventMessage extends VastMessage
 * {
 * }
 * </pre>
 */
class VastEventMessage : public ::VastMessage
{
  protected:

  private:
    void copy(const VastEventMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const VastEventMessage&);

  public:
    VastEventMessage(const char *name=NULL, int kind=0);
    VastEventMessage(const VastEventMessage& other);
    virtual ~VastEventMessage();
    VastEventMessage& operator=(const VastEventMessage& other);
    virtual VastEventMessage *dup() const {return new VastEventMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, VastEventMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, VastEventMessage& obj) {obj.parsimUnpack(b);}


#endif // _VAST_M_H_
