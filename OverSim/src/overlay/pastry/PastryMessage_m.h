//
// Generated file, do not edit! Created by opp_msgc 4.3 from overlay/pastry/PastryMessage.msg.
//

#ifndef _PASTRYMESSAGE_M_H_
#define _PASTRYMESSAGE_M_H_

#include <omnetpp.h>

// opp_msgc version check
#define MSGC_VERSION 0x0403
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of opp_msgc: 'make clean' should help.
#endif

// cplusplus {{
#include <IPvXAddress.h>
#include <NodeHandle.h>
#include <OverlayKey.h>
#include <CommonMessages_m.h>


static const int PASTRYTYPE_L = 8;
static const int LASTHOPFLAG_L = 8;
static const int TIMESTAMP_L = 32;
static const int ROWNUMBER_L = 16;
static const int PASTRYFINDNODEEXTDATA_L = NODEHANDLE_L + HOPCOUNT_L;

#define PASTRY_L(msg) (BASEOVERLAY_L(msg) + PASTRYTYPE_L)

#define PASTRYSTATE_L(msg) (PASTRY_L(msg) + TRANSPORTADDRESS_L \
    + NODEHANDLE_L * \
    (msg->getRoutingTableArraySize() + msg->getLeafSetArraySize() \
    + msg->getNeighborhoodSetArraySize()) + 3 * ARRAYSIZE_L + HOPCOUNT_L + \
    LASTHOPFLAG_L + TIMESTAMP_L)

#define PASTRYNEWLEAFS_L(msg) (msg->getLeafsArraySize() * NODEHANDLE_L + \
        ARRAYSIZE_L)

#define PASTRYJOINCALL_L(msg) PASTRY_L(msg)
#define PASTRYJOINRESPONSE_L(msg) PASTRY_L(msg) 

#define PASTRYREQUESTSTATECALL_L(msg) PASTRY_L(msg)
#define PASTRYREQUESTSTATERESPONSE_L(msg) PASTRY_L(msg)

#define PASTRYREQUESTREPAIRCALL_L(msg) PASTRY_L(msg)
#define PASTRYREQUESTREPAIRRESPONSE_L(msg) PASTRY_L(msg)

#define PASTRYREQUESTLEAFSETCALL_L(msg) PASTRY_L(msg)
#define PASTRYREQUESTLEAFSETRESPONSE_L(msg) PASTRY_L(msg)

#define PASTRYREQUESTROUTINGROWCALL_L(msg) (PASTRY_L(msg) + ROWNUMBER_L)
#define PASTRYREQUESTROUTINGROWRESPONSE_L(msg) PASTRY_L(msg)
// }}



/**
 * Enum generated from <tt>overlay/pastry/PastryMessage.msg</tt> by opp_msgc.
 * <pre>
 * enum PastryStateMsgType
 * {
 *     PASTRY_STATE_STD        = 0x01;
 *     PASTRY_STATE_JOIN       = 0x02;
 *     PASTRY_STATE_MINJOIN    = 0x04;
 *     PASTRY_STATE_UPDATE     = 0x08;
 *     PASTRY_STATE_REPAIR     = 0x10;
 *     PASTRY_STATE_JOINUPDATE = 0x20;
 *     PASTRY_STATE_LEAFSET    = 0x40;
 *     PASTRY_STATE_ROUTINGROW = 0x80;
 * }
 * </pre>
 */
enum PastryStateMsgType {
    PASTRY_STATE_STD = 0x01,
    PASTRY_STATE_JOIN = 0x02,
    PASTRY_STATE_MINJOIN = 0x04,
    PASTRY_STATE_UPDATE = 0x08,
    PASTRY_STATE_REPAIR = 0x10,
    PASTRY_STATE_JOINUPDATE = 0x20,
    PASTRY_STATE_LEAFSET = 0x40,
    PASTRY_STATE_ROUTINGROW = 0x80
};

/**
 * Class generated from <tt>overlay/pastry/PastryMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet PastryStateMessage extends BaseOverlayMessage
 * {
 *     int pastryStateMsgType @enum(PastryStateMsgType) = PASTRY_STATE_STD;    
 *     NodeHandle sender = NodeHandle::UNSPECIFIED_NODE;    
 *     NodeHandle routingTable[];    
 *     NodeHandle leafSet[];         
 *     NodeHandle neighborhoodSet[]; 
 *     int row = 0;                  
 *     bool lastHop = false;         
 *     simtime_t timestamp;          
 * }
 * </pre>
 */
class PastryStateMessage : public ::BaseOverlayMessage
{
  protected:
    int pastryStateMsgType_var;
    NodeHandle sender_var;
    NodeHandle *routingTable_var; // array ptr
    unsigned int routingTable_arraysize;
    NodeHandle *leafSet_var; // array ptr
    unsigned int leafSet_arraysize;
    NodeHandle *neighborhoodSet_var; // array ptr
    unsigned int neighborhoodSet_arraysize;
    int row_var;
    bool lastHop_var;
    simtime_t timestamp_var;

  private:
    void copy(const PastryStateMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PastryStateMessage&);

  public:
    PastryStateMessage(const char *name=NULL, int kind=0);
    PastryStateMessage(const PastryStateMessage& other);
    virtual ~PastryStateMessage();
    PastryStateMessage& operator=(const PastryStateMessage& other);
    virtual PastryStateMessage *dup() const {return new PastryStateMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getPastryStateMsgType() const;
    virtual void setPastryStateMsgType(int pastryStateMsgType);
    virtual NodeHandle& getSender();
    virtual const NodeHandle& getSender() const {return const_cast<PastryStateMessage*>(this)->getSender();}
    virtual void setSender(const NodeHandle& sender);
    virtual void setRoutingTableArraySize(unsigned int size);
    virtual unsigned int getRoutingTableArraySize() const;
    virtual NodeHandle& getRoutingTable(unsigned int k);
    virtual const NodeHandle& getRoutingTable(unsigned int k) const {return const_cast<PastryStateMessage*>(this)->getRoutingTable(k);}
    virtual void setRoutingTable(unsigned int k, const NodeHandle& routingTable);
    virtual void setLeafSetArraySize(unsigned int size);
    virtual unsigned int getLeafSetArraySize() const;
    virtual NodeHandle& getLeafSet(unsigned int k);
    virtual const NodeHandle& getLeafSet(unsigned int k) const {return const_cast<PastryStateMessage*>(this)->getLeafSet(k);}
    virtual void setLeafSet(unsigned int k, const NodeHandle& leafSet);
    virtual void setNeighborhoodSetArraySize(unsigned int size);
    virtual unsigned int getNeighborhoodSetArraySize() const;
    virtual NodeHandle& getNeighborhoodSet(unsigned int k);
    virtual const NodeHandle& getNeighborhoodSet(unsigned int k) const {return const_cast<PastryStateMessage*>(this)->getNeighborhoodSet(k);}
    virtual void setNeighborhoodSet(unsigned int k, const NodeHandle& neighborhoodSet);
    virtual int getRow() const;
    virtual void setRow(int row);
    virtual bool getLastHop() const;
    virtual void setLastHop(bool lastHop);
    virtual simtime_t getTimestamp() const;
    virtual void setTimestamp(simtime_t timestamp);
};

inline void doPacking(cCommBuffer *b, PastryStateMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, PastryStateMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/pastry/PastryMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet PastryFindNodeExtData
 * {
 *     TransportAddress sendStateTo = TransportAddress::UNSPECIFIED_NODE;    
 *     int joinHopCount = 0;    
 * }
 * </pre>
 */
class PastryFindNodeExtData : public ::cPacket
{
  protected:
    TransportAddress sendStateTo_var;
    int joinHopCount_var;

  private:
    void copy(const PastryFindNodeExtData& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PastryFindNodeExtData&);

  public:
    PastryFindNodeExtData(const char *name=NULL, int kind=0);
    PastryFindNodeExtData(const PastryFindNodeExtData& other);
    virtual ~PastryFindNodeExtData();
    PastryFindNodeExtData& operator=(const PastryFindNodeExtData& other);
    virtual PastryFindNodeExtData *dup() const {return new PastryFindNodeExtData(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual TransportAddress& getSendStateTo();
    virtual const TransportAddress& getSendStateTo() const {return const_cast<PastryFindNodeExtData*>(this)->getSendStateTo();}
    virtual void setSendStateTo(const TransportAddress& sendStateTo);
    virtual int getJoinHopCount() const;
    virtual void setJoinHopCount(int joinHopCount);
};

inline void doPacking(cCommBuffer *b, PastryFindNodeExtData& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, PastryFindNodeExtData& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/pastry/PastryMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet PastryNewLeafsMessage
 * {
 *     NodeHandle leafs[];    
 * }
 * </pre>
 */
class PastryNewLeafsMessage : public ::cPacket
{
  protected:
    NodeHandle *leafs_var; // array ptr
    unsigned int leafs_arraysize;

  private:
    void copy(const PastryNewLeafsMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PastryNewLeafsMessage&);

  public:
    PastryNewLeafsMessage(const char *name=NULL, int kind=0);
    PastryNewLeafsMessage(const PastryNewLeafsMessage& other);
    virtual ~PastryNewLeafsMessage();
    PastryNewLeafsMessage& operator=(const PastryNewLeafsMessage& other);
    virtual PastryNewLeafsMessage *dup() const {return new PastryNewLeafsMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual void setLeafsArraySize(unsigned int size);
    virtual unsigned int getLeafsArraySize() const;
    virtual NodeHandle& getLeafs(unsigned int k);
    virtual const NodeHandle& getLeafs(unsigned int k) const {return const_cast<PastryNewLeafsMessage*>(this)->getLeafs(k);}
    virtual void setLeafs(unsigned int k, const NodeHandle& leafs);
};

inline void doPacking(cCommBuffer *b, PastryNewLeafsMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, PastryNewLeafsMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/pastry/PastryMessage.msg</tt> by opp_msgc.
 * <pre>
 * message PastrySendState
 * {
 *     TransportAddress dest = TransportAddress::UNSPECIFIED_NODE;
 * }
 * </pre>
 */
class PastrySendState : public ::cMessage
{
  protected:
    TransportAddress dest_var;

  private:
    void copy(const PastrySendState& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PastrySendState&);

  public:
    PastrySendState(const char *name=NULL, int kind=0);
    PastrySendState(const PastrySendState& other);
    virtual ~PastrySendState();
    PastrySendState& operator=(const PastrySendState& other);
    virtual PastrySendState *dup() const {return new PastrySendState(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual TransportAddress& getDest();
    virtual const TransportAddress& getDest() const {return const_cast<PastrySendState*>(this)->getDest();}
    virtual void setDest(const TransportAddress& dest);
};

inline void doPacking(cCommBuffer *b, PastrySendState& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, PastrySendState& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/pastry/PastryMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet PastryJoinCall extends BaseCallMessage
 * {
 * }
 * </pre>
 */
class PastryJoinCall : public ::BaseCallMessage
{
  protected:

  private:
    void copy(const PastryJoinCall& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PastryJoinCall&);

  public:
    PastryJoinCall(const char *name=NULL, int kind=0);
    PastryJoinCall(const PastryJoinCall& other);
    virtual ~PastryJoinCall();
    PastryJoinCall& operator=(const PastryJoinCall& other);
    virtual PastryJoinCall *dup() const {return new PastryJoinCall(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, PastryJoinCall& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, PastryJoinCall& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/pastry/PastryMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet PastryJoinResponse extends BaseResponseMessage
 * {
 * }
 * </pre>
 */
class PastryJoinResponse : public ::BaseResponseMessage
{
  protected:

  private:
    void copy(const PastryJoinResponse& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PastryJoinResponse&);

  public:
    PastryJoinResponse(const char *name=NULL, int kind=0);
    PastryJoinResponse(const PastryJoinResponse& other);
    virtual ~PastryJoinResponse();
    PastryJoinResponse& operator=(const PastryJoinResponse& other);
    virtual PastryJoinResponse *dup() const {return new PastryJoinResponse(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, PastryJoinResponse& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, PastryJoinResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/pastry/PastryMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet RequestStateCall extends BaseCallMessage
 * {
 * }
 * </pre>
 */
class RequestStateCall : public ::BaseCallMessage
{
  protected:

  private:
    void copy(const RequestStateCall& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const RequestStateCall&);

  public:
    RequestStateCall(const char *name=NULL, int kind=0);
    RequestStateCall(const RequestStateCall& other);
    virtual ~RequestStateCall();
    RequestStateCall& operator=(const RequestStateCall& other);
    virtual RequestStateCall *dup() const {return new RequestStateCall(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, RequestStateCall& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, RequestStateCall& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/pastry/PastryMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet RequestStateResponse extends BaseResponseMessage
 * {
 * }
 * </pre>
 */
class RequestStateResponse : public ::BaseResponseMessage
{
  protected:

  private:
    void copy(const RequestStateResponse& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const RequestStateResponse&);

  public:
    RequestStateResponse(const char *name=NULL, int kind=0);
    RequestStateResponse(const RequestStateResponse& other);
    virtual ~RequestStateResponse();
    RequestStateResponse& operator=(const RequestStateResponse& other);
    virtual RequestStateResponse *dup() const {return new RequestStateResponse(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, RequestStateResponse& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, RequestStateResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/pastry/PastryMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet RequestRepairCall extends BaseCallMessage
 * {
 * }
 * </pre>
 */
class RequestRepairCall : public ::BaseCallMessage
{
  protected:

  private:
    void copy(const RequestRepairCall& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const RequestRepairCall&);

  public:
    RequestRepairCall(const char *name=NULL, int kind=0);
    RequestRepairCall(const RequestRepairCall& other);
    virtual ~RequestRepairCall();
    RequestRepairCall& operator=(const RequestRepairCall& other);
    virtual RequestRepairCall *dup() const {return new RequestRepairCall(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, RequestRepairCall& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, RequestRepairCall& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/pastry/PastryMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet RequestRepairResponse extends BaseResponseMessage
 * {
 * }
 * </pre>
 */
class RequestRepairResponse : public ::BaseResponseMessage
{
  protected:

  private:
    void copy(const RequestRepairResponse& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const RequestRepairResponse&);

  public:
    RequestRepairResponse(const char *name=NULL, int kind=0);
    RequestRepairResponse(const RequestRepairResponse& other);
    virtual ~RequestRepairResponse();
    RequestRepairResponse& operator=(const RequestRepairResponse& other);
    virtual RequestRepairResponse *dup() const {return new RequestRepairResponse(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, RequestRepairResponse& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, RequestRepairResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/pastry/PastryMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet RequestLeafSetCall extends BaseCallMessage
 * {
 * }
 * </pre>
 */
class RequestLeafSetCall : public ::BaseCallMessage
{
  protected:

  private:
    void copy(const RequestLeafSetCall& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const RequestLeafSetCall&);

  public:
    RequestLeafSetCall(const char *name=NULL, int kind=0);
    RequestLeafSetCall(const RequestLeafSetCall& other);
    virtual ~RequestLeafSetCall();
    RequestLeafSetCall& operator=(const RequestLeafSetCall& other);
    virtual RequestLeafSetCall *dup() const {return new RequestLeafSetCall(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, RequestLeafSetCall& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, RequestLeafSetCall& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/pastry/PastryMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet RequestLeafSetResponse extends BaseResponseMessage
 * {
 * }
 * </pre>
 */
class RequestLeafSetResponse : public ::BaseResponseMessage
{
  protected:

  private:
    void copy(const RequestLeafSetResponse& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const RequestLeafSetResponse&);

  public:
    RequestLeafSetResponse(const char *name=NULL, int kind=0);
    RequestLeafSetResponse(const RequestLeafSetResponse& other);
    virtual ~RequestLeafSetResponse();
    RequestLeafSetResponse& operator=(const RequestLeafSetResponse& other);
    virtual RequestLeafSetResponse *dup() const {return new RequestLeafSetResponse(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, RequestLeafSetResponse& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, RequestLeafSetResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/pastry/PastryMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet RequestRoutingRowCall extends BaseCallMessage
 * {
 *     int row;
 * }
 * </pre>
 */
class RequestRoutingRowCall : public ::BaseCallMessage
{
  protected:
    int row_var;

  private:
    void copy(const RequestRoutingRowCall& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const RequestRoutingRowCall&);

  public:
    RequestRoutingRowCall(const char *name=NULL, int kind=0);
    RequestRoutingRowCall(const RequestRoutingRowCall& other);
    virtual ~RequestRoutingRowCall();
    RequestRoutingRowCall& operator=(const RequestRoutingRowCall& other);
    virtual RequestRoutingRowCall *dup() const {return new RequestRoutingRowCall(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getRow() const;
    virtual void setRow(int row);
};

inline void doPacking(cCommBuffer *b, RequestRoutingRowCall& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, RequestRoutingRowCall& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/pastry/PastryMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet RequestRoutingRowResponse extends BaseResponseMessage
 * {
 * }
 * </pre>
 */
class RequestRoutingRowResponse : public ::BaseResponseMessage
{
  protected:

  private:
    void copy(const RequestRoutingRowResponse& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const RequestRoutingRowResponse&);

  public:
    RequestRoutingRowResponse(const char *name=NULL, int kind=0);
    RequestRoutingRowResponse(const RequestRoutingRowResponse& other);
    virtual ~RequestRoutingRowResponse();
    RequestRoutingRowResponse& operator=(const RequestRoutingRowResponse& other);
    virtual RequestRoutingRowResponse *dup() const {return new RequestRoutingRowResponse(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, RequestRoutingRowResponse& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, RequestRoutingRowResponse& obj) {obj.parsimUnpack(b);}


#endif // _PASTRYMESSAGE_M_H_
