//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
// 
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see http://www.gnu.org/licenses/.
// 

#include "HTopology.h"
#include "HMessage_m.h"
#include <rpcmacros.h>

Define_Module(HTopology);

/*
 * Hot Issues
 * 1) RandomChurn Generator sometimes kill the source node as well. NOT A GOOD CHOICE OF CHURN.
 *      Need to fix this issue.
 *      FIXED -> Use two churn generators one with NoChurn & other with Churn[any of the three churns]
 * 2) Registering children as bootstrapping nodes when my capacity()==0, fails. [RegisterAsBootstrapNode Call & Response]
 *      FIXED => But this will still not guarantee that tree is balanced.
 * 3) Cleaning up unnecessary code.
 * 4) FIXED No AddAsRescueChild request sent. [AddAsRescueChildCall & Response messages]
 * 5) Record the statistics into user friendly figures.
 *      FIXED => but not quite sure which type of graph should be plotted
 * 6) Change the string size [generate packets with bit rate as that of 360p video or similar]
 *      Generally 1segment comprises of 1s video
 *      Bit Rate for 360p = 1000kbps
 *      => 1s video will contain 1000*1000 bits = 10^6 bits
 *
 *      Sometimes the packet transfer delay crosses 1s [1.5-1.6s and the rate at which the packet is generated is 1s
 *      => some nodes will definitely be out of sync. Need some solutions here.]
 *      This was the case without any churn.
 *
 * 7) What If a node wants to see full video coverage? [None of the nodes are keeping track
 *      of the full video stream, except the source.]
 * 8) Can nodes cry out in case they don't get the deadline approaching packets?
 *      They do know which packet is generated by the source node. [Packet Generation rate or
 *      control sync message from the source node to all the nodes in the overlay]
 *
 * 9) - Fix the rescue mode operations
        - DONE choose a rescue parent
        - DONE maintaining our grand-children
        - DONE MeasurementTime parameter is added to the configuration file
        - DONE Previous bug detected
                - was due to randomChurn generator killing the source node
                    & then failing the assertion in preKillNode [mobilityTimer]
                     (oldTerminalCount-1 == terminalCount)
                => we cannot use the randomChurn generator for now [until
                    then bug is resolved]
        - DONE Don't accept the leave requests when they are from the leaf nodes
            [Remove them from your children set]
        - DONE Plug in the rescue mode call at handleSwitchToRescueMode
        - DONE Start two simulations
            - NO FAILURE [N=1000]
            - RANDOM CHURN [N=1000]
        - DONE schedule the deadline segments
        - DONE Think about the deadline segments & sequencing operation
        - DONE maintaining the segments in the order of their segmentIDs
        - DONE associate flag with node denoting its failure so that
                parent node don't send unnecessary b/w consuming messages

    TODO
        CHECKS
        - if we fix the bootstrapping after our children fails & we are not in bootstrapping
        - When parent fails & you're selected as replacement -> change grandparent & remove current parent from ancestors

        WHAT-IFs
        - what IF node replacement cann't be done?
        - what if replacement found but it failed afterwards [current bug]
        - what happens when a node fails while selecting replacement for its child?
        - what happens when rescue parent fails?
        - Node got a parent & then parent fails ==> Rescue set is empty ==> ??

        ****** SOLUTION WhatIfs *******
        TIMER_TO_REJOIN -> go into rescue mode[parent replacement] && gparent couldn't find a replacement && TIMER occurs => rejoin the network
        TIMER_CHECK_PARENT_HEALTH -> between certain time if no packet arrived from parent or rescue parent => rejoin the network

        GParent tries for replacement
            -> If replacementDone but replacementChild no more in children set => try just once again [if found then STATUS=Found]
            -> Otherwise pick the child with maximum capacity & add this as your child [put others as children of this node]
                & others see for themselves [STATUS=NotFound]

            -> STATUS=Found     => will tell you the accepted roles
            -> STATUS=NotFound  => some will be added in his tree but some node will have to search for new parent themselves
                [Rescue_link conversion OR ReJoinCall]

        HRejoinCall
            -> De-register yourself from the bootstrapping
            -> Keep your rescue link intact [otherwise your subtree won't be able to receive the packets]
            -> send this call to anyone of our ancestors & he'll put ourselves in the overlay
            -> OR send this call to anyone of bootstrapping node [this node shouldn't be there in bootstrapping]
        CONVERSION of rescue_link to parent_child_link [??] if the rescue parent has space for one child => add me
        But this cannot satisfy all these rescue children => we still need the rejoin mechanism
        ****** SOLUTION *******

        TREE-HEIGHT
        - Height measurement in the htopology
        - Tree height is also not optimal right now (concerned with bootstrapping & treeHeightOptimization)
            - height adjustment like in AVL tree [height balancing] or Red-Black trees?

        RANKING-FACTORS
        - Improve the ranking factors
            - Ranking (for the time being, assume to be a linear function of these parameters with some weights
                 which need to derived (experimentally or heuristically))

        UPDATED OVERLAY INFORMATION
        - How can we keep updated info. on rescue nodes [Need some kind of updation]
            - Parent changed
            - grand parent
            - Rescue node [we've had good relation with some node, previously it granted me access]
            - Children updated
            - Do we need random pointers in the tree?

        OVERHEAD-REMOVAL
        - when a node fails we send the switchToRescueMode & capacity
            calls[but only one should suffice, switchToRescueMode]

    ** PlayBack && Deadline scheduling **
        - DONE Declare PLAY_BACK_TIMER
        - DONE Initialize both of them when you receive the first video segment. This denotes the start index of the packets will begin streaming from
            & will consider the segments after this time only.
        - DONE Both playback & deadline sequencing is done at the same point of contact PlayBackTimer handler
        - DONE PLAY_BACK_TIMER is supposed to run at 1s boundary after you've received first 10 packets
            - It'll check if the required packet is available in buffer -> remove it
            - If it's not present => increment the #ofPacketsMissingDeadline
            - Reschedule it after 1s
        -DONE DEADLINE_SEGMENTS_SCHEDULE_TIMER will run every Xs to ensure that deadline segments are scheduled properly [better continuity index]
            - Will schedule Y #ofSegments approaching deadline [not the ones expected to be delivered by TREE] from different sources
                [if we ask a single node => we increase the load on one node && if that node fails we increase the chances of not delivering the
                deadline segments]
            - This should be running in RESCUE_MODE
           TODO - Source node will definitely deliver the packets to all these nodes
           TODO - Our source will keep all the packets starting from the time [But that may exceed the space available to us]
                - Lets remove packets which are definitely not required by anybody. [current-100th packet]
        - MESH-TREE SEGMENT POINTERS [do they overlap more often than not?]

     ** STATS **
 *      Startup Delay    : Delay between join request issuance & acceptance time
 *      Transfer Delay   : Delay between source & the end node [packet transfer operation]
 *      Control Overhead : Control traffic volume / Video traffic volume at each node
 *      Continuity Index : which is the number of segments that arrive before or on playback deadlines over the total number segments.
 *
 *      Simulation Parameters
 *      Coolstreaming
 *          120min total duration of streaming (typical length of the movie)
 *          500Kbps default streaming rate
 *          each segment contains one second of the stream
 *          each node contains 60s of streaming data
 *          playback starts after 10s of receiving the first segment
 *
 *      Anysee
 *          40s buffer [they say Coolstreaming requires 120s buffer]
 *
 *      Target:
 *          Low Startup delay <= 2s
 *          Low End-To-End delay
 *          Low Control Overhead??
 *
 *      Topology        Startup Delay       Transfer Delay  ControlOverhead     HeightOfTree    ContinuityIndex     HopCount[Transfer]
 *      Coolstreaming   60s                                 1.6%
 *      Anysee          20s                 200ms           1.0%                7[at max]
 *      Anysee2                                             0.9%
 *
 * - Which churn to follow?
 * - Fine Tuning the ranking parameters. I've to rank the rescue nodes wrt their capabilities to serve as rescue parent.
 *      Need to estimate the parameters [Linear regression]
 * - Optimizations:
 *      - Mapping Logical overlay to be physically close [as far as possible] while maintaining the tree height as low as possible
 *      - Different nodes will be able to support different #of children & rescue children. [WE STARTED OUT WITH BASIC FROM ALL NODES]
 *      - Low startup delay [nodes should pick up the stream without formally being the part of the overlay]
 *          - How can source node direct the new node to a set of nodes for asking the initial data??
 *              [Stable nodes can inform the bootstrap server so that they can serve these initial requests]
 *      - Remove unnecessary control overheads
 *
 * TODO Go through all the TODO's & resolve them if possible
 * TODO Sit someday & fix the message lengths [we've updated the message structures but the lengths remain the same]
 * TODO A node may not have the RescueParametersTimer scheduled [because it has no ancestor (we don't count
 *      the parent here) && hence no nodesOneUp]. But if sometime later it populates these parameters,
 *      then we'll have to schedule the timer [REMEMBER THIS THING AT RE-JOINING the NODE AT SOME OTHER PARENT]
 *
 * DONE
 * MAJOR CONCERN NOW
 *  -> SCHEDULING (in rescue mode over a set of nodes)
 *      Can  be taken care of, if only RANKING works fine
 * DONE => just schedule the segments in one-by-one in the increasing order of timeRemainingInDeadline
 *          in the ranked rescue set
 *  -> ACTIVENESS of Nodes (liveness of nodes & keep alive messages)
 * DONE Activeness (check in case of abrupt node failures)
 *      - DONE can be associated with a timeout to the videoSegmentCall (i.e. it doesn't reach the node)
 *      - ALTERNATE can be to continuously ping the nodes (but it's actually not useful as we already have a segment transfer call)
 *  -> RANKING of rescue nodes
 *      Let's enumerate all the parameters affecting the ranking (mainly answering the questions
 *          "Am I responsible for node's ability to serve as rescue node?")
 *
 *          -> RTT
 *          -> RescueCapacityLeft
 *          -> EffectiveBandwidth
 *          ->
 *
 *          Periodically gather information about these parameters from the potentially rescue nodes
 *
 *
 *
 * 1) DONE Generate Packets
 * 2) DONE Schedule them, transfer them to children & rescue nodes
 * 3) DONE Other nodes keep track of incoming packets & transfer them to their children
 *      DONE QUEUE
 * 4) Failure situations
 *      a) Keeping track of ACTIVE NODES in the rescue set
 *      b) RANKING algorithm or heuristics
 *      c) apply it
 *
 *   Node failure -> keep alive messages (any other alternative?)
 *      - Gracefully leaving the overlay [
 *   DONE   sends leave message to both children & parents]
 *   DONE   1) parent look for selecting an alternate for the leaving node
 *   DONE   2) children go in rescue mode till the decision is pending
 *          3) children in rescue mode, uses the mesh scheduling in the period [parentLeaveTime till aRescuerFound]
 *              How to keep track of the deadline approaching segments? so that they can be scheduled
 *
 *   OUR GRANDPARENT CAN ALWAYS BE OUR RESCUE NODE [WILL REMOVE THE OVERHEAD OF SELECTING THE RESCUE PARENT]
 *      - Abrupt failure of the node (
 *          DONE someone need to contact & confirm the failure
 *          DONE rest should be same as graceful leaving)
 *   RPC Timeout implementation
 *      DONE for node failure in case of videoSegment Transfer
 *
 * 5) Where's the mesh functionality?
 * 6) Collect required statistics
 *      a) Know what parameters are really required or what are the primary factors
 *      b) How to collect them?
 *      c) What kind of reality can be provided in the simulation? (Underlay Configuration is not so good
 *          it doesn't depict the reality. Go with some routers & stuff like that)
 *
 *      [ANSWER TO SIMULATION EVENT RELATED QUESTIONS]
 *          No. of nodes -> as many as possible
 *          Underlay configuration -> we are only worried about the overlay configuration
 *          Parameters -> checkout simulation events in papers
 *          Stream -> try to use the video stream (but only after this whole thing works with strings)
 *
 * 7) DONE Emergency video segment SCHEDULING.
 *      DONE Need to allocate identifiers to the segments
 *
 *  // Messages
 *  DONE GetChildrenCall, GetChildrenResponse -> used in getNodesOneUp
 *  DONE VideoSegmentCall -> stream video packet used in transferring the packet
 *  DONE LeaveOverlayCall -> send by leaving node to it's parent & children
 *  DONE LeaveOverlayResponse -> a node using LeaveOverlayCall should wait for this response[TODO MAY BE REMOVE IT]
 *      Directly give the call & wait (to check there's no timeout on the call & retry a few times & simply exit)
 *  DONE NewParentSelectedCall -> gives the description of the newly selected parent
 *  DONE ResponsibilityAsParentCall -> called node is selected as a parent for given set of children
 *  DONE ScheduleSegmentsCall, ScheduleSegmentsResponse -> asking to send some of the segments within [SegmentID, SegmmentID + count]
 *  DONE SwitchToRescueModeCall  -> ask these nodes to switch to rescue modes as their parent node failed
 *  DONE HGetParametersCall, HGetParametersResponse -> ask the ranking parameters to the node
 *      DONE Start a timer, so that we can keep fresh data in here
 *
 *  cache can be managed by buffer depicted in Anysee or STL-<map>
 *  DONE FIXED SIZE SEGMENTS
 *  DONE QUEUE or a bounded size buffer to store the packets received
 *
 *  TODO TIMERS
 *     DONE  1) Generation of packets
 *      2) Deadline of segments as per given packet generation rate
 *          [this will always be known or remain constant throughout the
 *          streaming life cycle]
 *      3) Calculating the parameters [ranking parameters]
 *     DONE Basic Functionality
 *          TODO
 *               - should be called once every (2*MAX-RTT or 4*MAX-RTT), otherwise there'll be lots of overhead
 *               - should be carefully set to a bit higher value than the once currently set
 *      4) Do we need to refresh data in our children parameters, with the help of timers?
 *
 *  DONE enhancements
 *  1) Bootstrapping need to change a bit
 *  2) Remove a node from bootstrap list once it's full & add it's children in the list
 *      => reduces the number of messages exchanged in joining of a new node
 *
 *  TODO statistics & simulation environment
 *    DONE startup time -> node's 1st request to join && the acceptance response
 *    DONE startup packet -> node joining time && 1st packet received
 *    DONE transfer delay -> packet issuance time && receiving simulation time TODO do we need to synchronize all the clocks
 *         packet loss [#of packets reaching after the deadline is over, or not at all reaching]
 *         How does a node know, when a segment is reaching the deadline?
 *             - May be use the SYNC signal sent by the root to all the nodes[so that they can figure out their status in the stream]
 *    DONE  total number of messages sent [divide into all the types we've defined in HMessage.msg file]
 *
 *    DONE parameter estimation shouldn't be done by the root node, anyways there are bugs associated with the current timer
 *      number of times parameterEstimation was done.
 *      ranks calculated [average rank available at a node, maximum, minimum & median]
 *      load at a node -> #ofChildren && #ofRescueChildren
 *    DONE #ofPacketsGenerated
 *    DONE[transfer delay handles this]  max reaching time of this packet to any node
 *      max height of the tree
 *
 *  1) What kind of network topology will work?
 *      One like our institute & other like a general Internet (with nodes behind proxy)
 *  2) What all statistics should be captured?
 *      -> startup time & response time
 *      -> fault tolerance (what happens in the rescue situations)
 *      -> any other characteristics
 *  3) Simulation should be for how many nodes? # of nodes
 *  4) What kind of stream we should be working on? (I'm currently using "strings",
 *          Should I replace it with videoStreams? ->
 *          because segment size may also have some effect on the simulation)
 * */

// To convert between IP addresses (which have bit 24 active), and keys (which don't), we'll need to set or remove this bit.
#define BIGBIT (1 << 24)

/* TODO Utilities
 * Will shift to some other place if required
 * */
template<typename T>
string tToString (T a) {
    std::stringstream ss;
    ss << a;

    return ss.str ();
}

bool compareRescueNodes (const RescueNode& L, const RescueNode& R) { return L.getRank() > R.getRank(); }


HTopology::~HTopology(){
    if (isSource) {
        cout << "Source node is going out of control" << endl;
    }

    // destroy self timer messages
    cancelAndDelete(packetGenTimer);
    cancelAndDelete(rescueParametersTimer);
    cancelAndDelete(playBackTimer);
}

void HTopology::initialize() {}

// Initialize variables accumulating the useful statistics
void HTopology::initializeStats () {
    // #ofMessages sent & recvd
    memset(numSentMessages, 0, sizeof numSentMessages);
    memset(numRecvMessages, 0, sizeof numRecvMessages);

    notReceivedPacket=notJoinedOverlay=true;
    parameterEstimationRounds=numPackets=0;
}

// Called when the module is being initialized
void HTopology::initializeOverlay(int stage) {
    // see BaseApp.cc
   if (stage != MIN_STAGE_OVERLAY) return;

   // get our key from our IP address
   nodeID = thisNode.getIp().get4().getInt() & ~BIGBIT;

   // set the operation mode
   modeOfOperation = GENERAL_MODE;

   // set the height to be -1
   height = -1;

   // TODO Do we really have to set the key[will this not be generated for us?]
   EV << thisNode << ": key just before assigning is " << endl;
   thisNode.setKey(OverlayKey(nodeID));     // set its key
   EV << thisNode << ": key after assigning is " << endl;

   // initialize the rest of variables
   bufferMapSize = par("bufferSize");
   maxChildren = par("maxChildren");
   maxRescueChildren = par("maxRescueChildren");
   bandwidth = par("bandwidth");
   noOfChildren = 0;
   joinRetry = par("joinRetry");
   joinDelay = par("joinDelay");
   packetGenRate = par("packetGenRate");
   videoBitRate = par("videoBitRate");

   // TODO this should be estimated in varying period of time [instead of estimating regularly]
   // Initially it should be done at a bit higher rate, then frequency should reduce gradually
   // Can you check what's the use of Jain's Parameter? [We studied in Networks course, if that can be applied here]
   rescueParameterEstimationRate = par("rescueParameterEstimationRate");
   isSource = false;

   initializedRescueRanks = false;

   // segment id to watch out for
   playBackSegmentID=0;

   segmentID = 0;

   EV << "max children is " << maxChildren << endl;

   // add some watches
   WATCH(predecessorNode);
   WATCH(successorNode);
   WATCH(thisNode);
   WATCH(joinRetry);
   WATCH(bootstrapNode);

   // self-messages
   packetGenTimer = NULL;
   rescueParametersTimer = NULL;
   playBackTimer = NULL;
   segmentsMissingDeadline=0;

   // Initialize the variables storing the statistics
   initializeStats();

   EV << thisNode << ": initialized." << std::endl;
}

// TODO you can try to delete this functionality[We really don't care what kind of nodeID is assigned to a node]
// We might think about it when we want to assign node IDs in such a way that it resembles their physical location
// Called to set our own overlay key (optional)
void HTopology::setOwnNodeID() {
    thisNode.setKey(OverlayKey(nodeID));
}

void HTopology::updateTooltip() {
    if (ev.isGUI()) {
        std::stringstream ttString;

        // show our predecessor and successor in tooltip
        ttString << predecessorNode << endl << thisNode << endl
                << successorNode << endl;

        getParentModule()->getParentModule()->getDisplayString().
        setTagArg("tt", 0, ttString.str().c_str());
        getParentModule()->getDisplayString().
        setTagArg("tt", 0, ttString.str().c_str());
        getDisplayString().setTagArg("tt", 0, ttString.str().c_str());

        // parent
        EV << "parent handle in updateToolTip: " << parent.getHandle() << endl;
        showOverlayNeighborArrow(parent.getHandle(), true,
                                         "m=m,50,0,50,0;ls=blue,1");
        // draw an arrow to our current successor
        showOverlayNeighborArrow(successorNode.getHandle(), true,
                                 "m=m,50,0,50,0;ls=red,1");
        // predecessor
        showOverlayNeighborArrow(predecessorNode.getHandle(), false,
                                 "m=m,50,100,50,100;ls=green,1");
    }
}

// change the STATE of this node to state
void HTopology::changeState (int STATE) {
    switch (STATE){
    case INIT:
        state = INIT;
        setOverlayReady(false);

        // initialize predecessor pointer
        parent = grandParent = rescueParent = HNode::unspecifiedNode;
        successorNode = predecessorNode = HNode::unspecifiedNode;

        updateTooltip();

        // debug message
        if (debugOutput) {
            EV << "[Chord::changeState() @ " << thisNode.getIp()
            << " (" << thisNode.getKey().toString(16) << ")]\n"
            << "    Entered INIT stage"
            << endl;
        }

        getParentModule()->getParentModule()->bubble("Enter INIT state.");
        break;

    case JOIN:
        state = JOIN;

        // debug message
        if (debugOutput) {
            EV << "[Chord::changeState() @ " << thisNode.getIp()
            << " (" << thisNode.getKey().toString(16) << ")]\n"
            << "    Entered JOIN stage"
            << endl;
        }

        // find a new bootstrap node and enroll to the bootstrap list
        bootstrapNode = bootstrapList->getBootstrapNode(0);

        EV << "bootstrap is " << bootstrapNode << endl ;
        // is this the first node?
        if (bootstrapNode.isUnspecified()) {
            // Initialize this Node as the source node
            EV << "Source node started the overlay." << endl;
            isSource = true;
            height = 0;     // Root node

            // Start the packet generation module
            packetGenTimer = new cMessage("Packet Generation Timer");
            scheduleTimer(packetGenTimer, packetGenRate);
        } else {
            joinRequestTime = simTime();            // FILL IN THE JOIN REQUEST TIME
            deathTime = joinRequestTime;            // Set deathTime equal to joinRequestTime so that we can compare & check if deathTime was modified later

            EV << thisNode << ": is going to join the overlay rooted at" << bootstrapNode << endl;
            HJoinCall *msg = new HJoinCall();
            msg->setBitLength(JOINCALL_L (msg));

            // send it to the destination
            sendRouteRpcCall (OVERLAY_COMP, bootstrapNode, msg);
        }

        updateTooltip();
        getParentModule()->getParentModule()->bubble("Enter JOIN state.");
        changeState(READY);
        break;

    case READY:
        state = READY;
        setOverlayReady(true);

        // Parameter estimation will not be done by the root node
        if (!isSource) {
            if (rescueParametersTimer == NULL)
                rescueParametersTimer = new cMessage ("Rescue_Parameters_Timer");
            scheduleTimer(rescueParametersTimer, rescueParameterEstimationRate);
        }

        if (!bootstrapNode.isUnspecified()) {
            EV <<"will remove this node from bootstrapping list" << endl;
            registeredInBootstrapping=false;
            bootstrapList->removeBootstrapNode(thisNode, overlayId);
        } else {
            registeredInBootstrapping=true;
        }

        // debug message
        if (debugOutput) {
            EV << "[Chord::changeState() @ " << thisNode.getIp()
            << " (" << thisNode.getKey().toString(16) << ")]\n"
            << "    Entered READY stage"
            << endl;
        }
        getParentModule()->getParentModule()->bubble("Enter READY state.");
        break;
    }
}

// Called when the module is ready to join the overlay
void HTopology::joinOverlay() {
    if (state == READY) {
        // If already joined the overlay, don't proceed
        // TODO need to debug the spurious joinOverlay() call
        return;
    }

    // tell the simulator that we're ready
    EV << "joinOverlay is called: " << endl ;
    changeState(INIT);
    changeState(JOIN);
}

// Scheduling a timer after rate time
void HTopology::scheduleTimer(cMessage* timer, double rate) {
    cancelEvent(timer);
    take (timer);
    scheduleAt(simTime()+rate, timer);
}

void HTopology::handleTimerEvent(cMessage* msg) {
    // Packet Generation Timer
    if(msg == packetGenTimer) {
        EV << "packet generation timer" << endl;
        handlePacketGenerationTimer(msg);
    }
    // Gather the rescue parameters
    else if(msg == rescueParametersTimer) {
        EV << "rescue parameters estimation timer" << endl;
        handleRescueParametersEstimationTimer (msg);
    }
    // Play the stream :P
    // But in case you are dead [deathTimer != joinRequestTimer] => no playback
    else if (msg == playBackTimer) {
        EV << thisNode << ": play back timer" << endl;
        //handlePlayBackTimer (msg);
        if (deathTime == joinRequestTime) {
            handlePlayBackTimer (msg);
        } else {
            cache.clear();
            scheduledCache.clear();
        }
    }
    // unknown self message
    else {
        EV << "Unknown Message is: " << msg->getClassName() << endl;
        //error("HTopology::handleTimerEvent(): received self message of "
        //      "unknown type!");
    }
}

void HTopology::handleRescueParametersEstimationTimer (cMessage *msg) {
    parameterEstimationRounds++;

    /* Reset the parameters response variables
     * TODO associate a number denoting the parameter estimation round
     *      [so that we don't have collision between two invocations]
     *  DONE add a timeout associated with this message, so that we can debug the current timers problem
     *       - BTW there was not such problem, instead the nodes didn't have the ancestors & nodesOneUp :)
     */
    parametersResponseReceived=parametersResponseRequired=0;
    for (KeyToRescueNodeMap::iterator it=ancestors.begin();
            it!=ancestors.end(); ++it, parametersResponseRequired++) {
        if ((*it).first == thisNode.getKey()) {
            EV << "We were sending self message via ancestors" << endl;
            continue;
        }
        HGetParametersCall *parametersCall = new HGetParametersCall();
        sendRouteRpcCall (OVERLAY_COMP, (*it).second.getHandle(), (*it).first, parametersCall);
    }

    for (KeyToRescueNodeMap::iterator it=nodesOneUp.begin();
            it!=nodesOneUp.end(); ++it, parametersResponseRequired++) {
        if ((*it).first == thisNode.getKey()) {
            EV << "We were sending self message via nodesOneUp" << endl;
            continue;
        }
        HGetParametersCall *parametersCall = new HGetParametersCall();
        sendRouteRpcCall (OVERLAY_COMP, (*it).second.getHandle(), (*it).first, parametersCall);
    }
    // TODO should we reschedule the call here? I DON'T THINK SO
}

// At source node:- packet is generated & sent to the children
void HTopology::handlePacketGenerationTimer(cMessage* msg) {
    scheduleTimer(packetGenTimer, packetGenRate);

    if (state != READY) {
        EV << "Packet generation message called w/o node being in READY state" << endl;
        return;
    }

    HVideoSegment segment = generateVideoSegment();
    EV << thisNode << ":Generated message is: " << segment.videoSegment;
    sendSegmentToChildren(segment);
}

void HTopology::handlePlayBackTimer (cMessage *msg) {
    // schedule at the same rate as the packet generation rate
    scheduleTimer(playBackTimer, packetGenRate);

    /* PLAYBACK FUNCTION */
    if (cache.find(playBackSegmentID) == cache.end()) {
        // This segment's deadline is over & we've not received the packet
        segmentsMissingDeadline++;

        // If the packet was in the scheduleCache & we got it from rescue links => we'll put it in the cache => it should not be in scheduleCache
        if (scheduledCache.find(playBackSegmentID) != scheduledCache.end()) {
            EV << thisNode << ": had scheduled packet " << playBackSegmentID << endl;
            scheduledCache.erase(playBackSegmentID);
        }
    } else {
        EV << thisNode << ": playing the segment with id -> " << cache[playBackSegmentID].segment.segmentID << endl;
        cache.erase(playBackSegmentID);
    }
    /* END PLAYBACK FUNCTION */

    /* DELETE SCHEDULED PACKETS WITH deadline < playBackSegmentID */
    for (map<int, HCacheElem>::iterator it=scheduledCache.begin(); it!=scheduledCache.end(); ) {
        if ((*it).first <= playBackSegmentID) {
            cout << thisNode << ": removing from scheduledCache" << (*it).first << endl;
            scheduledCache.erase (it++);
        } else {
            break;
        }
    }
    /* END DELETE SCHEDULED PACKETS WITH deadline < playBackSegmentID */

    /* DEADLINE SEGMENT SCHEDULING */
    if (scheduledCache.size() > 0) {
        vector<NodeHandle> rankedNodes = getRankedRescueNodeHandles();
        if (rankedNodes.size() > 0) {
            for (map<int, HCacheElem>::iterator it=scheduledCache.begin(); it!=scheduledCache.end(); ++it) {
                if ((*it).second.scheduled == false) {
#if _HDEBUG_
                    cout << thisNode << ": will schedule packet -> " << (*it).first << endl;
#endif
                    EV << thisNode << ": will schedule packet -> " << (*it).first << endl;

                    // Prepare the function call
                    HScheduleSegmentsCall *scheduleCall = new HScheduleSegmentsCall();
                    scheduleCall->setStartSegmentID((*it).first);
                    scheduleCall->setCount(1);
                    scheduleCall->setBitLength(HSCHEDULESEGMENTSCALL_L(scheduleCall));

                    // TODO send to the node in the order of priority
                    // 1) should the bandwidth be of concern too?
                    // 2) what about the timeRemaining to deadline?
                    int nodeNo = intuniform(0, rankedNodes.size()-1);
                    EV << thisNode << ": asked packet " << (*it).first << " from " << rankedNodes[nodeNo] << endl;
                    sendRouteRpcCall(OVERLAY_COMP, rankedNodes[nodeNo], scheduleCall);

                    // Set the packet to be scheduled
                    (*it).second.scheduled = true;
                } else {
                    EV << thisNode << ": already scheduled the packet " << (*it).first << endl;
                }
            }
        }
    }

    /* INCREMENT THE PLAYBACK COUNTER */
    playBackSegmentID++;

    // TODO
    /*
     * -- PLAYBACK FUNCTION
     * -> buffer search for startSegmentID
     * -> if not found -> increment the count of segments missing deadline
     * -> if found -> remove it from the buffer
     * -> startSegmentID++
     *
     * -- DEADLINE SEGMENT SCHEDULING
     * -> startSegmentID = next one to be scheduled [if this is not in the array, we cann't bring this in without missing the deadline]
     * -> highest id delivered by the tree => endSegmentID
     * --- Find out all the missing ids between the two & if not already scheduled, schedule them
     * --- If the difference between cachePointer & playBackPointer is not >= 5 --> we should consider scheduling 5 segments now [different
     *          nodes]
     *
     * TODO only after the basic model is working
     * -- For source node --> after it delivers 100th packet, remove a packet from the beginning each time a new packet is delivered
     *      Source should keep more packets than others
     * */
}

// NOTE you might want to check the amount of time this function takes to execute
HVideoSegment HTopology::generateVideoSegment () {
    assert (isSource == true);          // Only source should generate the packet
    EV << "Generating a new video segment" << endl;
    string msg(SEGMENT_SIZE-100,'M');

    // Generate a new message & deliver it to all the nodes
    string pkt = msg + "message-" + tToString(intuniform(0, INT_MAX));

    HVideoSegment segment;
    segment.segmentID = segmentID++;
    numPackets++;
    segment.issuanceTime = simTime();
    strncpy (segment.videoSegment, pkt.c_str(), SEGMENT_SIZE-1);
    return segment;
}

void HTopology::sendSegmentToChildren(HVideoSegment segment) {
    // Schedule the transfer to all the children & rescue nodes
    // TODO may be we can use the ideology asked in the proposed algorithm
    // Send to only half of the nodes & then ask them to deliver the packet to their neighbors
    EV << "Called sendSegmenttochildren" << endl;
    MapIterator it; int i=0;
    for (it = children.begin(); it != children.end(); ++it, ++i) {
        if ((*it).second.getIsDead() == true) {
#if _HDEBUG_
            cout << thisNode << ": child dead -> " << (*it).second.getHandle() << endl;
#endif
            EV << thisNode << ": child dead -> " << (*it).second.getHandle() << endl;
            continue;
        }

        EV << "Got it : " << i << endl;

        HVideoSegmentCall *videoCall = new HVideoSegmentCall();
        videoCall->setSegment(segment);
        videoCall->setBitLength(HVIDEOSEGMENTCALL_L(videoCall));

        sendRouteRpcCall (OVERLAY_COMP, (*it).second.getHandle(), (*it).first, videoCall);
    }
    i=0;
    for (it = rescueChildren.begin(); it != rescueChildren.end(); ++it, ++i) {
        EV << "Got it : j" << i << endl;
        HVideoSegmentCall *videoCall = new HVideoSegmentCall();
        videoCall->setSegment(segment);
        videoCall->setBitLength(HVIDEOSEGMENTCALL_L(videoCall));

        sendRouteRpcCall (OVERLAY_COMP, (*it).second.getHandle(), (*it).first, videoCall);
    }
}

// store the segment in your cache & distribute
void HTopology::handleVideoSegment (BaseCallMessage *msg) {
    numSentMessages[EVideoSegment]++;
    HVideoSegmentCall *mrpc = (HVideoSegmentCall *)msg;
    if (notReceivedPacket) {
        firstPacketRecvingTime = simTime();
        notReceivedPacket = false;

        // Set the play back timer
        playBackSegmentID = endSegmentID = mrpc->getSegment().segmentID;   // Will start the video with this segment
        playBackTimer = new cMessage("play_back_timer");
        scheduleTimer(playBackTimer, PLAYBACK_BUFFER_TIME);
    }

    EV << thisNode << ": received " << mrpc->getSegment().videoSegment
            << ": from -> " << mrpc->getSrcNode() << endl;

    // TODO STATS1 Transfer Delay
    // Record this transfer delay into the histogram
    // transferDelay = (simTime() - mrpc->getSegment().issuanceTime), how do we plot or use this info
    globalStatistics->recordHistogram("HTopology: Transfer Delay", (simTime() - mrpc->getSegment().issuanceTime).dbl());
    EV << "transfer delay for this packet: " << (simTime() - mrpc->getSegment().issuanceTime) << endl;

    addSegmentToCache(mrpc->getSegment());          // Store the segment in our cache
    sendSegmentToChildren(mrpc->getSegment());      // & then send it to our children

    // Send response back to the sending node
    HVideoSegmentResponse *rrpc =  new HVideoSegmentResponse();
    rrpc->setBitLength(HVIDEOSEGMENTRESPONSE_L(rrpc));
    sendRpcResponse(mrpc, rrpc);
}

void HTopology::printProfile () {
#if _PROFILE_DEBUG_
    cout << thisNode << ": profile " << endl;
    cout << "\t SegmentsMissing deadline = " << segmentsMissingDeadline << endl;
    cout << "\t TimeInOverlay = " << (simTime() - joinRequestTime).dbl() << endl;
    cout << "\t deathTime - joinRequestTime = " << (deathTime - joinRequestTime).dbl() << endl;
    cout << "\t Parent = " << parent.getHandle() << endl;
    cout << "\t #Of Children = " << children.size() << endl;
    cout << "\t Ancestors set size = " << ancestors.size() << endl;
    cout << "\t NodesOneUp set size = " << nodesOneUp.size() << endl;
    cout << "\t Height = " << height << endl;
#endif
}

// Save the statistics recorded in the simulation
void HTopology::saveStatistics () {
    // Stats from non-source nodes only makes sense, right?
    if (!isSource) {
        // TODO STAT2 Startup Time for the node
        if (notJoinedOverlay == false) {
            globalStatistics->recordHistogram("HTopology: StartupTime=JoinAccepted - JoinRequested", (joinAcceptanceTime-joinRequestTime).dbl());
        }

        if (notReceivedPacket == false) {
            // TODO STAT3 Streaming Startup time for the node
            globalStatistics->recordHistogram("HTopology: StreamingStartupTime=FirstPacketRecved - JoinRequested", (firstPacketRecvingTime-joinRequestTime).dbl());

            // TODO STAT4 Segments missing their deadline [For Continuity Index]
            globalStatistics->recordHistogram("HTopology: SegmentsMissingDeadline", segmentsMissingDeadline);
        }

        // TODO STAT5 Number of packets generated at the source node
        globalStatistics->addStdDev("PacketsGeneratedAtSource", numPackets);

        // TODO STAT6 Number of parameter estimation rounds
        globalStatistics->addStdDev("ParametersEstimationRounds", parameterEstimationRounds);

        // TODO # Of VideoSegment Sent & Received
        globalStatistics->recordHistogram("VideoSegmentSent", numSentMessages[EVideoSegment]);
        globalStatistics->recordHistogram("VideoSegmentReceived", numRecvMessages[EVideoSegment]);
    } else {
        // TODO STAT7 Total #of packets generated the source node
        globalStatistics->recordHistogram("Packets Generated at source", segmentID+1);
    }

    // TODO STAT8 Height of a tree node
    if (height > 0) {
        globalStatistics->recordHistogram("Height of a tree node", height);
    }

    printProfile();
}

// Called when the module is about to be destroyed
void HTopology::finishOverlay() {
    if (!parent.isUnspecified()) {
        leaveRequestTime = simTime();
        HLeaveOverlayCall *leaveCall = new HLeaveOverlayCall();
        leaveCall->setBitLength(HLEAVEOVERLAYCALL_L(leaveCall));

        // Notifications
        // to parent
        sendRouteRpcCall(OVERLAY_COMP, parent.getHandle(), leaveCall);

        // to children
        for (MapIterator it=children.begin(); it!=children.end(); ++it) {
            HLeaveOverlayCall *leaveCall = new HLeaveOverlayCall();
            leaveCall->setBitLength(HLEAVEOVERLAYCALL_L(leaveCall));
            sendRouteRpcCall(OVERLAY_COMP, (*it).second.getHandle(), leaveCall);
        }

        // rescue parent
        removeRescueLink();

        // NOTE ideally you should wait till you receive response from your parent
        // But then its forcing the node to stay put & no guarantee till what time I should wait
        // Just directly leave, NO WAITING :) [Let's be fair]
    }

    bootstrapList->removeBootstrapNode(thisNode);

    // remove this node from the overlay
    setOverlayReady(false);

    // save the statistics (see BaseApp)
    saveStatistics();
    EV << thisNode << ": Leaving the overlay." << std::endl;
}

// Return whether we know if the given node is responsible for the key
bool HTopology::isSiblingFor(const NodeHandle& node,
                             const OverlayKey& key,
                             int numSiblings,
                             bool* err) {
    // is it our node and our key?
    if (node == thisNode && key == thisNode.getKey()) {
        return true;
    }
    // we don't know otherwise
    return false;
}

// Return the next step for the routing of the given message
NodeVector *HTopology::findNode(const OverlayKey& key,
                                int numRedundantNodes,
                                int numSiblings,
                                BaseOverlayMessage* msg) {
    NodeVector* nextHops;

   nextHops = new NodeVector(1);

   // are we responsible? next step is this node
   if (key == thisNode.getKey()) {
       nextHops->add(thisNode);
   }
   // is the key behind us? next step is the previous node
   else if (key < thisNode.getKey()) {
       //nextHops->add(prevNode);
       EV << "prevNode" << std::endl;
   }
   // otherwise, the next step is the next node
   else {
    //   nextHops->add(nextNode);
       EV << "nextNode" << std::endl;
   }
   return nextHops;
}

// Return the max amount of siblings that can be queried about
int HTopology::getMaxNumSiblings() { return 1; }

// Return the max amount of redundant that can be queried about
int HTopology::getMaxNumRedundantNodes() { return 1; }

NodeHandle HTopology::getNodeHandle(MapIterator iter, MapIterator end) {
    if (iter == end) return NodeHandle::UNSPECIFIED_NODE;

    HNode node = (*iter).second;
    return node.getHandle();
}


// NodesOneUp
// respond to the getChildren call
void HTopology::sendChildren (BaseCallMessage *msg) {
    numSentMessages[EGetChildren]++;

    HGetChildrenCall *mrpc = (HGetChildrenCall *) msg;
    HGetChildrenResponse *rrpc =  new HGetChildrenResponse();
    rrpc->setForGrandChildrenAccumulation(mrpc->getForGrandChildrenAccumulation());
    rrpc->setChildrenArraySize(children.size());
    rrpc->setBitLength(HGETCHILDRENRESPONSE_L(rrpc));
    int k=0;
    for (MapIterator it=children.begin(); it!=children.end(); ++it, k++) {
        rrpc->setChildren(k, (*it).second.getHandle());
    }

    sendRpcResponse(mrpc, rrpc);
}

// use the ancestors array to figure out these nodes
void HTopology::initializeNodesOneUp () {
    if (grandParent.isUnspecified()) return;

    // Need to call the last ancestor & get it's children
    // exclude our parent & go ahead with with other nodes
    HGetChildrenCall *msg = new HGetChildrenCall();
    msg->setForGrandChildrenAccumulation (false);
    msg->setBitLength(HGETCHILDRENCALL_L (msg));

    // send it to the destination
    sendRouteRpcCall (OVERLAY_COMP, grandParent.getHandle(), msg);
}

// fills up the nodes one up field in the overlay
void HTopology::setNodesOneUp (BaseResponseMessage* msg) {
    numRecvMessages[EGetChildren]++;
    HGetChildrenResponse* mrpc = (HGetChildrenResponse*)msg;          // get Response message

    // just remove our parent from this list & add them to the nodesOneUp
    int noOfChildren = mrpc->getChildrenArraySize();
    for (int i=0; i<noOfChildren; ++i) {
        NodeHandle node = mrpc->getChildren(i);

        // ignore our parent
        if (node == parent.getHandle()) {
            EV << "Got our parent in the list: atleast proves this list to be legitimate :P";
            continue;
        }

        RescueNode hnode;
        hnode.setHandle(node);
        nodesOneUp[node.getKey()] = hnode;
    }
}

void HTopology::prepareAndSendJoinAcceptance(BaseCallMessage* msg,
        HJoinResponse* rrpc) {
    EV << thisNode << ": will be adding node: " << msg->getSrcNode() << ": as child" << endl;
    cout << thisNode << ": will be adding node: " << msg->getSrcNode() << ": as child" << endl;
    noOfChildren++;

    // we assume that node is a new comer => everything empty
    HNode child;
    child.setHandle(msg->getSrcNode());
    // there shouldn't already be any node with this key
    assert(children.find(child.getHandle().getKey()) == children.end());
    children[child.getHandle().getKey()] = child;
    MapIterator it = children.find(child.getHandle().getKey());

    // Do we need to tell our parent, regarding we adopting a new child?
    if (!parent.isUnspecified()) {
        HChildAddedCall *childAdded = new HChildAddedCall();
        childAdded->setChild(msg->getSrcNode());
        childAdded->setBitLength(HCHILDADDEDCALL_L(childAdded));

        sendRouteRpcCall(OVERLAY_COMP, parent.getHandle(), childAdded);
    }

    // What is required by a new node?
    // Children & rescueChildren will be empty.
    // nodesOneUp?? (Let the child figure out this parameter)
    // ancestors = thisNode->ancestors + thisNode
    // set the ancestors array
    if (!parent.isUnspecified())
    rrpc->setAncestorsArraySize(ancestors.size() + 1);// parent of this node will be added as well
    else
    rrpc->setAncestorsArraySize(ancestors.size());// this node has no parent (it's the source node)

    int k = 0;
    for (RescueMapIterator it = ancestors.begin();it != ancestors.end();++it, ++k) {
        RescueNode node = (*it).second;
        rrpc->setAncestors(k, node.getHandle());
    }

    if (!parent.isUnspecified())
    rrpc->setAncestors(k, parent.getHandle());

    rrpc->setSuccessorNode(getNodeHandle(it++, children.end()));
    rrpc->setPredecessorNode(getNodeHandle(it--, children.end()));
    rrpc->setJoined(true);
    rrpc->setHeightParent(this->height);

    // Remove yourself from the bootstrapping in case your capacity==0
    if (capacity()==0) {
        // remove yourself from the bootstrapping thing
        // && care to check if your children are there in the bootstrapping list
        for (MapIterator it=children.begin(); it !=children.end(); ++it) {
            if ((*it).second.getIsDead() == true) {
#if _HDEBUG_
    cout << thisNode << ": child dead in bootstrapping registration -> " << (*it).second.getHandle() << endl;
#endif
                EV << thisNode << ": child dead in bootstrapping registration -> " << (*it).second.getHandle() << endl;
                continue;
            }

            // Insert our children into the bootstrap list
            HRegisterInBootstrappingCall *registerCall = new HRegisterInBootstrappingCall();
            registerCall->setBitLength(HREGISTERINBOOTSTRAPPINGCALL_L(registerCall));

            sendRouteRpcCall (OVERLAY_COMP, (*it).second.getHandle(), (*it).first, registerCall);
            // bootstrapList->registerBootstrapNode((*it).second.getHandle(), overlayId);
        }
        // bootstrapList->removeBootstrapNode(thisNode, overlayId);
    }
}

void HTopology::prepareAlternativeToJoin(HJoinResponse* rrpc) {
    cout << thisNode << ": preparing alternative : " << endl;
    size_t size = children.size();
    int redirection = intuniform(0, size - 1);
    MapIterator iter = children.begin();
    for (int i = 0; i < redirection; ++i, iter++)
        ;

    HNode redirectionChild = (*iter).second;
    rrpc->setSuccessorNode(redirectionChild.getHandle());
    rrpc->setJoined(false);
}

void HTopology::handleJoinCall (BaseCallMessage *msg) {
    numSentMessages[EJoin]++;

    HJoinCall *mrpc = (HJoinCall*) msg;
    HJoinResponse *rrpc = new HJoinResponse ();
    EV << thisNode << ": received Join call from " <<  msg->getSrcNode() << endl;

    // TODO capacity()>0 && modeOfOperation==GENERAL_MODE
    if (capacity()>0) {
        prepareAndSendJoinAcceptance(msg, rrpc);
    } else {
        // TODO may be check if anyone of them can support the children
        // Try to keep the height of the tree as low as possible
        EV << "redirecting to one of my children: " << endl;
        prepareAlternativeToJoin(rrpc);
    }

    rrpc->setBitLength(HJOINRESPONSE_L(rrpc));
    sendRpcResponse(mrpc, rrpc);
}

void HTopology::setOverlayLinksFromJoinResponse(HJoinResponse* mrpc) {
    ancestors.clear();
    nodesOneUp.clear();

    parent.setHandle(mrpc->getSrcNode());
    this->height = mrpc->getHeightParent() + 1;
    if (mrpc->getAncestorsArraySize() > 0)
        grandParent.setHandle(
                mrpc->getAncestors(mrpc->getAncestorsArraySize() - 1));

    successorNode.setHandle(mrpc->getSuccessorNode());
    predecessorNode.setHandle(mrpc->getPredecessorNode());
    for (size_t i = 0; i < mrpc->getAncestorsArraySize(); ++i) {
        NodeHandle node = mrpc->getAncestors(i);
        RescueNode hnode;
        hnode.setHandle(node);
        ancestors[node.getKey()] = hnode;
    }

    modeOfOperation = GENERAL_MODE;         // Change the mode to general
    initializeNodesOneUp();                 // initialize the nodes one up
}

// TODO add Timeout for the JoinCall, because it might happen that there is
//      no response from the bootstrap node we requested to join, in which case
//      we should move on to some other node
void HTopology::handleJoinResponse (BaseResponseMessage *msg) {
    numRecvMessages[EJoin]++;

    HJoinResponse* mrpc = (HJoinResponse*)msg;          // get Response message
    if (mrpc->getJoined() == true) {
        notJoinedOverlay=false;
        joinAcceptanceTime = simTime();                 // FILL IN THE JOIN ACCEPTANCE TIME

        EV << "We got a response from " << mrpc->getSrcNode() << endl;
        setOverlayLinksFromJoinResponse(mrpc);
        EV << "joined overlay :" ;
        updateTooltip();
    } else {
        EV << thisNode << ": is going to join the overlay rooted at" << mrpc->getSuccessorNode() << endl;
        HJoinCall *mcall = new HJoinCall();
        mcall->setBitLength(JOINCALL_L (mcall));

        // go on & call the given node
        // assert (mrpc->getSuccessorNode().isUnspecified() == false);
        if (mrpc->getSuccessorNode().isUnspecified()) {
            EV << "Incorrect response->" ;
            EV << "NEED HELP" << endl;
            cout << "NEED HELP :msg class" << msg->getClassName() << endl;
            if (dynamic_cast<HReJoinResponse*>(msg))  {
                cout << " it's rejoin response class" << endl;
            }
            if (dynamic_cast<HConvertRescueLinkResponse*>(msg)) {
                cout << " it's convert rescue link response class" << endl;
            }
        } else {
            // go ahead & add yourself to the child
            EV << "joining at " << mrpc->getSuccessorNode() <<  endl;
            sendRouteRpcCall (OVERLAY_COMP, mrpc->getSuccessorNode(), mcall);
        }
    }
}

void HTopology::selectReplacement (const NodeHandle& node, HLeaveOverlayCall *mrpc) {
    /*
     * 1) Find replacement for the source of the message
     * 2) Notify the replacement to all the children after the decision is taken
     *
     * TODO who should take this decision? parent of the node or the children?
     * children can also do it via LEADER SELECTION, right?
     * */
    // Let the parent handle this situation, for now

    // NOTE mrpc is NULL in handleRpcTimeout event
    EV << "Called the select replacement event, and we're back with the functionality."
            << "Node is : " << node << endl;

    assert (children.find(node.getKey()) != children.end());        // MY CHILD
    assert (children[node.getKey()].getChildren().size() > 0);      // NOT LEAF NODE

#if _HDEBUG_
    cout << thisNode << ": selecting replacement for " << node << endl;
#endif

    HNodeReplacement nreplacement;
    nreplacement.node = node;
    nreplacement.mrpc = mrpc;           // NOTE this can be NULL
    EV << "Filing a leave request for key: " << node.getKey() << endl;
    leaveRequests[node.getKey()] = nreplacement;

    getParametersForSelectionAlgo(node.getKey());

    // TODO do we need to setup any other parameter? Check for the #of times this function is called
}

void HTopology::handleDeathAcknowledgementCall (BaseCallMessage *msg) {
    HDeathAcknowledgementCall *deathAck = (HDeathAcknowledgementCall *)msg;
    if (parent.isUnspecified() == false) {
        if( (deathTime == joinRequestTime) &&
                (parent.getHandle() == deathAck->getSrcNode()) ){
#if _CURDEBUG_
            cout << thisNode << ": parent has acknowledged my death." << endl;
#endif
            deathTime = simTime();
        }
    }

    delete deathAck;
}


void HTopology::handleLeaveCall (BaseCallMessage *msg) {
    // TODO can there be multiple leave calls from the same node?
    numSentMessages[ELeaveOverlay]++;
    /*
     * If you are the parent of the caller -> find a replacement of the node
     * Else
     *  you go in rescue mode
     * */

    HLeaveOverlayCall *mrpc = (HLeaveOverlayCall *)msg;

    if (parent.getHandle() == mrpc->getSrcNode()) {
        EV << " My parent is leaving the overlay " << endl;
#if _HDEBUG_
        cout << " My parent is leaving the overlay " << endl;
#endif

        /*
         * 1) Go in rescue mode
         * 2) TODO Schedule your deadlines as per the ranked rescue set
         *      Until your grandparent tells you the replacement
         * 3) TODO Choose a rescue parent.
         * */
        modeOfOperation = RESCUE_MODE;
        // TODO can we do something?
    }
    else {
        assert(children.find(mrpc->getSrcNode().getKey()) != children.end());

        if (parent.isUnspecified() == false) {
#if _HDEBUG_
            cout << thisNode << ": sending child removed call to our parent " << children[mrpc->getSrcNode().getKey()].getHandle() << endl;
#endif

            HChildRemovedCall *childRemoveCall = new HChildRemovedCall();
            childRemoveCall->setChild(mrpc->getSrcNode());
            childRemoveCall->setBitLength(HCHILDREMOVEDCALL_L(childRemoveCall));
            sendRouteRpcCall(OVERLAY_COMP, parent.getHandle(), childRemoveCall);
        }

        // TODO solve this issue
        /*// Send deadthAck to the child
        HDeathAcknowledgementCall *deathAckCall = new HDeathAcknowledgementCall();
        deathAckCall->setBitLength(HDEATHACKNOWLEDGEMENTCALL_L(deathAckCall));
        sendRouteRpcCall(OVERLAY_COMP, mrpc->getSrcNode(), deathAckCall);*/

#if _CURDEBUG_
        cout << thisNode << ": ack'd death of child at leaveCall -> " << mrpc->getSrcNode() << endl;
#endif

        // Only children who have children should be replaced => NO LEAF NODES
        if (children[mrpc->getSrcNode().getKey()].getChildren().size() > 0) {
#if _HDEBUG_
            cout << thisNode << ": setting dead ->" << children[mrpc->getSrcNode().getKey()].getHandle() << endl;
#endif
            children[mrpc->getSrcNode().getKey()].setIsDead(true);      // This node is dead
            selectReplacement(mrpc->getSrcNode(), mrpc);                // Select replacement for the node
        } else {
            EV << thisNode << ": A leaf just left me" << mrpc->getSrcNode() << endl;

            // TODO may be we can adopt the our grand children
            // Remove this leaf node from the children set
            children.erase(mrpc->getSrcNode().getKey());
        }
    }
}

void HTopology::handleRemoveRescueLinkCall (BaseCallMessage *msg) {
    HRemoveRescueLinkCall *mrpc = (HRemoveRescueLinkCall *)msg;
    if (mrpc->getSrcNode().getKey().isUnspecified()) {
        cout << thisNode << ": remove rescue link call, unspecified key " << mrpc->getSrcNode() << endl;
    }

    if (rescueChildren.find(mrpc->getSrcNode().getKey()) == rescueChildren.end()) {
        EV << thisNode <<  ": fake remove rescue link call from " << mrpc->getSrcNode() << endl;
    } else {
        // Remove this rescue child from our list
        // TODO we can give updates to our rescueLinks about this change [JUST MAKING COMPLICATED :P]
#if _HDEBUG_
        cout << thisNode << ": removing rescue link from rescue child" << mrpc->getSrcNode() << endl;
#endif
        rescueChildren.erase(mrpc->getSrcNode().getKey());
    }
    delete msg;
}

// Your parent's replacement has been found out.
void HTopology::handleNewParentSelectedCall (BaseCallMessage *msg) {
    numSentMessages[ENewParentSelected]++;

    HNewParentSelectedCall *mrpc = (HNewParentSelectedCall*)msg;

    // Ideally this node should also be acting in rescue mode
    assert (modeOfOperation == RESCUE_MODE);
    if (mrpc->getParent().isUnspecified() == false) {
        // Got a replacement for the node
        parent.setHandle(mrpc->getParent());
        modeOfOperation = GENERAL_MODE;

        // remove your rescue link from the rescue parent
        removeRescueLink();
    } else {
        // Lets choose our alternate parent
        getAlternateParent();
    }

    delete msg;
    // TODO adjust our successor & predecessor ??
}

// You are now selected as the replacement of your parent.
void HTopology::handleResponsibilityAsParentCall (BaseCallMessage *msg) {
    numSentMessages[EResponsibilityAsParent]++;

    HResponsibilityAsParentCall *mrpc = (HResponsibilityAsParentCall *)msg;

    // Ideally this node should also be acting in rescue mode
    // TODO may change when we change repair strategy
#if _HDEBUG_
    cout << thisNode << ": being selected as replacement for my parent " << parent.getHandle() << endl;
    if (modeOfOperation == GENERAL_MODE) {
        cout << " I'm in general mode of operation." << endl;
    } else {
        cout << " I'm operating in rescue mode" << endl;
    }
#endif

    assert (modeOfOperation == RESCUE_MODE);
    assert (!(mrpc->getParent().isUnspecified()));

    parent.setHandle(mrpc->getParent());
    height--;       // Reduce the height
    modeOfOperation = GENERAL_MODE;

    // remove your rescue link from the rescue parent
    removeRescueLink();

    // add the children vector into our children set
    for (size_t i=0; i<mrpc->getChildrenArraySize(); ++i, ++noOfChildren) {
        HNode node;
        node.setHandle(mrpc->getChildren(i));

        // ask them about their children
        children[node.getHandle().getKey()] = node;
        HGetChildrenCall *getChildrenCall = new HGetChildrenCall();
        getChildrenCall->setForGrandChildrenAccumulation(true);
        getChildrenCall->setBitLength(HGETCHILDRENCALL_L(getChildrenCall));
        sendRouteRpcCall(OVERLAY_COMP, mrpc->getChildren(i), getChildrenCall);
    }

    delete msg;
    // do we update our parent about our new children? I Think NO. He already know about them
}

void HTopology::handleScheduleSegmentsCall (BaseCallMessage *msg) {
    numSentMessages[EScheduleSegments]++;

    HScheduleSegmentsCall *scheduleCall = (HScheduleSegmentsCall *)msg;
    int startSegmentID = scheduleCall->getStartSegmentID();
    int count = scheduleCall->getCount();

    vector<HVideoSegment> foundSegments;
    // TODO you can maintain the cache in the form of a heap [stl<map> will be a good thing as it stores in increasing order of keys]
    // TODO optimize this thing
    for (int cnt=0; cnt<count; ++cnt) {
        if (cache.find(startSegmentID+cnt) != cache.end()) {
            foundSegments.push_back(cache[startSegmentID+cnt].segment);
        }
    }

    // NOTE If we've no packets to be sent for this call -> simply skip sending the response
    // Unnecessary overhead of sending a blank response
    if (foundSegments.size() > 0) {
        // prepare the response
        HScheduleSegmentsResponse *scheduleResponse = new HScheduleSegmentsResponse();
        scheduleResponse->setSegmentsArraySize(foundSegments.size());
        scheduleResponse->setBitLength(HSCHEDULESEGMENTSRESPONSE_L(scheduleResponse));
        for (size_t k=0; k<foundSegments.size(); ++k)
            scheduleResponse->setSegments(k, foundSegments[k]);
        sendRpcResponse(scheduleCall, scheduleResponse);
    } else {
        delete msg;
    }
}

void HTopology::addSegmentToCache (HVideoSegment& videoSegment) {
    // DONE check the buffer functionalities
    // DONE need to maintain the segments in the order of their deadlines [precisely the order of their segmentIDs]
    if ( (isSource == false) && (deathTime != joinRequestTime)) {
#if _HDEBUG_
        cout << thisNode << ": node is dead & someone asked to put segment into the cache" << endl;
#endif
        EV << thisNode << ": node is dead & someone asked to put segment into the cache" << endl;
        return;
    }

    HCacheElem cacheElem(videoSegment);

    // Don't accept packets missing the deadline
    if (videoSegment.segmentID < playBackSegmentID) {
        cout << thisNode << ": recvd segment (deadline gone) " << videoSegment.segmentID << endl;
        return;
    }

    if (scheduledCache.find(videoSegment.segmentID) != scheduledCache.end()) {
        EV << thisNode << ": a segment in schedule cache is received " << videoSegment.segmentID << endl;
        scheduledCache.erase(videoSegment.segmentID);   // Remove from the scheduledCache
    } else {
        int newLastSegmentID = videoSegment.segmentID;
        if (newLastSegmentID > endSegmentID) {
            EV << thisNode << ": will put segments between " << endSegmentID+1 << " --> " << newLastSegmentID
                    << " in scheduleCache " << endl;
            HCacheElem elem;
            for (int i=endSegmentID+1; i!=newLastSegmentID; ++i) {
                scheduledCache[i] = elem;
            }

            // Change the last segment's id to this one
            endSegmentID = newLastSegmentID;
        }
    }

    cache[videoSegment.segmentID] = cacheElem;      // Add to the cache
    // TODO you can use this function as trigger for the deadline segment scheduling
}

void HTopology::handleScheduleSegmentsResponse (BaseResponseMessage *msg) {
    numRecvMessages[EScheduleSegments]++;

    HScheduleSegmentsResponse *scheduleResponse = (HScheduleSegmentsResponse *)msg;
    int N=scheduleResponse->getSegmentsArraySize();
    if (N>0) {
        if (notReceivedPacket) {
#if _CURDEBUG_
            cout << thisNode << ": receiving the first packet via schedule call packetNo -> " << scheduleResponse->getSegments(0).segmentID << endl;
#endif
            firstPacketRecvingTime = simTime();
            notReceivedPacket = false;

            // Set the play back timer
            playBackSegmentID = endSegmentID = scheduleResponse->getSegments(0).segmentID;   // Will start the video with this segment
            playBackTimer = new cMessage("play_back_timer");
            scheduleTimer(playBackTimer, PLAYBACK_BUFFER_TIME);
        }
    }

    for (int i=0; i<N; ++i) {
        addSegmentToCache(scheduleResponse->getSegments(i));
    }
}

void HTopology::handleSwitchToRescueModeCall (BaseCallMessage *msg) {
    numSentMessages[ESwitchToRescueMode]++;

    HSwitchToRescueModeCall *switchCall = (HSwitchToRescueModeCall *)msg;
    if (switchCall->getSrcNode() != grandParent.getHandle()) {
        EV << "There's some problem with switchToRescueModeCall" << endl;
        return;
    }

    if (modeOfOperation == RESCUE_MODE) {
        // cout <<thisNode <<": we are already in rescue mode" << endl;
        EV << thisNode <<": we are already in rescue mode" << endl;
        delete msg;
        return;
    }

    // TODO we can send our capacity this way, in response to this message
    modeOfOperation = RESCUE_MODE;
    selectRescueParent ();
    delete msg;
}

void HTopology::handleRegisterInBootstrappingCall (BaseCallMessage *msg) {
    HRegisterInBootstrappingCall *mrpc = (HRegisterInBootstrappingCall *)msg;
    if (parent.getHandle().isUnspecified()
            || (mrpc->getSrcNode() != parent.getHandle())) {
        EV << "Received a register in bootstrapping call, but its fake." << endl;
        delete msg;
    } else {
        EV << thisNode << ": Registering in bootstrapping mechanism." << endl;
        bootstrapList->registerBootstrapNode(thisNode, overlayId);

        HRegisterInBootstrappingResponse *rrpc = new HRegisterInBootstrappingResponse();
        rrpc->setBitLength(HREGISTERINBOOTSTRAPPINGRESPONSE_L(rrpc));
        sendRpcResponse(mrpc, rrpc);
    }
}

void HTopology::handleRegisterInBootstrappingResponse (BaseResponseMessage *msg) {
    HRegisterInBootstrappingResponse *mrpc = (HRegisterInBootstrappingResponse *)msg;
    NodeHandle node = mrpc->getSrcNode();
    // TODO do you care about the capacity()==0 here??
    if (children.find(node.getKey()) == children.end()) {
        EV << "Fake register in bootstrap response" << endl;
    } else {
        if (registeredInBootstrapping) {
            registeredInBootstrapping=false;
            bootstrapList->removeBootstrapNode(thisNode, overlayId);
        } else {
            EV << "register bootstrap response: i'm not at all registered in the list" << endl;
        }
    }

    // TODO might produce some bugs
    // delete msg;
}

void HTopology::handleCapacityCall (BaseCallMessage *msg) {
    numSentMessages[ECapacity]++;

    HCapacityCall *mrpc = (HCapacityCall*)msg;          // get Call message
    HCapacityResponse *rrpc = new HCapacityResponse();  // create response
    rrpc->setParentNode(parent.getHandle());
    rrpc->setRespondingNode(thisNode);

    // TODO the capacity can be decided dynamically, but for now lets use the static version
    rrpc->setCapacity(capacity());      // set the capacity left at this node
    rrpc->setBitLength(HCAPACITYRESPONSE_L(rrpc));

    // now send the response. sendRpcResponse can automatically tell where to send it to.
    // note that sendRpcResponse will delete mrpc (aka msg)!
    sendRpcResponse(mrpc, rrpc);
}

void HTopology::handleCapacityResponse (BaseResponseMessage *msg) {
    numRecvMessages[ECapacity]++;

    HCapacityResponse *mrpc = (HCapacityResponse*)msg;          // get Response message
    if (mrpc->getParentNode().isUnspecified()) {
        cout << thisNode << "Got a capacity response but not valid parent handle"
                << "from " << mrpc->getSrcNode() << endl;
        return;
    }

    if (mrpc->getParentNode().getKey().isUnspecified()) {
        cout << thisNode << "Got a capacity response but not valid key for parent node"
                << "from " << mrpc->getSrcNode() << endl;
        return;
    }

    OverlayKey key = mrpc->getParentNode().getKey();
    if (leaveRequests.find(key) == leaveRequests.end()) {
        // TODO NOT QUITE SURE WHAT SHOULD BE DONE?
        EV << "some malicious activity going around" << endl;
        return;
    }

    std::map<OverlayKey, int>& queryNodesSelectionAlgo = leaveRequests[key].queryNodesSelectionAlgo;
    size_t responseRequired = leaveRequests[key].responseRequired;

    // SHOULD HAVE BEEN SOURCE NODE's Key
    //queryNodesSelectionAlgo[key] = mrpc->getCapacity();
    queryNodesSelectionAlgo[mrpc->getSrcNode().getKey()] = mrpc->getCapacity();
    if (queryNodesSelectionAlgo.size() == responseRequired) {
#if _HDEBUG_
        cout << thisNode << ": leaveReqeusts[key].node : " << leaveRequests[key].node << endl;
        cout << "Key is " << key << endl;
#endif
        //goAheadWithRestSelectionProcess (leaveRequests[key].node.getKey());
        alternateArrangementForYourGrandChildren(leaveRequests[key].node.getKey());
    }
}

void HTopology::handleGetParametersCall (BaseCallMessage *msg) {
    numSentMessages[EGetParameters]++;

    EV << "Got a getParameters call from " << msg->getSrcNode() << endl;

    HGetParametersCall *mrpc = (HGetParametersCall *)msg;
    HGetParametersResponse *rrpc = new HGetParametersResponse ();
    rrpc->setCapacity(capacity());
    rrpc->setBandwidth(bandwidth);
    rrpc->setRescueCapacity(rescueCapacity());
    rrpc->setBitLength(HGETPARAMETERSRESPONSE_L(rrpc));

    sendRpcResponse(mrpc, rrpc);
}

void HTopology::handleGetParametersResponse (BaseResponseMessage *msg, simtime_t rtt) {
    numRecvMessages[EGetParameters]++;

    HGetParametersResponse *mrpc = (HGetParametersResponse*) msg;
    OverlayKey key = mrpc->getSrcNode().getKey();

    EV << "rtt: " << rtt.inUnit(SIMTIME_MS)
            << "capacity: " << mrpc->getCapacity()
            << ", rescue capacity: "<< mrpc->getRescueCapacity()
            << ", bandwidth: "<<  mrpc->getBandwidth()<< endl;

    if (ancestors.find(key) != ancestors.end()) {
        RankingParameters parameters = {rtt.inUnit(SIMTIME_MS), mrpc->getCapacity(), mrpc->getRescueCapacity(), mrpc->getBandwidth()};
        ancestors[key].setRankingParameters(parameters);
        parametersResponseReceived++;
        EV << "Updating parameters at entry: " << ancestors[key].getHandle()
                        << " && rank is " << ancestors[key].getRank() << endl;
    }
    else if (nodesOneUp.find(key) != nodesOneUp.end()) {
        RankingParameters parameters = {rtt.inUnit(SIMTIME_MS), mrpc->getCapacity(), mrpc->getRescueCapacity(), mrpc->getBandwidth()};
        nodesOneUp[key].setRankingParameters(parameters);
        parametersResponseReceived++;
        EV << "Updating parameters at entry: " << nodesOneUp[key].getHandle()
                << " && rank is " << nodesOneUp[key].getRank() << endl;
    }

    if (parametersResponseReceived >= parametersResponseRequired-PARAMETERS_RESPONSE_BUFFER) {
        EV << "Restarting the parameters estimation timer " << endl;
        initializedRescueRanks = true;
        // TODO call the ranking function
        // AFAIK, every time you get a new message after the buffer #of responses,
        // you'll remove the previous one & reschedule the new one => you'll ultimately have a new one
        scheduleTimer(rescueParametersTimer, rescueParameterEstimationRate);
    }
}

void HTopology::handleChildAddedCall (BaseCallMessage *msg) {
    HChildAddedCall *mrpc = (HChildAddedCall *)msg;
    if (children.find(mrpc->getSrcNode().getKey()) == children.end()) {
        EV << thisNode << ": fake childAdded call from " << mrpc->getSrcNode() << endl;
    } else {
        EV << thisNode << ": adding our grandChild in the set for " << mrpc->getSrcNode() << "->" << mrpc->getChild() << endl;
        children[mrpc->getSrcNode().getKey()].addChild(mrpc->getChild());
    }
    delete msg;
}

void HTopology::handleChildRemovedCall(BaseCallMessage *msg) {
    HChildAddedCall *mrpc = (HChildAddedCall *)msg;
    if (children.find(mrpc->getSrcNode().getKey()) == children.end()) {
        EV << thisNode << ": fake childRemoved call from " << mrpc->getSrcNode() << endl;
    } else {
#if _HDEBUG_
        cout << thisNode << ": remove our grandChild in the set for " << mrpc->getSrcNode() << "->" << mrpc->getChild() << endl;
#endif
        EV << thisNode << ": remove our grandChild in the set for " << mrpc->getSrcNode() << "->" << mrpc->getChild() << endl;
        children[mrpc->getSrcNode().getKey()].removeChild(mrpc->getChild());
    }
    delete msg;
}

void HTopology::handleGetChildrenResponse (BaseResponseMessage *msg) {
    HGetChildrenResponse *childrenResponse = (HGetChildrenResponse*)msg;
    if (childrenResponse->getForGrandChildrenAccumulation()) {
        if (children.find(childrenResponse->getSrcNode().getKey()) == children.end()) {
            EV << thisNode << ": fake getChildren response for grandchildren accumulation" << endl;
        } else {
            EV << thisNode << ": setting our grandChildren for the child : " << childrenResponse->getSrcNode() << endl;
            //  NodeVector grandChildren;
            for (size_t i=0; i<childrenResponse->getChildrenArraySize(); ++i) {
                EV << "adding a new child functionality missing: " << childrenResponse->getChildren(i) << endl;
                // grandChildren.add(childrenResponse->getChildren(i));
                // TODO children[childrenResponse->getSrcNode().getKey()].addChild(childrenResponse->getChildren(i));
            }
            //children[childrenResponse->getSrcNode().getKey()].setNodeVector(grandChildren);
        }
    } else {
        EV << thisNode << ": setting NodesOneUp" << endl;
        // Set NodesOneUp
        setNodesOneUp(msg);
    }
}

// RPC
bool HTopology::handleRpcCall(BaseCallMessage *msg) {
    // There are many macros to simplify the handling of RPCs. The full list is in <OverSim>/src/common/RpcMacros.h.
    // start a switch
    RPC_SWITCH_START(msg);

    // enters the following block if the message is of type HCapacityCall (note the shortened parameter!)
    RPC_ON_CALL(HCapacity) {
        handleCapacityCall(msg);
        RPC_HANDLED = true;  // set to true, since we did handle this RPC (default is false)
        break;
    }

    RPC_ON_CALL(HGetParameters) {
        handleGetParametersCall(msg);
        RPC_HANDLED = true;
        break;
    }

    RPC_ON_CALL(HSelectParent) {
        numSentMessages[ESelectParent]++;
        //HSelectParentCall *mrpc = (HSelectParentCall)msg;

        // TODO Do check if the request is not a fake/malicious one
        RPC_HANDLED = true;
        break;
    }

    RPC_ON_CALL(HVideoSegment) {
        handleVideoSegment(msg);
        RPC_HANDLED = true;
        break;
    }

    RPC_ON_CALL(HLeaveOverlay) {
       handleLeaveCall(msg);
       RPC_HANDLED = true;
       break;
    }

    RPC_ON_CALL(HDeathAcknowledgement) {
       handleDeathAcknowledgementCall(msg);
       RPC_HANDLED = true;
       break;
    }

    RPC_ON_CALL(HResponsibilityAsParent) {
       handleResponsibilityAsParentCall(msg);
       RPC_HANDLED = true;
       break;
    }

    RPC_ON_CALL(HNewParentSelected) {
       handleNewParentSelectedCall(msg);
       RPC_HANDLED = true;
       break;
    }

    RPC_ON_CALL(HScheduleSegments) {
        handleScheduleSegmentsCall (msg);
        RPC_HANDLED = true;
        break;
    }

    RPC_ON_CALL(HSwitchToRescueMode) {
        handleSwitchToRescueModeCall(msg);
        RPC_HANDLED=true;
        break;
    }

    RPC_ON_CALL(HGetChildren) {
        sendChildren (msg);
        RPC_HANDLED = true;
        break;
    }

    RPC_ON_CALL(HRegisterInBootstrapping) {
        handleRegisterInBootstrappingCall(msg);
        RPC_HANDLED = true;
        break;
    }

    RPC_ON_CALL(HJoin) {
        handleJoinCall (msg);
        RPC_HANDLED = true;
        break;
    }

    RPC_ON_CALL(HRescueJoin) {
        handleRescueJoinCall(msg);
        RPC_HANDLED = true;
        break;
    }

    RPC_ON_CALL(HRemoveRescueLink) {
        handleRemoveRescueLinkCall(msg);
        RPC_HANDLED = true;
        break;
    }

    RPC_ON_CALL(HConvertRescueLink) {
        handleConvertRescueLinkCall(msg);
        RPC_HANDLED = true;
        break;
    }

    RPC_ON_CALL(HReJoin) {
       handleReJoinCall(msg);
       RPC_HANDLED = true;
       break;
   }

    RPC_ON_CALL(HChildAdded) {
        handleChildAddedCall(msg);
        RPC_HANDLED = true;
        break;
    }

    RPC_ON_CALL(HChildRemoved) {
        handleChildRemovedCall(msg);
        RPC_HANDLED = true;
        break;
    }

    // end the switch
    RPC_SWITCH_END();

    // return whether we handled the message or not.
    // don't delete unhandled messages!
    return RPC_HANDLED;
}

// Called when an RPC we sent has timed out.
// Don't delete msg here!
void HTopology::handleRpcTimeout(BaseCallMessage* msg,
                                 const TransportAddress& dest,
                                 cPolymorphic* context, int rpcId,
                                 const OverlayKey& destKey) {
    // Same macros as in handleRpc

    // start a switch
    RPC_SWITCH_START(msg);

        // DONE this timeout seems to overshooting the actual time required to send to the children
        //  - problem was that there was no response message which can negate the timeout period & hence a response was created
        // I think you should change the timeout period associated with this call, otherwise it'll assume the node is DEAD
        RPC_ON_CALL(HVideoSegment) {
            HVideoSegmentCall *mrpc = (HVideoSegmentCall *)msg;
            // TODO failure detection by rescue parent
            if (children.find(destKey) == children.end()) {
                EV << "not my child, why Am i sending it a video segment?" << endl;
            }
            else {
                EV << "Node failed is my child: " << children[destKey] << endl;

#if _HDEBUG_
                cout << thisNode << ": Node failed is my child: " << children[destKey] << endl;
#endif

                // Notify our parent that we've removed a child from our children set
                if (parent.isUnspecified() == false) {
#if _HDEBUG_
                    cout << thisNode << ": sending child removed call to our parent " << children[destKey] << endl;
#endif

                    HChildRemovedCall *childRemoveCall = new HChildRemovedCall();
                    //childRemoveCall->setChild(mrpc->getSrcNode());
                    childRemoveCall->setChild(children[destKey].getHandle());
                    childRemoveCall->setBitLength(HCHILDREMOVEDCALL_L(childRemoveCall));
                    sendRouteRpcCall(OVERLAY_COMP, parent.getHandle(), childRemoveCall);
                }

                // TODO solve this
                // Send deadthAck to the child
                HDeathAcknowledgementCall *deathAckCall = new HDeathAcknowledgementCall();
                deathAckCall->setBitLength(HDEATHACKNOWLEDGEMENTCALL_L(deathAckCall));
                sendRouteRpcCall(OVERLAY_COMP, children[destKey].getHandle(), deathAckCall);
#if _HDEBUG_
                cout << thisNode << ": ack'd the child's death " << children[destKey].getHandle() << endl;
#endif

                //  Notify the failure to the children
                set<NodeHandle> nodeChildren = children[destKey].getChildren();
                if (nodeChildren.size() > 0) {
                    for (set<NodeHandle>::iterator it=nodeChildren.begin(); it!=nodeChildren.end(); ++it) {
                        HSwitchToRescueModeCall *switchCall = new HSwitchToRescueModeCall();
                        switchCall->setBitLength(HSWITCHTORESCUEMODECALL_L(switchCall));
                        sendRouteRpcCall (OVERLAY_COMP, (*it), switchCall);
                    }

#if _HDEBUG_
                    cout << thisNode << ": selecting replacement for " << children[destKey].getHandle() << endl;
                    cout << "from the following nodes " << endl;
                    for (set<NodeHandle>::iterator it=nodeChildren.begin(); it!=nodeChildren.end(); ++it) {
                         cout << "- " << *it << endl;
                    }
#endif
                    //  Select a replacement
                    selectReplacement(children[destKey].getHandle(), NULL);
                } else {
                    EV << thisNode << ": A leaf just left me" << mrpc->getSrcNode() << endl;

                    // TODO may be we can adopt the our grand children
                    // Remove this leaf node from the children set
                    children.erase(mrpc->getSrcNode().getKey());
                }
            }
        }

        RPC_ON_CALL(HGetParameters) {
            EV << "TIMEOUT HGETPARAMETERS: couldn't send to " << dest << endl;
        }

        RPC_ON_CALL(HScheduleSegments) {
            EV << "Schedule segments: couldn't send to " << dest << endl;
        }

    // end the switch
    RPC_SWITCH_END();
}

// Called when we receive an RPC response from another node.
// Don't delete msg here!
void HTopology::handleRpcResponse(BaseResponseMessage* msg,
                                  cPolymorphic* context,
                                  int rpcId,
                                  simtime_t rtt) {
    // The macros are here similar. Just use RPC_ON_RESPONSE instead of RPC_ON_CALL.

    // start a switch
    RPC_SWITCH_START(msg);
        // enters the following block if the message is of type MyNeighborResponse (note the shortened parameter!)
        RPC_ON_RESPONSE (HVideoSegment) {
            numRecvMessages[EVideoSegment]++;
            EV << "got an hVideoSegment call's response" << endl;
            break;
        }

        RPC_ON_RESPONSE(HSelectParent) {
            numRecvMessages[ESelectParent]++; break;
            // TODO, will there really be any response message of this sort?
        }

        RPC_ON_RESPONSE(HCapacity)                  { handleCapacityResponse(msg);            break;      }
        RPC_ON_RESPONSE(HGetParameters)             { handleGetParametersResponse(msg, rtt);  break;      }
        RPC_ON_RESPONSE(HScheduleSegments)          { handleScheduleSegmentsResponse(msg);    break;      }
        RPC_ON_RESPONSE(HGetChildren)               { handleGetChildrenResponse(msg);         break;      }
        RPC_ON_RESPONSE(HRegisterInBootstrapping)   { handleRegisterInBootstrappingResponse(msg); break;  }
        RPC_ON_RESPONSE(HRescueJoin)                { handleRescueJoinResponse(msg);          break;      }
        RPC_ON_RESPONSE(HConvertRescueLink)         { handleConvertRescueLinkResponse(msg);   break;      }
        RPC_ON_RESPONSE(HReJoin)                    { handleReJoinResponse(msg);              break;      }
        RPC_ON_RESPONSE(HJoin)                      { handleJoinResponse(msg);                break;      }

    // end the switch
    RPC_SWITCH_END();
}

// AddOns

// select replacement for node
// 1) Setting Up the required Parameters for the procedure
void HTopology::getParametersForSelectionAlgo (const OverlayKey& key) {
    EV << "getParametersForSelectionAlgo : " << key << endl;

    if (key.isUnspecified()) {
        cout << "getParametersForSelectionAlgo --> key is unspecified" << endl;
    }

    if (leaveRequests.find(key) == leaveRequests.end()) {
        EV << "some spurious call to getParametersForSelectionAlgo" << endl;
        return;
    }

    if (children.find(key) == children.end()) {
        EV << "replacement of the given node is not a responsibility of this node" << endl;
        return;
    }

    set<NodeHandle> nodeChildren = children[key].getChildren();

    leaveRequests[key].queryNodesSelectionAlgo.clear();        // clear this variable for storing the recent values
    leaveRequests[key].responseRequired=nodeChildren.size();   // Response required
    for (set<NodeHandle>::iterator it=nodeChildren.begin(); it!=nodeChildren.end(); ++it) {
        // Prepare the capacity message
        HCapacityCall *msg = new HCapacityCall();
        NodeHandle node = *it;
        msg->setDestinationKey(node.getKey());
        msg->setBitLength(HCAPACITYCALL_L(msg));

        // send it to the destination
        // TODO Not sure if this is the correct way to do it
        sendRouteRpcCall (OVERLAY_COMP, node, msg);
    }
}

bool HTopology::pickReplacement(int noOfChildrenToAdd, bool replacementDone,
        std::map<OverlayKey, int>::iterator& it,
        std::map<OverlayKey, int>& queryNodesSelectionAlgo) {
    for (; it != queryNodesSelectionAlgo.end(); ++it) {
        // What else is to be done?
        // Modify the existing next & prev pointers for the replacement's sibling
        // Modify the pointers for the siblings in the current overlay
        // And add nodeChildren as parent to the replacement node
        int capacity = (*it).second;
        // TODO actually one less -> leave itself
        if (capacity >= noOfChildrenToAdd) {
#if _HDEBUG_
            cout << "Replacement node's key is " << (*it).first << endl;
#endif
            replacementDone = true;
            break;
        }
    }
    return replacementDone;
}

void HTopology::sendLeaveResponse(const OverlayKey& key) {
    // 1) Notify the node about the result
    // Send the HLeaveOverlayResponse to the node, whose replacement has been found
    // May be some node can serve till a viable solution is found
    if (leaveRequests[key].mrpc != NULL) {
        // TODO this won't be handled right?
        HLeaveOverlayResponse *rrpc = new HLeaveOverlayResponse();
        rrpc->setPermissionGranted(true);
        rrpc->setBitLength(HLEAVEOVERLAYRESPONSE_L(rrpc));
        sendRpcResponse(leaveRequests[key].mrpc, rrpc);
    }
}

// 2) Main procedure for deciding the replacement for keyParent
void HTopology::goAheadWithRestSelectionProcess(const OverlayKey& key) {
    EV << "Rest of the selection process for child replacement: " << key << endl;
    if (key.isUnspecified()) {
        cout << "goAheadWithRestSelectionProcess --> key is unspecified" << endl;
    }

    if (leaveRequests.find(key) == leaveRequests.end()) {
        EV << "some spurious call to goAheadWithRestSelectionAlgo" << endl;
        return;
    }

    if (children.find(key) == children.end()) {
        EV << "replacement of the given node is not a responsibility of this node " << endl;
        return;
    }

    int noOfChildrenToAdd = children[key].getChildren().size();
    bool replacementDone = false;
    std::map<OverlayKey, int>& queryNodesSelectionAlgo = leaveRequests[key].queryNodesSelectionAlgo;
    std::map<OverlayKey, int>::iterator it=leaveRequests[key].queryNodesSelectionAlgo.begin();

#if _HDEBUG_
    cout << "Finding out replacement for the key " << key << endl;
#endif
    replacementDone = pickReplacement(noOfChildrenToAdd, replacementDone, it, queryNodesSelectionAlgo);

    if (replacementDone) {
        // 1) Notify the node about the result
        // Send the HLeaveOverlayResponse to the node, whose replacement has been found
        // May be some node can serve till a viable solution is found
        sendLeaveResponse(key);

        // 2) Replace the child with this newly selected parent (children list)
        set<NodeHandle> newChildren = children[key].getChildren();

        set<NodeHandle>::iterator pos=newChildren.begin();
#if _HDEBUG_
        cout << "Keys are " << endl;
        for (; pos!=newChildren.end(); ++pos) {
            cout << (*pos).getKey() << endl;
        }
#endif

        pos=newChildren.begin();
        for (; pos!=newChildren.end(); ++pos) {
            if ((*pos).getKey() == (*it).first) break;
        }

#if _HDEBUG_
        cout << "pos == newChildren.end() ??" << (pos==newChildren.end()) << endl;
#endif

        NodeHandle newHandle = *pos;
        if (pos != newChildren.end()) newChildren.erase(pos);
        else {
            EV << "Is this even possible that the replacement node is not in the children set?" << endl;
#if _CURDEBUG_
            cout << "Is this even possible that the replacement node is not in the children set?"
                    << (*it).first << endl;
#endif
        }
        HNode newNode = children[key];
        NodeHandle oldNode = newNode.getHandle();
        // children.erase(key);
        newNode.setHandle(newHandle);
        newNode.setChildren(newChildren);
        children[newHandle.getKey()] = newNode;


        // 3) Inform the newParent about its children
        HResponsibilityAsParentCall *mrpc = new HResponsibilityAsParentCall();
        mrpc->setChildrenArraySize(newChildren.size());

        int i=0;
        for (set<NodeHandle>::iterator iter=newChildren.begin(); iter!=newChildren.end(); ++iter,++i) {
            mrpc->setChildren(i, *iter);
        }

        mrpc->setParent(thisNode);
        mrpc->setBitLength(HRESPONSIBILITYASPARENTCALL_L(mrpc));
        // sendRouteRpcCall(OVERLAY_COMP, oldNode, mrpc);  // Definite bug creeping in since no one knows
        sendRouteRpcCall(OVERLAY_COMP, newHandle, mrpc);

        // 4) Inform children about the new parent
        // TODO what about the successor & predecessor
        for (set<NodeHandle>::iterator iter=newChildren.begin(); iter!=newChildren.end(); ++iter) {
            HNewParentSelectedCall *msg = new HNewParentSelectedCall();
            msg->setParent(newNode.getHandle());
            msg->setBitLength(HNEWPARENTSELECTEDCALL_L (msg));
            sendRouteRpcCall(OVERLAY_COMP, *iter, msg);
        }

        // END BOOK-KEEPING
    } else {
        // Couldn't select a parent for the children,
        // WHAT's THE FALL BACK OPTION?
        noOfChildren--;
        EV << "Couldn't select a new node" << endl;
    }

    // TODO this we've to do in any case
    children.erase(key);
    leaveRequests.erase (key);
    // 1) Get the node's children from the handle
    // 2) Job is to pick a node from this list & make it the new parent & let this propagate till the last level
    //  or Let's pick a node at last level & make it the new parent
    //   We can also look at some of the characteristics
    //          It should be having enough capacity to support all the children in the list
    //              (probably second approach will always work).
    //          Any other transfer characteristics?

    // Once done with "deciding the new parent", inform the children about their new parent
    // Also inform the new parent for the same
}

void HTopology::sendReJoinCall () {
    // TODO pick your choice of node to be added in the tree
    // find a new bootstrap node and enroll to the bootstrap list
    bootstrapNode = bootstrapList->getBootstrapNode(0);

    EV << "bootstrap is " << bootstrapNode << endl ;
    cout << thisNode << ": going to send rejoin call " << bootstrapNode << endl;

    // Should not be the first node in the list
    assert (bootstrapNode.isUnspecified() == false);

    EV << thisNode << ": is going to Re-Join the overlay rooted at " << bootstrapNode << endl;
    HReJoinCall *msg = new HReJoinCall();
    msg->setBitLength(HREJOINCALL_L(msg));

    // send it to the destination
    sendRouteRpcCall (OVERLAY_COMP, bootstrapNode, msg);
}

// Getting a parent alternative [GParent couldn't find one]
void HTopology::getAlternateParent() {
    if (modeOfOperation == RESCUE_MODE) {
        cout << thisNode << ": getAlternateParent -> rescue mode" << endl;

        if (rescueParent.isUnspecified() == false) {
            cout << thisNode << ": getAlternateParent -> converting rescue link to parent-child" << endl;

            // Try to convert the rescue link to parent-child link
            HConvertRescueLinkCall *msg = new HConvertRescueLinkCall();
            msg->setBitLength(HCONVERTRESCUELINKCALL_L(msg));
            sendRouteRpcCall(OVERLAY_COMP, rescueParent.getHandle(), msg);
        } else {
            cout << thisNode << ": getAlternateParent -> converting rescue link to parent-child" << endl;

            // No Rescue parent for the help [rejoin the overlay network]
            sendReJoinCall();
        }
    } else {
        cout << thisNode << ": getAlternateParent -> general mode" << endl;
        assert(modeOfOperation == GENERAL_MODE);
        // Simple rejoin the network [WHAT ABOUT THE PACKET SCHEDULING]
        sendReJoinCall();
    }
}

HNode HTopology::grandChildWithThisKey (set<NodeHandle>& newChildren, OverlayKey key) {
    set<NodeHandle>::iterator pos=newChildren.begin();
#if _HDEBUG_
        cout << "Keys are " << endl;
        for (; pos!=newChildren.end(); ++pos) {
            cout << (*pos).getKey() << endl;
        }
#endif

    pos=newChildren.begin();
    for (; pos!=newChildren.end(); ++pos) {
        if ((*pos).getKey() == key) break;
    }

#if _HDEBUG_
        cout << "pos == newChildren.end() ??" << (pos==newChildren.end()) << endl;
#endif

    NodeHandle newHandle;
    if (pos != newChildren.end()) { newHandle = *pos; newChildren.erase(pos); }
    else {
        EV << "Is this even possible that the replacement node is not in the children set?" << endl;
#if _CURDEBUG_
        cout << "Is this even possible that the replacement node is not in the children set?"
                << key << endl;
        cout << "size of newChildren: " << newChildren.size() << endl;
#endif

        pos = newChildren.begin();
        newHandle = *pos;
        newChildren.erase(pos);
    }

    HNode newNode;
    newNode.setHandle(newHandle);
    newNode.setChildren(newChildren);

    return newNode;
}

void HTopology::sendReplacementMessages(
        const set<NodeHandle>& childrenToAddToThatBranch,
        const set<NodeHandle>& noHelpAssistedChildren, const HNode& newNode) {

    // 4a) Inform the newParent about its children
    HResponsibilityAsParentCall* mrpc = new HResponsibilityAsParentCall();
    mrpc->setChildrenArraySize(childrenToAddToThatBranch.size());
    int i = 0;
    for (set<NodeHandle>::iterator iter = childrenToAddToThatBranch.begin();
            iter != childrenToAddToThatBranch.end(); ++iter, ++i) {
        mrpc->setChildren(i, *iter);
    }
    mrpc->setParent(thisNode);
    mrpc->setBitLength(HRESPONSIBILITYASPARENTCALL_L(mrpc));
    // Definite bug creeping in since no one knows
    sendRouteRpcCall(OVERLAY_COMP, newNode.getHandle(), mrpc);


    // 4b) Inform children about the new parent
    // TODO what about the successor & predecessor
    for (set<NodeHandle>::iterator iter = childrenToAddToThatBranch.begin();
            iter != childrenToAddToThatBranch.end(); ++iter) {
        HNewParentSelectedCall *msg = new HNewParentSelectedCall();
        msg->setParent(newNode.getHandle());
        msg->setBitLength(HNEWPARENTSELECTEDCALL_L (msg));
        sendRouteRpcCall(OVERLAY_COMP, *iter, msg);
    }


    // 4c) Inform the unlucky grandChildren to seek the shelter somewhere else in the overlay
    for (set<NodeHandle>::iterator iter = noHelpAssistedChildren.begin();
            iter != noHelpAssistedChildren.end(); ++iter) {
        HNoReplacementFoundCall *msg = new HNoReplacementFoundCall();
        msg->setBitLength(HNOREPLACEMENTFOUNDCALL_L(msg));
        sendRouteRpcCall(OVERLAY_COMP, *iter, msg);
    }
}

std::ostream& operator<<(std::ostream& s, const pair<OverlayKey, int>& p)
{
    return s << '(' << p.first << ',' << p.second << ')';
}

// Do alternate arrangement for your grand children
void HTopology::alternateArrangementForYourGrandChildren(const OverlayKey& key) {
    // Pick the maximum capacity grandChild & add others to it [as much as possible]
    // others need to see for themselves
    EV << "V2 - Rest of the selection process for child replacement: " << key << endl;
    if (key.isUnspecified()) {
        cout << "AlternateArrangement --> key is unspecified" << endl;
    }
    if (leaveRequests.find(key) == leaveRequests.end()) {
        EV << "some spurious call to alternateArrangement" << endl;
        return;
    }
    if (children.find(key) == children.end()) {
        EV << "replacement of the given node is not a responsibility of this node " << endl;
        return;
    }

    // TODO if only leaving node has only one child??
    std::map<OverlayKey, int>& queryNodesSelectionAlgo = leaveRequests[key].queryNodesSelectionAlgo;
    std::map<OverlayKey, int>::iterator replacementNode;

    // 0)
    // Find out the maximum element node among the grandChildren [children of children[key]]
    replacementNode = std::max_element(queryNodesSelectionAlgo.begin(), queryNodesSelectionAlgo.end());

    // verify that this gives correct output
    /*std::copy(queryNodesSelectionAlgo.begin(), queryNodesSelectionAlgo.end(), std::ostream_iterator<pair<OverlayKey,int> >(cout, "-- \n"));
    cout << "replacement node " << (*replacementNode).second << endl;*/

    // 1)
    // Notify the node about the result
    // Send the HLeaveOverlayResponse to the node, whose replacement has been found
    // May be some node can serve till a viable solution is found
    sendLeaveResponse(key);

    // Add the replacement grandChild as your child & push in as many nodes as possible
    // 2)
    // Find the grandChild with this key
    // Replace the child with this newly selected parent (children list)
    // In case the grandChild do not exists, pick the beginning node
    set<NodeHandle> newChildren = children[key].getChildren();
    if (newChildren.size() > 0) {
        HNode newNode = grandChildWithThisKey(newChildren, (*replacementNode).first);

        // 3)
        // Get the capacity of the newNode
        // And prepare the replacementChild, childrenToAddToThatBranch && noHelpAssistedToChildren
        replacementNode = queryNodesSelectionAlgo.find(newNode.getKey());
        if (replacementNode == queryNodesSelectionAlgo.end()) {
                 //||(children[key].getChildren().find(newNode) == children[key].getChildren().end())) {
            noOfChildren--;
            cout << thisNode << ": fatal error" << endl;

            for (set<NodeHandle>::iterator iter=children[key].getChildren().begin(); iter!=children[key].getChildren().end(); ++iter) {
                HNewParentSelectedCall *chooseAlternate = new HNewParentSelectedCall();
                NodeHandle unspecified;
                chooseAlternate->setParent(unspecified);
                chooseAlternate->setBitLength(HNEWPARENTSELECTEDCALL_L (chooseAlternate));
                sendRouteRpcCall(OVERLAY_COMP, *iter, chooseAlternate);
            }
        } else {
            int capacityLeft = (*replacementNode).second;
            set<NodeHandle> newNodeChildren = newNode.getChildren();

            // Minimum of the two candidates
            capacityLeft = min(capacityLeft, (int)newNodeChildren.size());
            set<NodeHandle>::iterator noHelpBegin = newNodeChildren.begin();
            std::advance(noHelpBegin, capacityLeft);

            // Splice the set out to get the required sets of lucky & unlucky children
            set<NodeHandle> noHelpAssistedChildren(noHelpBegin, newNodeChildren.end());
            set<NodeHandle> childrenToAddToThatBranch(newNodeChildren.begin(), noHelpBegin);

            // TODO rectify this
            newNode.setChildren(childrenToAddToThatBranch);
            children[newNode.getKey()] = newNode;

            // 4)
            // Send various calls to the participants
            sendReplacementMessages(childrenToAddToThatBranch,
                    noHelpAssistedChildren, newNode);
        }
    } else {
        cout << thisNode << ": no children left for the node " << key << endl;
    }

    children.erase(key);
    leaveRequests.erase (key);
}

void HTopology::getGrandChildrenAt(BaseCallMessage* msg) {
    // get the grandChildren available at the newly connected node's subtree
    HGetChildrenCall* getChildrenCall = new HGetChildrenCall();
    getChildrenCall->setForGrandChildrenAccumulation(true);
    getChildrenCall->setBitLength(HGETCHILDRENCALL_L(getChildrenCall));
    sendRouteRpcCall(OVERLAY_COMP, msg->getSrcNode(), getChildrenCall);
}

void HTopology::handleConvertRescueLinkCall (BaseCallMessage *msg) {
    HConvertRescueLinkCall *convertCall = (HConvertRescueLinkCall *)msg;
    cout << thisNode << ": got convert rescue link call from " << msg->getSrcNode() << endl;
    if (rescueChildren.find(convertCall->getSrcNode().getKey()) == rescueChildren.end()) {
        cout << thisNode << ": fake convert rescue call" << endl;
        return;
    }

    HConvertRescueLinkResponse *convertResponse = new HConvertRescueLinkResponse();

    if (capacity() > 0) {
        // Add this into out children list
        convertResponse->setJoined(true);

        // add to children list && prepare ancestors & successor, predecessor
        // if we are out of capacity => remove from bootstrapping
        prepareAndSendJoinAcceptance(convertCall, convertResponse);

        // get the grandChildren available at the newly connected node's subtree
        getGrandChildrenAt(msg);

        // Remove the source node from rescue children
        rescueChildren.erase(convertCall->getSrcNode().getKey());
    } else {
        // We don't have the vacancy to fill this node's requirement
        convertResponse->setJoined(false);
    }

    convertResponse->setBitLength(HCONVERTRESCUELINKRESPONSE_L(convertResponse));
    sendRpcResponse(convertCall, convertResponse);
}

void HTopology::handleConvertRescueLinkResponse (BaseResponseMessage *msg) {
    cout << thisNode << ": convert rescue link response: " << msg->getSrcNode() << endl;

    HConvertRescueLinkResponse *convertResponse = (HConvertRescueLinkResponse *) msg;
    if (rescueParent.isUnspecified() == true) return;
    assert (rescueParent.getHandle() == convertResponse->getSrcNode());

    if (convertResponse->getJoined() == true) {
        // extract out common functions from handleJoinResponse
        EV << "We got a +ve response from " << convertResponse->getSrcNode() << endl;
        cout << thisNode << ": We got a +bve response from " << convertResponse->getSrcNode() << endl;
        setOverlayLinksFromJoinResponse(convertResponse);

        // DONE send parent addChildCall for our children [taken care by the rescue parent]

        // set rescue parent to unspecified again
        rescueParent = HNode::unspecifiedNode;
    } else {
        // Go ahead & look for re-join in the network
        cout << thisNode << ": We got a -ve convert response from " << convertResponse->getSrcNode() << endl;
        sendReJoinCall();
    }
}

void HTopology::handleReJoinCall (BaseCallMessage *msg) {
    HReJoinCall *mrpc = (HReJoinCall*) msg;
    HReJoinResponse *rrpc = new HReJoinResponse ();
    EV << thisNode << ": REJOIN received from " <<  msg->getSrcNode() << endl;
    cout << thisNode << ": REJOIN received from " <<  msg->getSrcNode() << endl;

    // TODO capacity()>0 && modeOfOperation==GENERAL_MODE
    if (capacity()>0) {
        // Add it to children set && prepare the response required && send the joining acceptance to the node
        prepareAndSendJoinAcceptance(msg, rrpc);

        // get the grandChildren available at the newly connected node's subtree
        getGrandChildrenAt(msg);
    } else {
        // TODO may be check if anyone of them can support the children
        // Try to keep the height of the tree as low as possible
        EV << "REJOIN redirecting to one of my children: " << endl;
        prepareAlternativeToJoin(rrpc);
    }

    rrpc->setBitLength(HREJOINRESPONSE_L(rrpc));
    sendRpcResponse(mrpc, rrpc);
}

void HTopology::removeRescueLink() {
    // remove your rescue link from the rescue parent
    if (!rescueParent.isUnspecified()) {
        HRemoveRescueLinkCall *removeRescueLinkCall =
                new HRemoveRescueLinkCall();
        removeRescueLinkCall->setBitLength(
                HREMOVERESCUELINKCALL_L(removeRescueLinkCall));
        sendRouteRpcCall(OVERLAY_COMP, rescueParent.getHandle(),
                removeRescueLinkCall);

        // Reset the rescue parent to unspecified node
        rescueParent = HNode::unspecifiedNode;
    }
}

void HTopology::handleReJoinResponse (BaseResponseMessage *msg) {
    HReJoinResponse* mrpc = (HReJoinResponse*)msg;          // get Response message
    if (mrpc->getJoined() == true) {
        EV << "We got a REJOIN response from " << mrpc->getSrcNode() << endl;
        cout << "We got a REJOIN response from " << mrpc->getSrcNode() << endl;

        // Set parent, ancestors & mode of operation
        setOverlayLinksFromJoinResponse(mrpc);

        // remove your rescue link from the rescue parent
        removeRescueLink();
    } else {
        EV << thisNode << ": is going to join the overlay rooted at" << mrpc->getSuccessorNode() << endl;
        HReJoinCall *mcall = new HReJoinCall();
        mcall->setBitLength(HREJOINCALL_L (mcall));

        // go on & call the given node
        assert (mrpc->getSuccessorNode().isUnspecified() == false);
        EV << "REJOIN joining at " << mrpc->getSuccessorNode() <<  endl;
        sendRouteRpcCall (OVERLAY_COMP, mrpc->getSuccessorNode(), mcall);
    }
}

void HTopology::handleRescueJoinCall (BaseCallMessage *msg) {
    HRescueJoinCall *mrpc = (HRescueJoinCall *)msg;
    HRescueJoinResponse *rrpc = new HRescueJoinResponse();
    if (rescueCapacity() > 0) {
        EV << thisNode << ": will be adding node: " << mrpc->getSrcNode() << ": as child" << endl;
                noOfChildren++;

        // TODO what happens when this rescue node fails when its in RESCUE_MODE
        // who will help its children?
        HNode rescueChild;
        rescueChild.setHandle(mrpc->getSrcNode());

        // there shouldn't already be any node with this key
#if _HDEBUG_
        if (rescueChildren.find(rescueChild.getHandle().getKey()) != rescueChildren.end()) {
            cout << thisNode << ": node already in rescue children set "<<
                    rescueChild.getHandle() << endl;
        }
#endif
        assert(rescueChildren.find(rescueChild.getHandle().getKey()) == rescueChildren.end());
        rescueChildren[rescueChild.getHandle().getKey()] = rescueChild;
        rrpc->setJoined(true);

        // Do we need to tell our parent, regarding we adopting a new child?
        // Let's not complicate the situation, parent node on failure will take care of the actual children only
        // Let rescue children know about your failure, they anyways are in rescue situation &
        // this will make their situation even worse
    } else{
        rrpc->setJoined(false);
    }

    rrpc->setBitLength(HRESCUEJOINRESPONSE_L(rrpc));
    sendRpcResponse(mrpc, rrpc);
}

void HTopology::handleRescueJoinResponse (BaseResponseMessage *msg) {
    HRescueJoinResponse *rescueResponse = (HRescueJoinResponse *)msg;
    if (rescueResponse->getJoined() == true) {
#if _HDEBUG_
        cout << thisNode << ": rescue parent set to " << rescueResponse->getSrcNode() << endl;
#endif
        rescueParent.setHandle(rescueResponse->getSrcNode());
    } else {
        // remove this node from the current rescue nodes & send the rescue call to a valid node
#if _HDEBUG_
        cout << thisNode << ": curr rescue size : " << currentRescueNodes.size() << endl;
#endif
        for(vector<RescueNode>::iterator it=currentRescueNodes.begin(); it!=currentRescueNodes.end(); ++it) {
            if ((*it).getHandle() == rescueResponse->getSrcNode()) {
#if _HDEBUG_
                cout << thisNode << ": trying to erase rescue possibility  ->" << rescueResponse->getSrcNode() << endl;
#endif
                currentRescueNodes.erase(it);
                break;
            }
        }

        sendRescueCall();
    }
}

// Picks up the next valid rescueParent & calls for the help
void HTopology::sendRescueCall() {
    bool gotARescuer=false;
    for (size_t i=0; i<currentRescueNodes.size(); ++i) {
        if (currentRescueNodes[i].getRankingParameters().rescueCapacity > 0) {
            HRescueJoinCall *rescueCall = new HRescueJoinCall();
            rescueCall->setBitLength(HRESCUEJOINCALL_L(rescueCall));

#if _HDEBUG_
            cout << thisNode << ": Possible rescue parent has rank: " << currentRescueNodes[i].getRank() ;
            cout << " ->" << currentRescueNodes[i].getHandle() << endl;
#endif
            EV << thisNode << ": Possible rescue parent has rank: " << currentRescueNodes[i].getRank() << endl;

            if (currentRescueNodes[i].getHandle().isUnspecified()) {
                cout << thisNode << ": node is unspecified -> " << currentRescueNodes[i].getHandle() << endl;
            }

            sendRouteRpcCall (OVERLAY_COMP, currentRescueNodes[i].getHandle(), rescueCall);
            gotARescuer = true;
            break;
        }
    }

    if (!gotARescuer) {
#if _HDEBUG_
        cout << thisNode << ": Cannot find a rescue parent" << endl;
#endif
        EV << thisNode << ": Cannot find a rescue parent" << endl;
    }
}

// choose a rescue parent for yourself
void HTopology::selectRescueParent () {
    // This should be quite an easy job once we are done with "Ranking the rescue nodes"
    // Just go one by one to all the nodes in the rescue list in descending order of their
    // ranks & ask if they can serve as rescuers, if yes go ahead and change the mode to RESCUE
    // ultimately we should be allotted a rescue position (at SOURCE NODE)

    // send the node a rescue signal

    // during the rescue situation we should be using our network nodes for transferring the
    // deadline segments, may be use the transfer algorithm from Anysee.

    // TODO instead of calling getRankedNodes(), just keep a variable keeping these nodes
    // so that we don't have to gather them up
    if (modeOfOperation != RESCUE_MODE) {
        EV << "Spurious call to select a rescue parent" << endl;
        return;
    }

    if (rescueParent.isUnspecified() == false) {
#if _HDEBUG_
        cout << thisNode << ": rescue parent is already set" << endl;
#endif
        EV << thisNode << ": rescue parent is already set" << endl;
        return;
    }

#if _HDEBUG_
    cout << thisNode << ": selecting a rescue parent" << endl;
#endif
    currentRescueNodes = getRankedRescueNodes();
    sendRescueCall();
}

// returns the RescueNode structures for the ranked rescue nodes
vector<RescueNode> HTopology::getRankedRescueNodes (){
    // TODO how do we make sure that the parameters are initialized?
#if _HDEBUG_
    cout << thisNode << "Getting ranked rescue nodes." << endl;
#endif
    vector<RescueNode> rescueNodes;
    for(RescueMapIterator it=ancestors.begin(); it!=ancestors.end(); ++it) {
        rescueNodes.push_back((*it).second);
    }

    for(RescueMapIterator it=nodesOneUp.begin(); it!=nodesOneUp.end(); ++it) {
        rescueNodes.push_back((*it).second);
    }

    // sort them as per their ranking
    sort(rescueNodes.begin(), rescueNodes.end(), compareRescueNodes);
    return rescueNodes;
}

// returns the NodeHandles for the ranked rescue nodes
vector<NodeHandle> HTopology::getRankedRescueNodeHandles () {
    vector<RescueNode> rescueNodes = getRankedRescueNodes();
    vector<NodeHandle> rankedNodes;
    for (size_t i=0; i<rescueNodes.size(); ++i) rankedNodes.push_back(rescueNodes[i].getHandle());

    return rankedNodes;
}

// look for alternatives on deadline approaching segments
void HTopology::scheduleDeadlineSegments (int startSegmentID, int count, int perNode) {
    vector<NodeHandle> rankedNodes = getRankedRescueNodeHandles();
    int nodeNo=0;

    while (count !=0) {
        // Prepare the function call
        HScheduleSegmentsCall *scheduleCall = new HScheduleSegmentsCall();
        scheduleCall->setStartSegmentID(startSegmentID);
        scheduleCall->setCount(perNode);
        scheduleCall->setBitLength(HSCHEDULESEGMENTSCALL_L(scheduleCall));

        // TODO send to the node in the order of priority
        // 1) should the bandwidth be of concern too?
        // 2) what about the timeRemaining to deadline?
        sendRouteRpcCall(OVERLAY_COMP, rankedNodes[nodeNo++], scheduleCall);

        startSegmentID += perNode;
        count -= perNode;
    }
}

// Advance Features
void HTopology::optimizeTree () {
    // TODO Deals with height consideration of the tree
}

void HTopology::calculateResourceAllocationPolicy () {
    // TODO Resource allocation policy in case we're left with limited resources to spare[see Anysee]
}
