//
// Generated file, do not edit! Created by opp_msgc 4.3 from ./HMessage.msg.
//

#ifndef _HMESSAGE_M_H_
#define _HMESSAGE_M_H_

#include <omnetpp.h>

// opp_msgc version check
#define MSGC_VERSION 0x0403
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of opp_msgc: 'make clean' should help.
#endif

// cplusplus {{
#include <TransportAddress.h>
#include <NodeHandle.h>
#include <OverlayKey.h>
#include <CommonMessages_m.h>
#include "HTopology.h"

#define JOINCALL_L(msg) 			BASECALL_L(msg)
#define HCAPACITYCALL_L(msg) 		BASECALL_L(msg) + KEY_L
#define HCAPACITYRESPONSE_L(msg) 	BASERESPONSE_L(msg) + NODEHANDLE_L + TYPE_L
#define HSELECTPARENTCALL_L(msg) 	HCAPACITYCALL_L(msg)
#define HSELECTPARENTRESPONSE_L(msg) BASERESPONSE_L(msg) + NODEHANDLE_L
// }}



/**
 * Enum generated from <tt>./HMessage.msg</tt> by opp_msgc.
 * <pre>
 * enum MessageType {
 *     M_JOIN=1;				
 *     M_LEAVE=2;			
 *     M_QUERY_NODE=3;		
 *     M_QUERY_SEGMENT=4;	
 *     M_RESCUE=5;			
 * };
 * </pre>
 */
enum MessageType {
    M_JOIN = 1,
    M_LEAVE = 2,
    M_QUERY_NODE = 3,
    M_QUERY_SEGMENT = 4,
    M_RESCUE = 5
};

/**
 * Class generated from <tt>./HMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet HCapacityCall extends BaseCallMessage {
 *     OverlayKey destinationKey;
 * };
 * </pre>
 */
class HCapacityCall : public ::BaseCallMessage
{
  protected:
    OverlayKey destinationKey_var;

  private:
    void copy(const HCapacityCall& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const HCapacityCall&);

  public:
    HCapacityCall(const char *name=NULL, int kind=0);
    HCapacityCall(const HCapacityCall& other);
    virtual ~HCapacityCall();
    HCapacityCall& operator=(const HCapacityCall& other);
    virtual HCapacityCall *dup() const {return new HCapacityCall(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual OverlayKey& getDestinationKey();
    virtual const OverlayKey& getDestinationKey() const {return const_cast<HCapacityCall*>(this)->getDestinationKey();}
    virtual void setDestinationKey(const OverlayKey& destinationKey);
};

inline void doPacking(cCommBuffer *b, HCapacityCall& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, HCapacityCall& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>./HMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet HCapacityResponse extends BaseResponseMessage {
 *     NodeHandle respondingNode;
 *     int capacity;						
 * };
 * </pre>
 */
class HCapacityResponse : public ::BaseResponseMessage
{
  protected:
    NodeHandle respondingNode_var;
    int capacity_var;

  private:
    void copy(const HCapacityResponse& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const HCapacityResponse&);

  public:
    HCapacityResponse(const char *name=NULL, int kind=0);
    HCapacityResponse(const HCapacityResponse& other);
    virtual ~HCapacityResponse();
    HCapacityResponse& operator=(const HCapacityResponse& other);
    virtual HCapacityResponse *dup() const {return new HCapacityResponse(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual NodeHandle& getRespondingNode();
    virtual const NodeHandle& getRespondingNode() const {return const_cast<HCapacityResponse*>(this)->getRespondingNode();}
    virtual void setRespondingNode(const NodeHandle& respondingNode);
    virtual int getCapacity() const;
    virtual void setCapacity(int capacity);
};

inline void doPacking(cCommBuffer *b, HCapacityResponse& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, HCapacityResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>./HMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet HSelectParentCall extends BaseCallMessage {
 *     OverlayKey key;
 * };
 * </pre>
 */
class HSelectParentCall : public ::BaseCallMessage
{
  protected:
    OverlayKey key_var;

  private:
    void copy(const HSelectParentCall& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const HSelectParentCall&);

  public:
    HSelectParentCall(const char *name=NULL, int kind=0);
    HSelectParentCall(const HSelectParentCall& other);
    virtual ~HSelectParentCall();
    HSelectParentCall& operator=(const HSelectParentCall& other);
    virtual HSelectParentCall *dup() const {return new HSelectParentCall(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual OverlayKey& getKey();
    virtual const OverlayKey& getKey() const {return const_cast<HSelectParentCall*>(this)->getKey();}
    virtual void setKey(const OverlayKey& key);
};

inline void doPacking(cCommBuffer *b, HSelectParentCall& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, HSelectParentCall& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>./HMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet HSelectParentResponse extends BaseResponseMessage {
 *     NodeHandle respondingNode;
 *     
 * };
 * </pre>
 */
class HSelectParentResponse : public ::BaseResponseMessage
{
  protected:
    NodeHandle respondingNode_var;

  private:
    void copy(const HSelectParentResponse& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const HSelectParentResponse&);

  public:
    HSelectParentResponse(const char *name=NULL, int kind=0);
    HSelectParentResponse(const HSelectParentResponse& other);
    virtual ~HSelectParentResponse();
    HSelectParentResponse& operator=(const HSelectParentResponse& other);
    virtual HSelectParentResponse *dup() const {return new HSelectParentResponse(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual NodeHandle& getRespondingNode();
    virtual const NodeHandle& getRespondingNode() const {return const_cast<HSelectParentResponse*>(this)->getRespondingNode();}
    virtual void setRespondingNode(const NodeHandle& respondingNode);
};

inline void doPacking(cCommBuffer *b, HSelectParentResponse& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, HSelectParentResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>./HMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet HJoinCall extends BaseCallMessage
 * {
 * }
 * </pre>
 */
class HJoinCall : public ::BaseCallMessage
{
  protected:

  private:
    void copy(const HJoinCall& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const HJoinCall&);

  public:
    HJoinCall(const char *name=NULL, int kind=0);
    HJoinCall(const HJoinCall& other);
    virtual ~HJoinCall();
    HJoinCall& operator=(const HJoinCall& other);
    virtual HJoinCall *dup() const {return new HJoinCall(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, HJoinCall& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, HJoinCall& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>./HMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet HJoinResponse extends BaseResponseMessage
 * {
 *     int sucNum;    
 *     NodeHandle sucNode[];    
 *     NodeHandle preNode;    
 * }
 * </pre>
 */
class HJoinResponse : public ::BaseResponseMessage
{
  protected:
    int sucNum_var;
    NodeHandle *sucNode_var; // array ptr
    unsigned int sucNode_arraysize;
    NodeHandle preNode_var;

  private:
    void copy(const HJoinResponse& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const HJoinResponse&);

  public:
    HJoinResponse(const char *name=NULL, int kind=0);
    HJoinResponse(const HJoinResponse& other);
    virtual ~HJoinResponse();
    HJoinResponse& operator=(const HJoinResponse& other);
    virtual HJoinResponse *dup() const {return new HJoinResponse(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getSucNum() const;
    virtual void setSucNum(int sucNum);
    virtual void setSucNodeArraySize(unsigned int size);
    virtual unsigned int getSucNodeArraySize() const;
    virtual NodeHandle& getSucNode(unsigned int k);
    virtual const NodeHandle& getSucNode(unsigned int k) const {return const_cast<HJoinResponse*>(this)->getSucNode(k);}
    virtual void setSucNode(unsigned int k, const NodeHandle& sucNode);
    virtual NodeHandle& getPreNode();
    virtual const NodeHandle& getPreNode() const {return const_cast<HJoinResponse*>(this)->getPreNode();}
    virtual void setPreNode(const NodeHandle& preNode);
};

inline void doPacking(cCommBuffer *b, HJoinResponse& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, HJoinResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>./HMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet HMessage {
 *     int type enum(MessageType);			
 *     TransportAddress senderAddress;		
 *     int nodeID;							
 *     int parentID;						
 *     int optionalParameter;				
 *     string anyMessage;					
 * };
 * </pre>
 */
class HMessage : public ::cPacket
{
  protected:
    int type_var;
    TransportAddress senderAddress_var;
    int nodeID_var;
    int parentID_var;
    int optionalParameter_var;
    opp_string anyMessage_var;

  private:
    void copy(const HMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const HMessage&);

  public:
    HMessage(const char *name=NULL, int kind=0);
    HMessage(const HMessage& other);
    virtual ~HMessage();
    HMessage& operator=(const HMessage& other);
    virtual HMessage *dup() const {return new HMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getType() const;
    virtual void setType(int type);
    virtual TransportAddress& getSenderAddress();
    virtual const TransportAddress& getSenderAddress() const {return const_cast<HMessage*>(this)->getSenderAddress();}
    virtual void setSenderAddress(const TransportAddress& senderAddress);
    virtual int getNodeID() const;
    virtual void setNodeID(int nodeID);
    virtual int getParentID() const;
    virtual void setParentID(int parentID);
    virtual int getOptionalParameter() const;
    virtual void setOptionalParameter(int optionalParameter);
    virtual const char * getAnyMessage() const;
    virtual void setAnyMessage(const char * anyMessage);
};

inline void doPacking(cCommBuffer *b, HMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, HMessage& obj) {obj.parsimUnpack(b);}


#endif // _HMESSAGE_M_H_
