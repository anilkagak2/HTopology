//
// Generated file, do not edit! Created by opp_msgc 4.3 from overlay/chord/ChordMessage.msg.
//

#ifndef _CHORDMESSAGE_M_H_
#define _CHORDMESSAGE_M_H_

#include <omnetpp.h>

// opp_msgc version check
#define MSGC_VERSION 0x0403
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of opp_msgc: 'make clean' should help.
#endif

// cplusplus {{
#include <IPvXAddress.h>
#include <NodeHandle.h>
#include <TransportAddress.h>
#include <CommonMessages_m.h>


static const int CHORDCOMMAND_L = 8;
static const int SUCNUM_L = 8;
static const int FINGER_L = 8;
static const int STEP_L = 8;
static const int PRENODESET_L = 1;

#define NEWSUCCESSORHINT_L(msg) (BASEOVERLAY_L(msg) + CHORDCOMMAND_L + \
                                 2*NODEHANDLE_L)
#define NOTIFYCALL_L(msg) (BASECALL_L(msg))
#define NOTIFYRESPONSE_L(msg) (BASERESPONSE_L(msg) + SUCNUM_L + NODEHANDLE_L +\
			      (msg->getSucNodeArraySize() * NODEHANDLE_L) +\
                  PRENODESET_L)
#define JOINCALL_L(msg) BASECALL_L(msg)
#define JOINRESPONSE_L(msg) (BASERESPONSE_L(msg) + SUCNUM_L + NODEHANDLE_L +\
                             (msg->getSucNodeArraySize() * NODEHANDLE_L))
#define STABILIZECALL_L(msg) BASECALL_L(msg)
#define STABILIZERESPONSE_L(msg) (BASERESPONSE_L(msg) + NODEHANDLE_L)
#define FIXFINGERSCALL_L(msg) (BASECALL_L(msg) + FINGER_L)
#define FIXFINGERSRESPONSE_L(msg) (BASERESPONSE_L(msg) + FINGER_L + \
                                   NODEHANDLE_L + SUCNUM_L + \
                                   (msg->getSucNodeArraySize() * NODEHANDLE_L))
#define DEBRUIJNCALL_L(msg) (BASECALL_L(msg) + KEY_L)
#define DEBRUIJNRESPONSE_L(msg) (BASERESPONSE_L(msg) + SUCNUM_L + NODEHANDLE_L + \
				 (msg->getSucNodeArraySize() * NODEHANDLE_L)) 

#define KOORDEFINDNODEEXTMESSAGE_L (KEY_L + STEP_L)
// }}



/**
 * Enum generated from <tt>overlay/chord/ChordMessage.msg</tt> by opp_msgc.
 * <pre>
 * enum ChordCommand
 * {
 * 
 *     NEWSUCCESSORHINT = 0;
 * }
 * </pre>
 */
enum ChordCommand {
    NEWSUCCESSORHINT = 0
};

/**
 * Class generated from <tt>overlay/chord/ChordMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet ChordMessage extends BaseOverlayMessage
 * {
 *     int command enum(ChordCommand);    
 * }
 * </pre>
 */
class ChordMessage : public ::BaseOverlayMessage
{
  protected:
    int command_var;

  private:
    void copy(const ChordMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ChordMessage&);

  public:
    ChordMessage(const char *name=NULL, int kind=0);
    ChordMessage(const ChordMessage& other);
    virtual ~ChordMessage();
    ChordMessage& operator=(const ChordMessage& other);
    virtual ChordMessage *dup() const {return new ChordMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getCommand() const;
    virtual void setCommand(int command);
};

inline void doPacking(cCommBuffer *b, ChordMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, ChordMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/chord/ChordMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet NewSuccessorHintMessage extends ChordMessage
 * {
 *     NodeHandle srcNode;    
 *     NodeHandle preNode;    
 * }
 * </pre>
 */
class NewSuccessorHintMessage : public ::ChordMessage
{
  protected:
    NodeHandle srcNode_var;
    NodeHandle preNode_var;

  private:
    void copy(const NewSuccessorHintMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NewSuccessorHintMessage&);

  public:
    NewSuccessorHintMessage(const char *name=NULL, int kind=0);
    NewSuccessorHintMessage(const NewSuccessorHintMessage& other);
    virtual ~NewSuccessorHintMessage();
    NewSuccessorHintMessage& operator=(const NewSuccessorHintMessage& other);
    virtual NewSuccessorHintMessage *dup() const {return new NewSuccessorHintMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual NodeHandle& getSrcNode();
    virtual const NodeHandle& getSrcNode() const {return const_cast<NewSuccessorHintMessage*>(this)->getSrcNode();}
    virtual void setSrcNode(const NodeHandle& srcNode);
    virtual NodeHandle& getPreNode();
    virtual const NodeHandle& getPreNode() const {return const_cast<NewSuccessorHintMessage*>(this)->getPreNode();}
    virtual void setPreNode(const NodeHandle& preNode);
};

inline void doPacking(cCommBuffer *b, NewSuccessorHintMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, NewSuccessorHintMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/chord/ChordMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet NotifyCall extends BaseCallMessage
 * {
 *     TransportAddress failed = TransportAddress::UNSPECIFIED_NODE;
 * }
 * </pre>
 */
class NotifyCall : public ::BaseCallMessage
{
  protected:
    TransportAddress failed_var;

  private:
    void copy(const NotifyCall& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NotifyCall&);

  public:
    NotifyCall(const char *name=NULL, int kind=0);
    NotifyCall(const NotifyCall& other);
    virtual ~NotifyCall();
    NotifyCall& operator=(const NotifyCall& other);
    virtual NotifyCall *dup() const {return new NotifyCall(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual TransportAddress& getFailed();
    virtual const TransportAddress& getFailed() const {return const_cast<NotifyCall*>(this)->getFailed();}
    virtual void setFailed(const TransportAddress& failed);
};

inline void doPacking(cCommBuffer *b, NotifyCall& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, NotifyCall& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/chord/ChordMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet NotifyResponse extends BaseResponseMessage
 * {
 *     int sucNum;    
 *     NodeHandle sucNode[];    
 *     NodeHandle preNode;    
 *     bool preNodeSet; 
 * }
 * </pre>
 */
class NotifyResponse : public ::BaseResponseMessage
{
  protected:
    int sucNum_var;
    NodeHandle *sucNode_var; // array ptr
    unsigned int sucNode_arraysize;
    NodeHandle preNode_var;
    bool preNodeSet_var;

  private:
    void copy(const NotifyResponse& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NotifyResponse&);

  public:
    NotifyResponse(const char *name=NULL, int kind=0);
    NotifyResponse(const NotifyResponse& other);
    virtual ~NotifyResponse();
    NotifyResponse& operator=(const NotifyResponse& other);
    virtual NotifyResponse *dup() const {return new NotifyResponse(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getSucNum() const;
    virtual void setSucNum(int sucNum);
    virtual void setSucNodeArraySize(unsigned int size);
    virtual unsigned int getSucNodeArraySize() const;
    virtual NodeHandle& getSucNode(unsigned int k);
    virtual const NodeHandle& getSucNode(unsigned int k) const {return const_cast<NotifyResponse*>(this)->getSucNode(k);}
    virtual void setSucNode(unsigned int k, const NodeHandle& sucNode);
    virtual NodeHandle& getPreNode();
    virtual const NodeHandle& getPreNode() const {return const_cast<NotifyResponse*>(this)->getPreNode();}
    virtual void setPreNode(const NodeHandle& preNode);
    virtual bool getPreNodeSet() const;
    virtual void setPreNodeSet(bool preNodeSet);
};

inline void doPacking(cCommBuffer *b, NotifyResponse& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, NotifyResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/chord/ChordMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet JoinCall extends BaseCallMessage
 * {
 * }
 * </pre>
 */
class JoinCall : public ::BaseCallMessage
{
  protected:

  private:
    void copy(const JoinCall& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const JoinCall&);

  public:
    JoinCall(const char *name=NULL, int kind=0);
    JoinCall(const JoinCall& other);
    virtual ~JoinCall();
    JoinCall& operator=(const JoinCall& other);
    virtual JoinCall *dup() const {return new JoinCall(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, JoinCall& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, JoinCall& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/chord/ChordMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet JoinResponse extends BaseResponseMessage
 * {
 *     int sucNum;    
 *     NodeHandle sucNode[];    
 *     NodeHandle preNode;    
 * }
 * </pre>
 */
class JoinResponse : public ::BaseResponseMessage
{
  protected:
    int sucNum_var;
    NodeHandle *sucNode_var; // array ptr
    unsigned int sucNode_arraysize;
    NodeHandle preNode_var;

  private:
    void copy(const JoinResponse& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const JoinResponse&);

  public:
    JoinResponse(const char *name=NULL, int kind=0);
    JoinResponse(const JoinResponse& other);
    virtual ~JoinResponse();
    JoinResponse& operator=(const JoinResponse& other);
    virtual JoinResponse *dup() const {return new JoinResponse(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getSucNum() const;
    virtual void setSucNum(int sucNum);
    virtual void setSucNodeArraySize(unsigned int size);
    virtual unsigned int getSucNodeArraySize() const;
    virtual NodeHandle& getSucNode(unsigned int k);
    virtual const NodeHandle& getSucNode(unsigned int k) const {return const_cast<JoinResponse*>(this)->getSucNode(k);}
    virtual void setSucNode(unsigned int k, const NodeHandle& sucNode);
    virtual NodeHandle& getPreNode();
    virtual const NodeHandle& getPreNode() const {return const_cast<JoinResponse*>(this)->getPreNode();}
    virtual void setPreNode(const NodeHandle& preNode);
};

inline void doPacking(cCommBuffer *b, JoinResponse& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, JoinResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/chord/ChordMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet StabilizeCall extends BaseCallMessage
 * {
 * }
 * </pre>
 */
class StabilizeCall : public ::BaseCallMessage
{
  protected:

  private:
    void copy(const StabilizeCall& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const StabilizeCall&);

  public:
    StabilizeCall(const char *name=NULL, int kind=0);
    StabilizeCall(const StabilizeCall& other);
    virtual ~StabilizeCall();
    StabilizeCall& operator=(const StabilizeCall& other);
    virtual StabilizeCall *dup() const {return new StabilizeCall(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, StabilizeCall& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, StabilizeCall& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/chord/ChordMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet StabilizeResponse extends BaseResponseMessage
 * {
 *     NodeHandle preNode;    
 * }
 * </pre>
 */
class StabilizeResponse : public ::BaseResponseMessage
{
  protected:
    NodeHandle preNode_var;

  private:
    void copy(const StabilizeResponse& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const StabilizeResponse&);

  public:
    StabilizeResponse(const char *name=NULL, int kind=0);
    StabilizeResponse(const StabilizeResponse& other);
    virtual ~StabilizeResponse();
    StabilizeResponse& operator=(const StabilizeResponse& other);
    virtual StabilizeResponse *dup() const {return new StabilizeResponse(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual NodeHandle& getPreNode();
    virtual const NodeHandle& getPreNode() const {return const_cast<StabilizeResponse*>(this)->getPreNode();}
    virtual void setPreNode(const NodeHandle& preNode);
};

inline void doPacking(cCommBuffer *b, StabilizeResponse& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, StabilizeResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/chord/ChordMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet FixfingersCall extends BaseCallMessage
 * {
 *     int finger;    
 * }
 * </pre>
 */
class FixfingersCall : public ::BaseCallMessage
{
  protected:
    int finger_var;

  private:
    void copy(const FixfingersCall& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const FixfingersCall&);

  public:
    FixfingersCall(const char *name=NULL, int kind=0);
    FixfingersCall(const FixfingersCall& other);
    virtual ~FixfingersCall();
    FixfingersCall& operator=(const FixfingersCall& other);
    virtual FixfingersCall *dup() const {return new FixfingersCall(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getFinger() const;
    virtual void setFinger(int finger);
};

inline void doPacking(cCommBuffer *b, FixfingersCall& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, FixfingersCall& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/chord/ChordMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet FixfingersResponse extends BaseResponseMessage
 * {
 *     int finger;    
 *     NodeHandle sucNode[];    
 * }
 * </pre>
 */
class FixfingersResponse : public ::BaseResponseMessage
{
  protected:
    int finger_var;
    NodeHandle *sucNode_var; // array ptr
    unsigned int sucNode_arraysize;

  private:
    void copy(const FixfingersResponse& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const FixfingersResponse&);

  public:
    FixfingersResponse(const char *name=NULL, int kind=0);
    FixfingersResponse(const FixfingersResponse& other);
    virtual ~FixfingersResponse();
    FixfingersResponse& operator=(const FixfingersResponse& other);
    virtual FixfingersResponse *dup() const {return new FixfingersResponse(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getFinger() const;
    virtual void setFinger(int finger);
    virtual void setSucNodeArraySize(unsigned int size);
    virtual unsigned int getSucNodeArraySize() const;
    virtual NodeHandle& getSucNode(unsigned int k);
    virtual const NodeHandle& getSucNode(unsigned int k) const {return const_cast<FixfingersResponse*>(this)->getSucNode(k);}
    virtual void setSucNode(unsigned int k, const NodeHandle& sucNode);
};

inline void doPacking(cCommBuffer *b, FixfingersResponse& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, FixfingersResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/chord/ChordMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet KoordeFindNodeExtMessage
 * {
 *     OverlayKey routeKey;    
 *     int step;             
 * }
 * </pre>
 */
class KoordeFindNodeExtMessage : public ::cPacket
{
  protected:
    OverlayKey routeKey_var;
    int step_var;

  private:
    void copy(const KoordeFindNodeExtMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const KoordeFindNodeExtMessage&);

  public:
    KoordeFindNodeExtMessage(const char *name=NULL, int kind=0);
    KoordeFindNodeExtMessage(const KoordeFindNodeExtMessage& other);
    virtual ~KoordeFindNodeExtMessage();
    KoordeFindNodeExtMessage& operator=(const KoordeFindNodeExtMessage& other);
    virtual KoordeFindNodeExtMessage *dup() const {return new KoordeFindNodeExtMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual OverlayKey& getRouteKey();
    virtual const OverlayKey& getRouteKey() const {return const_cast<KoordeFindNodeExtMessage*>(this)->getRouteKey();}
    virtual void setRouteKey(const OverlayKey& routeKey);
    virtual int getStep() const;
    virtual void setStep(int step);
};

inline void doPacking(cCommBuffer *b, KoordeFindNodeExtMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, KoordeFindNodeExtMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/chord/ChordMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet DeBruijnCall extends BaseCallMessage
 * {
 *     OverlayKey destKey;    
 * }
 * </pre>
 */
class DeBruijnCall : public ::BaseCallMessage
{
  protected:
    OverlayKey destKey_var;

  private:
    void copy(const DeBruijnCall& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const DeBruijnCall&);

  public:
    DeBruijnCall(const char *name=NULL, int kind=0);
    DeBruijnCall(const DeBruijnCall& other);
    virtual ~DeBruijnCall();
    DeBruijnCall& operator=(const DeBruijnCall& other);
    virtual DeBruijnCall *dup() const {return new DeBruijnCall(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual OverlayKey& getDestKey();
    virtual const OverlayKey& getDestKey() const {return const_cast<DeBruijnCall*>(this)->getDestKey();}
    virtual void setDestKey(const OverlayKey& destKey);
};

inline void doPacking(cCommBuffer *b, DeBruijnCall& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, DeBruijnCall& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/chord/ChordMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet DeBruijnResponse extends BaseResponseMessage
 * {
 *     NodeHandle dBNode;
 *     int sucNum;    
 *     NodeHandle sucNode[];   
 * }
 * </pre>
 */
class DeBruijnResponse : public ::BaseResponseMessage
{
  protected:
    NodeHandle dBNode_var;
    int sucNum_var;
    NodeHandle *sucNode_var; // array ptr
    unsigned int sucNode_arraysize;

  private:
    void copy(const DeBruijnResponse& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const DeBruijnResponse&);

  public:
    DeBruijnResponse(const char *name=NULL, int kind=0);
    DeBruijnResponse(const DeBruijnResponse& other);
    virtual ~DeBruijnResponse();
    DeBruijnResponse& operator=(const DeBruijnResponse& other);
    virtual DeBruijnResponse *dup() const {return new DeBruijnResponse(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual NodeHandle& getDBNode();
    virtual const NodeHandle& getDBNode() const {return const_cast<DeBruijnResponse*>(this)->getDBNode();}
    virtual void setDBNode(const NodeHandle& dBNode);
    virtual int getSucNum() const;
    virtual void setSucNum(int sucNum);
    virtual void setSucNodeArraySize(unsigned int size);
    virtual unsigned int getSucNodeArraySize() const;
    virtual NodeHandle& getSucNode(unsigned int k);
    virtual const NodeHandle& getSucNode(unsigned int k) const {return const_cast<DeBruijnResponse*>(this)->getSucNode(k);}
    virtual void setSucNode(unsigned int k, const NodeHandle& sucNode);
};

inline void doPacking(cCommBuffer *b, DeBruijnResponse& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, DeBruijnResponse& obj) {obj.parsimUnpack(b);}


#endif // _CHORDMESSAGE_M_H_
